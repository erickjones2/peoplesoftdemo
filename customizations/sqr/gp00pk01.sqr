!***********************************************************************
!   GP00PK01:  Rules Package Compare Report                            *
!***********************************************************************
!***********************************************************************
!                                                                      *
!                                                                      *
!                                                                      *
!                                                                      *
! This software and related documentation are provided under a         *
! license agreement containing restrictions on use and                 *
! disclosure and are protected by intellectual property                *
! laws. Except as expressly permitted in your license agreement        *
! or allowed by law, you may not use, copy, reproduce,                 *
! translate, broadcast, modify, license, transmit, distribute,         *
! exhibit, perform, publish or display any part, in any form or        *
! by any means. Reverse engineering, disassembly, or                   *
! decompilation of this software, unless required by law for           *
! interoperability, is prohibited.                                     *
! The information contained herein is subject to change without        *
! notice and is not warranted to be error-free. If you find any        *
! errors, please report them to us in writing.                         *
!                                                                      *
!                                                                      *
! Copyright (C) 1988, 2016, Oracle and/or its affiliates.              *
! All Rights Reserved.                                                 *
!***********************************************************************
!                                                                      *
!       $Release:  HR92                                                !
!           $Bug:  20972602                                            !
!                                                                      *
!***********************************************************************

#include 'setenv.sqc'   !Set environment
#include 'setup32.sqc'  !Printer and page-size initialization, SETUP31 and
                        !  SETUP32 SQCs to support HTML, HP PCL, PostScript,
                        !  PDF and Window in addition to Line Printer as
                        !  the output type.

! Change History
! Incident ID    Dated     Comments
!
!***********************************************************************
! begin-report                                                         *                                                          *
!                                                                      *
! Called By: N/A                                                       *
! Calls:   Init-Processing                                             *
!            Get-Values                                                *
!            Process-Main                                              *
!            Reset                                                     *
!            Delete-From-AE-Tables                                     *
!            End-Report                                                *
!***********************************************************************

begin-report


  do Init-Processing

  do Get-Values

  do Process-Main

  do Reset                                   ! called from reset.sqc

  do Update-Prcs-Run-Status       ! called from prcsapi.sqc to update the Process Monitor to Success

end-report



begin-procedure Init-Processing

  do Init-Datetime                ! called from datetime.sqc

  do Get-Current-Datetime         ! called from prcsapi.sqc (curdttim.sqc)

  do Define-Prcs-Vars             ! called from prcsapi.sqc (prcsdef.sqc)

  do Get-Run-Control-Parms        ! In prcsapi.sqc
  
  If $prcs_run_cntl_id = 'ADHOC' and #prcs_process_instance = 0
  
  do Modify-Run-Control           ! if called from Change Assistant for PeopleSoft Update Manager

  End-if

  do Init-Number                  ! called from number.sqc

  do Get-Language-Codes           ! called from prcslng.sqc

  do Security-Param


end-procedure !Init-Processing

begin-procedure Modify-Run-Control

BEGIN-SELECT
GP_PKG_ID  &GPPackageID

  let $prcs_run_cntl_id = &GPPackageID

FROM PS_GP_PKG_DFN
WHERE PKG_COMPARE_DTTM = (SELECT MAX(PKG_COMPARE_DTTM) 
FROM PS_GP_PKG_DFN WHERE PKG_UPGRADE_DTTM IS NULL AND PKG_COMPARE_DTTM IS NOT NULL)

END-SELECT

end-procedure

begin-procedure Process-Main

 do Check-Report-Type

 do Get-Print-Options

 do Get-LastProcessInstanceID    ! Retrieve the last instance ID of the JOB

 do Get-Target-DBName
 
 do Init-Report

 If rtrim(&PKG_COMPARE_DTTM,' ') <> ''

    do Print-Summary

    do Process-Countries-except-ALL

    do Process-Country-ALL
 else
    print $NO_RPT_Lbl (15) BOLD center
 End-if

end-procedure !Process-Main

!**********************************
!begin-procedure Check-Report-Type
!**********************************
begin-procedure Check-Report-Type
BEGIN-SELECT
GP_PKG_ID
GP_VERSION_IND
DESCR   &pkgDescr
GPDBNAME
PKG_COMPARE_DTTM
PKG_IMPORT_DTTM

   Let $pkgDescr = rtrim(&pkgDescr,' ')

   FROM PS_GP_PKG_DFN
     WHERE GP_PKG_ID = $GP_PKG_ID
END-SELECT

End-procedure !Check-Report-Type

!**********************************
!begin-procedure Get-Target-DBName
!**********************************
begin-procedure Get-Target-DBName
BEGIN-SELECT
RQ.DBNAME
  FROM PSPRCSPARMS OD , PSPRCSRQST  RQ
    WHERE OD.PRCSINSTANCE  = RQ.PRCSINSTANCE
      AND RQ.PRCSINSTANCE = #LastInstance
end-select
end-procedure ! Get-Target-DBName

!**********************************
!begin-procedure Get-Print-Options
!**********************************
begin-procedure Get-Print-Options
BEGIN-SELECT
PRINT_ERR_WARN_IND
PRINT_MOD_IND
PRINT_NEW_IND
PRINT_DEL_IND
PRINT_UNCHG_IND
  FROM PS_GP_PKG_RUNCTL RUNCTL
      WHERE RUNCTL.OPRID= $prcs_oprid
        AND RUNCTL.RUN_CNTL_ID=$prcs_run_cntl_id
end-select
end-procedure ! Get-Print-Options

!**************************
!begin-procedure Init-Report
!**************************
begin-procedure Init-Report
! Column definitons
!Transaction Columns
  #define Col_1         1
  #define Col_2         5
  #define Col_3         4

  #define Col_4         20
  #define Col_4b        17
  #define Col_4a        24
  #define Col_4c        19

  #define Col_5         49
  #define Col_5a        50
  #define Col_6         10

  #define Col_7         75
  #define Col_7a        91
  #define Col_7b        93

  #define Col_8         75
  #define Col_8a        72
  #define Col_9         130
  #define Col_10        152
  #define Col_10a       154

  #define SCol_1        7
  #define SCol_1a       11
  #define SCol_2        35
  #define SCol_3        50
  #define SCol_3a       59
  #define SCol_4        90
  #define SCol_4a       98

  #define MaxFMLCol     47


!Transaction Rows
  #define Row_1         15

! Translations procedures & Strings Table retrievals.

  do Init_Report_Translation ($ReportID,$curr_Language_Cd)
  do Append_Report_Translation ('GP00PK01')

  do Get_Field_Information ('GP00PK01 ','RULE PCKG',    $RULE_PCKG_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','RPT TYPE',     $RPT_TYPE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','PCKG NAME',    $PCKG_NAME_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','SOURCE DB',    $SOURCE_DB_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','TRGT DB',      $TRGT_DB_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','IMPORTED AT',  $IMPORTED_AT_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','CMPRD AT',     $CMPRD_AT_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','VERSION',      $VERSION_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','ELEMENT',      $ELEMENT_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','RCD.FLD',      $RCD_FLD_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','PIN CODE',     $PIN_CODE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','PIN TYPE',     $PIN_TYPE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','UPGRD ACTION', $UPGRD_ACTION_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','CMPR STATUS',  $CMPR_STATUS_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','CMPR RPT',     $CMPR_RPT_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','GPPIN',        $GPPIN_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NAME',         $NAME_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','PINNUM',       $PINNUM_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','DESCR',        $DESCR_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','COMMENTS',     $COMMENTS_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','UPGRD',        $UPGRD_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','MOD ELE',      $MOD_ELE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','ERRORFAIL',    $ERRORFAIL_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NEWELE',       $NEWELE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','DELELE',       $DELELE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','UNCHANGEDELE', $UNCHANGEDELE_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','FORMTEXT',     $FORMTEXT_lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','VERSIONPKG',   $GPVersionLbl,#DW)
  do Get_Field_Information ('GP00PK01 ','SUMMARY',      $SUMMARY_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','COUNTRY',      $COUNTRY_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','RULE PKG DTL', $RULE_PKG_DTL_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','RULE PKG TYPE',$RULE_PKG_TYPE_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','REG',          $REG_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','VER IN PKG',   $VER_IN_PKG_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','CMPR RPT DTL', $CMPR_RPT_DTL_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','CTRY IN PKG',  $CTRY_IN_PKG_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','PRINT OPTNS',  $PRINT_OPTNS_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NO OF ELEM',   $NO_OF_ELEM_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','ERR WARN',     $ERR_WARN_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','MOD',          $MOD_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NEW',          $NEW_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','DEL',          $DEL_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','UNCHG',        $UNCHG_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','YES',          $YES_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NO',           $NO_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NO DATA',      $NO_DATA_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','ALL DESCR',    $ALL_DESCR_Lbl,#DW)
  do Get_Field_Information ('GP00PK01 ','NO RPT',       $NO_RPT_Lbl,#DW)


! Initialize date formatting.

  Let $RPT_TYPE_1_lbl  = rtrim($RPT_TYPE_lbl,' ') || ':'
  Let $RPT_TYPE_2_lbl  = rtrim($RPT_TYPE_lbl,' ')
  Let $PCKG_NAME_lbl = rtrim($PCKG_NAME_lbl,' ') || ':'
  Let $SOURCE_DB_1_lbl = rtrim($SOURCE_DB_lbl,' ') || ':'
  Let $SOURCE_DB_2_lbl = rtrim($SOURCE_DB_lbl,' ')
  Let $TRGT_DB_1_lbl   = rtrim($TRGT_DB_lbl,' ') || ':'
  Let $TRGT_DB_2_lbl   = rtrim($TRGT_DB_lbl,' ')
  Let $IMPORTED_AT_lbl = rtrim($IMPORTED_AT_lbl,' ') || ':'
  Let $CMPRD_AT_lbl  = rtrim($CMPRD_AT_lbl,' ') || ':'
  Let $PIN_CODE_lbl  = rtrim($PIN_CODE_lbl,' ') || ':'
  Let $PIN_TYPE_lbl  = rtrim($PIN_TYPE_lbl,' ') || ':'
  Let $UPGRD_ACTION_lbl = rtrim($UPGRD_ACTION_lbl,' ') || ':'
  Let $UPGRD_lbl = rtrim($UPGRD_lbl,' ') || ':'
  Let $CMPR_STATUS_lbl = rtrim($CMPR_STATUS_lbl,' ') || ':'
  Let $COUNTRY_lbl = rtrim($COUNTRY_lbl,' ') || ':'
  Let $RULE_PKG_TYPE_lbl = rtrim($RULE_PKG_TYPE_lbl,' ') || ':'
  Let $VER_IN_PKG_lbl = rtrim($VER_IN_PKG_lbl,' ') || ':'
  Let $CTRY_IN_PKG_lbl = rtrim($CTRY_IN_PKG_lbl,' ') || ':'
  Let $ALL_DESCR_lbl = rtrim($ALL_DESCR_lbl,' ')

    let $Date_Init = '1900-01-01 00:00:00.000'

    #ifdef ORACLE
           let $Date_Init = '01-NOV-1999'
    #end-if

    do Format-DateTime($Date_Init, $out999, {DEFDATE}, '', '')
! Report variables.
  let $ReportID       = 'GP00PK01'
! Report title will be populated when we retrieve the package description
  let $ReportTitle    = $RULE_PCKG_lbl || ': ' || rtrim(&GP_PKG_ID,' ') || ' (' || $pkgDescr || ') ' || $CMPR_RPT_lbl

  let $pagenew='false'

   Let $chr13 = chr(13)
   Let $chr10 = chr(10)

   Let $finalReformat = 'N'
   let $matchMakeEnabled = 0 ! this flag is set to 1 by the matchmaking procedure. If the procedure call is disabled
                             ! we dont want to scan for line type identifiers during the printing routine.

   Let $ShowDebugInfo = 'N'
   Let $GraphicEnabledInMatch = 'Y'
   let #GlobalDepth = 1
   let $DataFound = 'N'
end-procedure !Init-Report

!**********************************
!begin-procedure Print-Summary
!**********************************
begin-procedure Print-Summary

  let $SummaryPage='Y'
  Let $Rpt_type = $SUMMARY_lbl
  do Rule-Pkg-Dtl
  do Compare-Rpt-Dtl
  new-page
  let $SummaryPage='N'

end-procedure ! Print-Summary


!******************************
!begin-procedure Process-Countries-except-ALL
!******************************
begin-procedure Process-Countries-except-ALL
begin-SELECT DISTINCT
P7.COUNTRY

  let $Country=rtrim(&P7.COUNTRY,' ')
  do Get-Country-Descr
  let $Country_Dtl = &P7.COUNTRY||' ('||$Country_Descr||')'
  do Print-Sections
  if #current-line > 8
     New-page
  End-if

  FROM PS_GP_PKG_ELEMENTS P7
WHERE P7.GP_PKG_ID = &GP_PKG_ID
AND P7.COUNTRY <> 'ALL'
ORDER BY P7.COUNTRY
end-SELECT
end-procedure !Process-Countries-except-ALL

!***********************************
!begin-procedure Process-Country-ALL
!***********************************
begin-procedure Process-Country-ALL

  let $Country='ALL'
  let $Country_Dtl = $Country || ' (' || $ALL_DESCR_lbl || ')'
  do Print-Sections

end-procedure !Process-Country-ALL

!******************************
!begin-procedure Rule-Pkg-Dtl
!******************************
begin-procedure Rule-Pkg-Dtl
  print $RULE_PKG_DTL_Lbl (+1) BOLD
  print $RULE_PKG_TYPE_lbl (+1,{SCol_1})

  If &GP_VERSION_IND = 'Y'
     print $VERSION_lbl (,{SCol_2})
     print $VER_IN_PKG_lbl (+1,{SCol_1})

     do Print-Versions
  else
     print $REG_Lbl (,{SCol_2})
  End-if

   print  $SOURCE_DB_1_lbl (+2,{SCol_1})
   print &GPDBNAME (,{SCol_2})
   print $TRGT_DB_1_lbl (+1,{SCol_1})
   If #prcs_process_instance = 0
   print $database_name (,{SCol_2})
   Else
   print &RQ.DBNAME (,{SCol_2})
   End-If
   print  $IMPORTED_AT_lbl (+1,{SCol_1})
   print &PKG_IMPORT_DTTM  (,{SCol_2})
   print  $CMPRD_AT_lbl (+1,{SCol_1})
   print &PKG_COMPARE_DTTM  (,{SCol_2})

end-procedure !Rule-Pkg-Dtl

!******************************
!begin-procedure Compare-Rpt-Dtl
!******************************
begin-procedure Compare-Rpt-Dtl

  print $CMPR_RPT_DTL_Lbl (+3,1) BOLD
  print $CTRY_IN_PKG_lbl (+1,{SCol_1})

  do Print-Countries

  print $RPT_TYPE_2_lbl (+2,{SCol_1})
  print $PRINT_OPTNS_Lbl (,{SCol_3})
  print $NO_OF_ELEM_Lbl (,{SCol_4})

  print $ERR_WARN_Lbl (+1,{SCol_1a})
  If &PRINT_ERR_WARN_IND = 'Y'
     do Get-Err-Warn-Cnt
     print $YES_Lbl (,{SCol_3a})
     print &No_of_Err_Warn (,{SCol_4a})
  else
     print $NO_Lbl (,{SCol_3a})
     print '--' (,{SCol_4a})
  End-if

  print $MOD_Lbl (+1,{SCol_1a})
  If &PRINT_MOD_IND = 'Y'
     do Get-Mod-Cnt
     print $YES_Lbl (,{SCol_3a})
     print &No_of_Mod (,{SCol_4a})
  else
     print $NO_Lbl (,{SCol_3a})
     print '--' (,{SCol_4a})
  End-if

  print $NEW_Lbl (+1,{SCol_1a})
  If &PRINT_NEW_IND = 'Y'
     do Get-New-Cnt
     print $YES_Lbl (,{SCol_3a})
     print &No_of_New (,{SCol_4a})
  else
     print $NO_Lbl (,{SCol_3a})
     print '--' (,{SCol_4a})
  End-if

  print $DEL_Lbl (+1,{SCol_1a})
  If &PRINT_DEL_IND = 'Y'
     do Get-Del-Cnt
     print $YES_Lbl (,{SCol_3a})
    print &No_of_Del (,{SCol_4a})
  else
     print $NO_Lbl (,{SCol_3a})
     print '--' (,{SCol_4a})
  End-if

  print $UNCHG_Lbl (+1,{SCol_1a})
  If &PRINT_UNCHG_IND = 'Y'
     do Get-Unchg-Cnt
     print $YES_Lbl (,{SCol_3a})
     print &No_of_Unchg (,{SCol_4a})
  else
     print $NO_Lbl (,{SCol_3a})
     print '--' (,{SCol_4a})
  End-if


end-procedure !Compare-Rpt-Dtl

!******************************
!begin-procedure Print-Versions
!******************************
begin-procedure Print-Versions
POSITION (-1)
begin-SELECT
GP_VERSION

   print &GP_VERSION (+1,{SCol_2})

  FROM PS_GP_PKG_CRITVER1 VER
  WHERE VER.GP_PKG_ID = &GP_PKG_ID
end-select
end-procedure !Print-Versions

!******************************
!begin-procedure Print-Countries
!******************************
begin-procedure Print-Countries
POSITION (-1)
begin-SELECT DISTINCT
P1.COUNTRY

   let $Country=&P1.COUNTRY
   do Get-Country-Descr
   let $Country_Dtl = &P1.COUNTRY||' ('||$Country_Descr||')'
   print $Country_Dtl (+1,{SCol_2})

  FROM PS_GP_PKG_ELEMENTS P1
WHERE P1.GP_PKG_ID = &GP_PKG_ID
AND P1.COUNTRY <> 'ALL'
AND (P1.GP_PKG_ELEM_CMP_ST IN ('F','W')
OR (P1.GP_PKG_ELEM_CMP_ST='S'
    AND P1.GP_PKG_UPG_OPTN='Y'
    AND P1.GP_PKG_UPG_ACTION <> 'I'))
ORDER BY P1.COUNTRY
end-SELECT

begin-SELECT
'X'

   let $Country = 'ALL'
   let $Country_Dtl = $Country || ' (' || $ALL_DESCR_lbl || ')'
   print $Country_Dtl (+1,{SCol_2})

  FROM PS_INSTALLATION
WHERE EXISTS
(SELECT
'X'
FROM
PS_GP_PKG_ELEMENTS P11
WHERE P11.GP_PKG_ID = &GP_PKG_ID
AND P11.COUNTRY = 'ALL'
AND (P11.GP_PKG_ELEM_CMP_ST IN ('F','W')
OR (P11.GP_PKG_ELEM_CMP_ST='S'
    AND P11.GP_PKG_UPG_OPTN='Y'
    AND P11.GP_PKG_UPG_ACTION <> 'I')))
end-SELECT
end-procedure !Print-Countries

!******************************
!begin-procedure Get-Err-Warn-Cnt
!******************************
begin-procedure Get-Err-Warn-Cnt

begin-SELECT
COUNT(*) &No_of_Err_Warn
FROM PS_GP_PKG_ELEMENTS P2
where P2.GP_PKG_ID = &GP_PKG_ID
AND P2.GP_PKG_ELEM_CMP_ST in ('F', 'W')
end-SELECT
end-procedure !Get-Err-Warn-Cnt

!******************************
!begin-procedure Get-Mod-Cnt
!******************************
begin-procedure Get-Mod-Cnt

begin-SELECT
COUNT(*) &No_of_Mod
FROM PS_GP_PKG_ELEMENTS P3
where P3.GP_PKG_ID = &GP_PKG_ID
AND P3.GP_PKG_ELEM_CMP_ST ='S'
AND EXISTS (SELECT 'X' FROM PS_GP_PKGRPT_TMP T1
            WHERE T1.GP_PKG_ID = P3.GP_PKG_ID
            AND T1.GP_PKG_PIN_NUM = (P3.PIN_NUM + 50000000)
            AND T1.PROCESS_INSTANCE =  #LastInstance)
END-SELECT
end-procedure !Get-Mod-Cnt

!******************************
!begin-procedure Get-New-Cnt
!******************************
begin-procedure Get-New-Cnt

begin-SELECT
COUNT(*) &No_of_New
FROM PS_GP_PKG_ELEMENTS P4
where P4.GP_PKG_ID = &GP_PKG_ID
AND P4.GP_PKG_ELEM_CMP_ST ='S'
AND P4.GP_PKG_UPG_ACTION = 'U'
AND P4.GP_PKG_NEW_PIN_FLG = 'Y'
AND P4.GP_PKG_UPG_OPTN = 'Y'
END-SELECT
end-procedure !Get-New-Cnt

!******************************
!begin-procedure Get-Del-Cnt
!******************************
begin-procedure Get-Del-Cnt

begin-SELECT
COUNT(*) &No_of_Del
FROM PS_GP_PKG_ELEMENTS P5
where P5.GP_PKG_ID = &GP_PKG_ID
AND P5.GP_PKG_ELEM_CMP_ST ='S'
AND P5.GP_PKG_UPG_ACTION = 'D'
AND P5.GP_PKG_NEW_PIN_FLG <> 'Y'
AND P5.GP_PKG_UPG_OPTN = 'Y'
END-SELECT

end-procedure !Get-Del-Cnt

!******************************
!begin-procedure Get-Unchg-Cnt
!******************************
begin-procedure Get-Unchg-Cnt

begin-SELECT
COUNT(*) &No_of_Unchg
FROM PS_GP_PKG_ELEMENTS P6
where P6.GP_PKG_ID = &GP_PKG_ID
AND P6.GP_PKG_ELEM_CMP_ST ='S'
AND P6.GP_PKG_UPG_ACTION = 'U'
AND P6.GP_PKG_NEW_PIN_FLG = 'N'
AND P6.GP_PKG_UPG_OPTN = 'Y'
AND NOT EXISTS (SELECT T2.GP_PKG_PIN_NUM
                FROM PS_GP_PKGRPT_TMP T2
                WHERE T2.PROCESS_INSTANCE = #LastInstance
                AND T2.GP_PKG_ID = P6.GP_PKG_ID
                AND P6.PIN_NUM + 50000000 = T2.GP_PKG_PIN_NUM)
END-SELECT

end-procedure !Get-Unchg-Cnt


!***********************************
!begin-procedure Print-Sections
!***********************************
begin-procedure Print-Sections

  If &PRINT_ERR_WARN_IND = 'Y'
     do Failed-Warning-Status
  End-if

  If &PRINT_MOD_IND = 'Y'
     do Get-Modified
  End-if

  If &PRINT_NEW_IND = 'Y'
     do GPNewElements
  End-if

  If &PRINT_DEL_IND = 'Y'
     do GPDelElements
  End-if

  If &PRINT_UNCHG_IND = 'Y'
     do GPUnchanged
  End-if

end-procedure !Print-Sections

!******************************
!begin-procedure Get-Values
!******************************
begin-procedure Get-Values
   if $prcs_process_instance = ''
      do Ask-Values
   ELSE
      do Select-Parameters
   End-if

   do Format-DateTime($FromDate,$HdgFromDt,{DEFDATE}, '', '')
   do Format-DateTime($ThruDate,$HdgThruDt,{DEFDATE}, '', '')

end-procedure !Get-Values

!*************************
!begin-procedure Ask-Values
!*************************
begin-procedure Ask-Values
  !input $IncludeDetail 'Include Detail?  Y/N' TYPE=char maxlen=1
end-procedure !Ask-Values

!**********************************
!begin-procedure Select-Parameters
!**********************************
begin-procedure Select-Parameters
BEGIN-SELECT
RUNP.GP_PKG_ID
  let $GP_PKG_ID  = rtrim(&RUNP.GP_PKG_ID,' ')
    FROM PS_GP_PKG_RUNCTL RUNP
      WHERE RUNP.OPRID= $prcs_oprid
        AND RUNP.RUN_CNTL_ID=$prcs_run_cntl_id
END-SELECT
end-procedure !Select-Parameters

!***************************
begin-heading 7
!***************************
#include 'stdhdg01.sqc'

!***********************************************************************
! Print column definitions.  Some fields are lined up vertically with  *
!   other fields on the report.  The first occurence of a column       *
!   location is defined.  After that, fields that occur in the same    *
!   column use the first field's column definition.  Field labels end  *
!   in _lbl.  Other column definitions are for the field values.       *
!***********************************************************************

!Line 1
!Transaction Header Line

      POSITION (-1)
      let $Report_Type = $RPT_TYPE_1_lbl || ' '|| $Rpt_type
      print $Report_Type () center BOLD
   if $SummaryPage='N'
      let $Country_Name = $COUNTRY_lbl || ' ' || $Country_Dtl
      print $Country_Name (+1)  center BOLD
      print '=' (+1,1,176) fill
      print $ELEMENT_lbl (+1,{Col_3})
      print $RCD_FLD_lbl (,{Col_5})
      print $SOURCE_DB_2_lbl (,{Col_8})
      print '(' ()
      print &GPDBNAME ()
      print ')' ()
      print $TRGT_DB_2_lbl (,{Col_9})
      print '(' ()
      If #prcs_process_instance = 0
      print $database_name ()
      Else
      print &RQ.DBNAME ()
      End-If
      print ')' ()
      print '=' (+1,1,176) fill
   else
      print '=' (+2,1,176) fill
   End-if


end-heading

!*********************************
!begin-procedure Get-Heading3
!*********************************
begin-procedure Get-Heading3
   if $pagenew='true' and #current-line > 8
      New-page
   End-if
   next-listing no-advance need=3
   print $PIN_CODE_lbl (+1,{Col_3})
   print $pin_code (,{Col_4a})
   let #col_num = #current-line
   print $PIN_TYPE_lbl (+1,{Col_3})
   print $Pin_type  (,{Col_4a})
   let $flag ='true'
   let $pagenew='false'
   evaluate $ComparetypeFlag
     when = 'M'
       POSITION (-3)
       break
     when = 'N'
     when = 'D'
      POSITION (-2)
      break
     when-other
      break
   End-evaluate

end-procedure !Get-Heading3
!
!*********************************
!begin-procedure Get-Heading4
!*********************************
begin-procedure Get-Heading4
   next-listing  need=4
   print $PIN_CODE_lbl (+1,{Col_3})
   print $pin_code (,{Col_4a})
   print $PIN_TYPE_lbl (+1,{Col_3})
   print $pin_type  (,{Col_4a})
   !print $Pin_code (,{Col_5})
   print $UPGRD_ACTION_lbl (+1,{Col_3})
   print $upgaction (,{Col_4a})
   print $UPGRD_lbl (+1,{Col_3})
   print $upgoption (,{Col_4a})
   print $CMPR_STATUS_lbl (+1,{Col_3})
   print $cmprstatus (,{Col_4a})
   let $FailReason1 =   '**' || $FailReason
   print $FailReason1 (+1,{Col_3})
   POSITION (-4)
   let $pagenew='false'

end-procedure !Get-Heading4

!************************************
!begin-procedure Pin-Num-Fail-GP-Pin
!************************************
begin-procedure Pin-Num-Fail-GP-Pin
  Do DebugProc ('S', 'Pin-Num-Fail-GP-Pin')
begin-SELECT
B.PIN_NM
B.PIN_NUM
B.PIN_TYPE
S.DESCR
S.PIN_TYPE
B.PIN_CODE

 let $Pin_code = rtrim(&B.PIN_CODE,' ')
 let $Pin_type = &S.DESCR

 if $Pin_code <> ''
    do Get-Pin-Pckg-Ele
 End-if

  FROM PS_GP_PIN B,  PS_GP_PIN_TYPE S
    WHERE B.PIN_NUM = #SrcPinNumFail
      AND B.PIN_TYPE = S.PIN_TYPE
end-select
  Do DebugProc ('E', 'Pin-Num-Fail-GP-Pin')
end-procedure !Pin-Num-Fail-GP-Pin

!*********************************
!begin-procedure Failed-Warning-Status
!*********************************
begin-procedure Failed-Warning-Status
   if #current-line > 8
     New-page
   End-if

      Let $Rpt_type = $ERRORFAIL_lbl
  Do DebugProc ('S', 'Failed-Warning-Status')
begin-SELECT
A.PIN_NUM
A.PIN_NUM_TGT
A.PIN_CODE
A.PIN_TYPE
A.GP_PKG_ELEM_CMP_ST
A.GP_PKG_UPG_ACTION
A.GP_PKG_FAIL_REASON
A.GP_PKG_UPG_OPTN
T.DESCR
T.PIN_TYPE

   let $pin_code = &A.PIN_CODE
   let $FieldName = 'GP_PKG_ELEM_CMP_ST'
   let $FieldValue = &A.GP_PKG_ELEM_CMP_ST
   do Read-Translate-Table
   let $cmprstatus = $XlatShortName

   let $FieldName = 'GP_PKG_FAIL_REASON'
   let $FieldValue = &A.GP_PKG_FAIL_REASON
   do Read-Translate-Table
   let $FailReason = $XlatLongName

   let $Pin_type = &T.DESCR

   let $FieldName = 'GP_PKG_UPG_ACTION'
   let $FieldValue = &A.GP_PKG_UPG_ACTION
   do Read-Translate-Table
   let $upgaction =  $XlatLongName

   if &A.GP_PKG_UPG_OPTN = 'Y'
      let $upgoption =  $YES_Lbl
   else
      let $upgoption =  $NO_Lbl
   end-if


   let  #SrcPinNumFail = &A.PIN_NUM + 50000000
   let #TgtPinNumFail  = &A.PIN_NUM_TGT
   do Get-Heading4
   do Pin-Num-Fail-GP-Pin

   let $DataFound = 'Y'

   FROM PS_GP_PKG_ELEMENTS A,  PS_GP_PIN_TYPE T
     WHERE A.GP_PKG_ID = &GP_PKG_ID
       AND A.GP_PKG_ELEM_CMP_ST in ('F', 'W')
       AND A.PIN_TYPE = T.PIN_TYPE
       AND A.COUNTRY=$Country
ORDER BY A.GP_PKG_ELEM_CMP_ST, A.GP_PKG_FAIL_REASON, A.PIN_CODE
end-select
  Do DebugProc ('E', 'Failed-Warning-Status')
if $DataFound = 'N' and $Country <> 'ALL'
   print $NO_DATA_Lbl ({Row_1}) BOLD center
else
   let $DataFound = 'N'
End-if
end-procedure !Failed-Warning-Status

!**********************************
!begin-procedure Get-Modified
!**********************************
begin-procedure Get-Modified
   if #current-line > 8
      New-page
   End-if

   let $Rpt_type = $MOD_ELE_lbl
   let $ComparetypeFlag = 'M'

  Do DebugProc ('S', 'Get-Modified')
begin-SELECT DISTINCT
C.PIN_CODE
C.PIN_NUM
C.PIN_NUM_TGT
C.GP_PKG_ELEM_CMP_ST
C.GP_PKG_UPG_ACTION
C.PIN_TYPE
T1.DESCR
T1.PIN_TYPE

 let $pin_code = &C.PIN_CODE
 let $pin_type =  &T1.DESCR

 let #SrcPinNum = &C.PIN_NUM + 50000000                      !Save PIN_NUM + 50 mill into #SrcPinNum variable
 let #PkgPinNum = &C.PIN_NUM                                 !Save PIN_NUM into #PkgPinNum variable
 let #TgtPinNum = &C.PIN_NUM_TGT                             !Save PIN_NUM_TGT into #TgtPinNum variable

 let $PkgElmPinType = &C.PIN_TYPE                            !Save PIN_TYPE into &PkgElmPinType variable

 let #lastseqno = 0
 do ElementBasics                           !Call ElementBasics procedure to get basic details from GP_PIN for the element
 let #lastseqno = 0

 let $DataFound = 'Y'

   From PS_GP_PKG_ELEMENTS C, PS_GP_PIN_TYPE T1
     WHERE C.GP_PKG_ID = &GP_PKG_ID
       AND C.GP_PKG_UPG_ACTION = 'U'
       AND C.GP_PKG_NEW_PIN_FLG <> 'Y'
       AND C.GP_PKG_ELEM_CMP_ST = 'S'
       AND C.PIN_TYPE = T1.PIN_TYPE
       AND C.COUNTRY=$Country
       AND EXISTS (SELECT 'X' FROM PS_GP_PKGRPT_TMP TMP
                      WHERE TMP.GP_PKG_ID = C.GP_PKG_ID
                        AND TMP.GP_PKG_PIN_NUM = (C.PIN_NUM + 50000000)
                        AND TMP.PROCESS_INSTANCE =  #LastInstance)
ORDER BY C.PIN_CODE
END-SELECT
  Do DebugProc ('E', 'Get-Modified')
if $DataFound = 'N' and $Country <> 'ALL'
   print $NO_DATA_Lbl ({Row_1}) BOLD center
else
   let $DataFound = 'N'
End-if
end-procedure !Get-Modified

!****************************
!begin-procedure ElementBasics
!****************************
begin-procedure ElementBasics

  do Get-Heading3

     do GetRecName

   Let #Parent-or-Child-Seqno = 1  ! Print effective-dated parent records first
   do GPElemDefnEffDt

   Let #Parent-or-Child-Seqno = 2  ! Print effective-dated child records after parent
   do GPElemDefnEffDt

   do GPElemDefnNoEffDt  ! Then print records that are NEITHER effective-dated nor begin-end-dated

   do GPElemDefnBgnEndDt ! Finally, print begin-end-dated records

end-procedure !ElementBasics

!****************************
!begin-procedure GetRecName
!****************************
begin-procedure GetRecName
  Do DebugProc ('S', 'GetRecName')
begin-SELECT distinct
A3.RECNAME

  let #lastseqno = 0

  let $NewRecFlag = 'True'

  let $Rec_Name = &A3.RECNAME
     do Print-RecName



         do GPPinMasterRecs
  FROM PS_GP_PKGRPT_TMP A3
    WHERE A3.PROCESS_INSTANCE =  #LastInstance
      AND A3.GP_PKG_ID = &GP_PKG_ID
      AND A3.GP_PKG_PIN_NUM = #SrcPinNum
      AND (A3.RECNAME = 'GP_PIN' or A3.RECNAME = 'GP_PIN_LANG')
ORDER BY A3.RECNAME ! force gp_pin to be processed before gp_pin_lang
END-SELECT
  Do DebugProc ('E', 'GetRecName')
let $Rec_Name =''
let $NewRecFlag = 'False'
end-procedure !GetRecName
!
!
!****************************
!begin-procedure Checkfields
!****************************
begin-procedure Checkfields
   EVALUATE #Fldtype
   WHEN = 0
       let  $src_Field = rtrim($src_char,' ')
       let  $tgt_Field  = rtrim($tgt_char,' ')
       BREAK
   WHEN = 1
       DO DescrLngSrc
       DO DescrLngTgt
       BREAK
   WHEN = 2
       If $RefFlag = 'Y'
          let  $src_Field = rtrim($src_char,' ')
          let  $tgt_Field  = rtrim($tgt_char,' ')
       Else
          If $key_ind = '1' or $key_ind = '3'  ! there was a matching row on the db so print numeric if even if it is 0
             let  $src_Field = rtrim(edit(#src_num,  '88888888888.888888'),'0')
             let  $tgt_Field  = rtrim(edit(#tgt_num, '88888888888.888888'),'0')
          Else
             let  $src_Field = rtrim(edit( #src_num,  'B8888888888.BBBBBB'),'0')
             let  $tgt_Field  = rtrim(edit (#tgt_num, 'B8888888888.BBBBBB'),'0')

          End-if

          let #lngthSrc = length($src_Field)
          let #lngthTgt = length($tgt_Field)

          If substrp($src_Field,#lngthSrc,1) = '.'  ! Remove decimal point if it is the last character in the field
                let $src_Field = substrp($src_Field,1,(#lngthSrc - 1))
          End-If

          If substrp($tgt_Field,#lngthTgt,1) = '.' ! Remove decimal point if it is the last character in the field
             let $tgt_Field = substrp($tgt_Field,1,(#lngthTgt - 1))
          End-If

       End-If
       BREAK
   WHEN = 3
       If $key_ind = '1' or $key_ind = '3' ! there was NOT a matching row on the db so print numeric if even if it is 0
          let  $src_Field = rtrim(edit(#src_snum, '88888888888.888888'),'0')
          let  $tgt_Field = rtrim(edit(#tgt_snum, '88888888888.888888'),'0')
       Else
          let  $src_Field = rtrim(edit(#src_snum, 'B8888888888.BBBBBB'),'0')
          let  $tgt_Field = rtrim(edit(#tgt_snum, 'B8888888888.BBBBBB'),'0')
       End-If

       let #lngthSrc = length($src_Field)
       let #lngthTgt = length($tgt_Field)

       If substrp($src_Field,#lngthSrc,1) = '.'  ! Remove decimal point if it is the last character in the field
          let $src_Field = substrp($src_Field,1,(#lngthSrc - 1))
       End-If

       If substrp($tgt_Field,#lngthTgt,1) = '.' ! Remove decimal point if it is the last character in the field
          let $tgt_Field = substrp($tgt_Field,1,(#lngthTgt - 1))
       End-If

      BREAK
   WHEN = 4
       Let $src_Field = ''
       Let $tgt_Field = ''
       if rtrim($src_date,' ') <> ''
          do Format-DateTime($src_date, $src_Field, {DEFDATE}, '', '')
       End-if
       if rtrim($tgt_date,' ') <> ''
          do Format-DateTime($tgt_date, $tgt_Field, {DEFDATE}, '', '')
       End-if
       BREAK
   WHEN = 5
       let  $src_Field = rtrim($src_time,' ')
       let  $tgt_Field  = rtrim($tgt_time,' ')
       BREAK
   WHEN = 6
       Let $src_Field = ''
       Let $tgt_Field = ''
       if rtrim($src_dttm,' ') <> ''
           let $src_Field = $src_dttm
       End-if
       if rtrim($tgt_dttm,' ') <> ''
           let $tgt_Field = $tgt_dttm
       End-if
       BREAK
   END-EVALUATE
end-procedure !Checkfields

!****************************
!begin-procedure DescrLngSrc
!****************************
begin-procedure DescrLngSrc
  Do DebugProc ('S', 'DescrLngSrc')

begin-SELECT
LCH.DESCRLONG

   Let $src_Field = rtrim(&LCH.DESCRLONG,' ')

     FROM PS_GP_PKGLCH_TMP LCH, PS_GP_PKGRPT_TMP T
       WHERE LCH.PROCESS_INSTANCE = #LastInstance
         AND LCH.GP_PKG_ID = &GP_PKG_ID
         AND LCH.PIN_NUM = #SrcPinNum
         AND LCH.RECNAME = $Rec_Name
         AND LCH.SEQNO = #Seqno
         AND LCH.PROCESS_INSTANCE = T.PROCESS_INSTANCE
         AND LCH.GP_PKG_ID = T.GP_PKG_ID
         AND LCH.PIN_NUM = T.GP_PKG_PIN_NUM
         AND LCH.RECNAME = T.RECNAME
         AND LCH.SEQNO = T.SEQNO
         AND LCH.FIELDNUM = T.FIELDNUM
END-SELECT
  Do DebugProc ('E', 'DescrLngSrc')
end-procedure !DescrLngSrc

!****************************
!begin-procedure DescrLngTgt
!****************************
begin-procedure DescrLngTgt
  Do DebugProc ('S', 'DescrLngTgt')

begin-SELECT
LCH1.DESCRLONG

   Let $tgt_Field = &LCH1.DESCRLONG

     FROM PS_GP_PKGLCH_TMP LCH1, PS_GP_PKGRPT_TMP TM
       WHERE LCH1.PROCESS_INSTANCE = #LastInstance
         AND LCH1.GP_PKG_ID = &GP_PKG_ID
         AND LCH1.PIN_NUM = #TgtPinNum
         AND LCH1.RECNAME = $Rec_Name
         AND LCH1.SEQNO = #Seqno
         AND LCH1.PROCESS_INSTANCE = TM.PROCESS_INSTANCE
         AND LCH1.GP_PKG_ID = TM.GP_PKG_ID
         AND LCH1.RECNAME = TM.RECNAME
         AND LCH1.SEQNO = TM.SEQNO
         AND LCH1.FIELDNUM = TM.FIELDNUM
END-SELECT
  Do DebugProc ('S', 'DescrLngTgt')
end-procedure !DescrLngSrc
!
!****************************
!begin-procedure GPPinMasterRecs
! This procedure processes the record GP_PIN and GP_PIN_LANG only.
!****************************
begin-procedure GPPinMasterRecs
  Do DebugProc ('S', 'GPPinMasterRecs')
begin-SELECT
X.RECNAME
X.GP_PKG_PIN_NUM
X.FIELDNAME
X.PIN_NUM_REF_FLAG
X.KEY_FIELD_IND
X.PKGSRC_NUM_FLD
X.PKGSRC_DATE_FLD
X.PKGSRC_DTTM_FLD
X.PKGSRC_SNUM_FLD
X.PKGSRC_CHAR_FLD
X.PKGSRC_TIME_FLD
X.PKGTGT_NUM_FLD
X.PKGTGT_DATE_FLD
X.PKGTGT_DTTM_FLD
X.PKGTGT_SNUM_FLD
X.PKGTGT_CHAR_FLD
X.PKGTGT_TIME_FLD
Y.SHORTNAME
Z.FIELDTYPE
X.SEQNO
X.FIELDNUM

  If &X.SEQNO <> #lastseqno
    If #lastseqno <> 0
      Let $PrintBlankLineFlag = 'True'
    End-If
    Let #lastseqno = &X.SEQNO
  Else
    Let $PrintBlankLineFlag = 'False'
  End-If

 let #src_num  = &X.PKGSRC_NUM_FLD
 let #tgt_num  = &X.PKGTGT_NUM_FLD

 let #src_snum = &X.PKGSRC_SNUM_FLD
 let #tgt_snum = &X.PKGTGT_SNUM_FLD
 let $src_char = &X.PKGSRC_CHAR_FLD
 let $tgt_char = &X.PKGTGT_CHAR_FLD
 let $src_dttm = &X.PKGSRC_DTTM_FLD
 let $tgt_dttm = &X.PKGTGT_DTTM_FLD
 let $src_date = &X.PKGSRC_DATE_FLD
 let $tgt_date = &X.PKGTGT_DATE_FLD
 let $src_time = &X.PKGSRC_TIME_FLD
 let $tgt_time = &X.PKGTGT_TIME_FLD

 let #Seqno    = &X.SEQNO
 let #FieldNum = &X.FIELDNUM

 let #Fldtype   = &Z.FIELDTYPE
 let $Sname     = &Y.SHORTNAME
 let $RefFlag   = &X.PIN_NUM_REF_FLAG
 let $key_ind   = &X.KEY_FIELD_IND
 let $FieldName = &X.FIELDNAME

!If the field being processed is a Character field, convert any translate fields to their shortname value (use READXLAT.SQC)

 do Checkfields
 If &Z.FIELDTYPE = 0

    Let $FieldValue = &X.PKGSRC_CHAR_FLD
    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       let  $src_Field = rtrim($XlatShortName,' ')
       If $src_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $src_Field =  rtrim(&X.PKGSRC_CHAR_FLD, ' ')   ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
         let $src_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-If

    Let $FieldName = &X.FIELDNAME
    Let $FieldValue = &X.PKGTGT_CHAR_FLD

    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       Let $tgt_Field = rtrim($XlatShortName,' ')
       If $tgt_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $tgt_Field = rtrim(&X.PKGTGT_CHAR_FLD,' ')     ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
          Let $tgt_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-IF
 End-if

 do PrintModified

   FROM PS_GP_PKGRPT_TMP X, PSDBFLDLABL Y, PSDBFIELD Z
     WHERE X.PROCESS_INSTANCE = #LastInstance
       AND X.GP_PKG_ID = &GP_PKG_ID
       AND X.GP_PKG_PIN_NUM = #SrcPinNum
       AND X.RECNAME = $Rec_Name
       AND X.FIELDNAME = Y.FIELDNAME
       AND Y.DEFAULT_LABEL = 1
       AND X.FIELDNAME = Z.FIELDNAME
ORDER BY X.SEQNO, X.FIELDNUM, X.PKGSRC_NUM_FLD ASC, X.PKGTGT_NUM_FLD ASC, X.PKGSRC_SNUM_FLD ASC, X.PKGTGT_SNUM_FLD ASC
END-SELECT
  Do DebugProc ('E', 'GPPinMasterRecs')
end-procedure !GPPinMasterRecs
!
!******************************
!begin-procedure GPElemDefnEffDt
!******************************
begin-procedure GPElemDefnEffDt
  Do DebugProc ('S', 'GPElemDefnEffDt')
  let $PrevRecname = ''
begin-select distinct
C.SEQNO
A1.RECNAME
A1.SEQNO
A1.PKGSRC_DATE_FLD
A1.PKGTGT_DATE_FLD

  let #Seqno = &A1.SEQNO
  let $Rec_Name = &A1.RECNAME

  If $PrevRecname <> &A1.RECNAME
     let $NewRecFlag = 'True'
     do Print-RecName
  Else
     let $NewRecFlag = 'False'
  End-If

  let $PrevRecname = &A1.RECNAME

  let $SrcDt = &A1.PKGSRC_DATE_FLD
  let $TgtDt = &A1.PKGTGT_DATE_FLD

  do GPElemDefnFldsEffDt

  FROM PS_GP_PKGRPT_TMP A1, PS_GP_PIN_FLD_MAP1 B, PS_GP_PKGREC_TMP C
    WHERE A1.PROCESS_INSTANCE = #LastInstance
      AND A1.PROCESS_INSTANCE = C.PROCESS_INSTANCE
      AND A1.FIELDNAME = 'EFFDT'
      AND A1.GP_PKG_PIN_NUM = #SrcPinNum
      AND B.EFFDT_TYPE = 'E'
      AND A1.RECNAME = B.RECNAME
      AND A1.RECNAME = C.RECNAME
      AND C.PIN_TYPE = $PkgElmPinType
      AND C.SEQNO = #Parent-or-Child-Seqno
ORDER BY C.SEQNO, A1.PKGSRC_DATE_FLD DESC, A1.PKGTGT_DATE_FLD DESC, A1.SEQNO
end-select
  Do DebugProc ('E', 'GPElemDefnEffDt')
let $Rec_Name =''
end-procedure ! GPElemDefnEffDt

!**********************************
!begin-procedure GPElemDefnFldsEffDt
!**********************************
begin-procedure GPElemDefnFldsEffDt
  Do DebugProc ('S', 'GPElemDefnFldsEffDt')
begin-select
P.RECNAME
P.GP_PKG_PIN_NUM
P.FIELDNAME
P.PIN_NUM_REF_FLAG
P.KEY_FIELD_IND
P.PKGSRC_NUM_FLD
P.PKGSRC_DATE_FLD
P.PKGSRC_DTTM_FLD
P.PKGSRC_SNUM_FLD
P.PKGSRC_CHAR_FLD
P.PKGSRC_TIME_FLD
P.PKGTGT_NUM_FLD
P.PKGTGT_DATE_FLD
P.PKGTGT_DTTM_FLD
P.PKGTGT_SNUM_FLD
P.PKGTGT_CHAR_FLD
P.PKGTGT_TIME_FLD
Q.SHORTNAME
R.FIELDTYPE
P.SEQNO
P.FIELDNUM

  If &P.SEQNO <> #lastseqno
    If #lastseqno <> 0
      Let $PrintBlankLineFlag = 'True'
    End-If
    Let #lastseqno = &P.SEQNO
  Else
    Let $PrintBlankLineFlag = 'False'
  End-If

  let #src_num  = &P.PKGSRC_NUM_FLD
  let #tgt_num  = &P.PKGTGT_NUM_FLD
  let #src_snum = &P.PKGSRC_SNUM_FLD
  let #tgt_snum = &P.PKGTGT_SNUM_FLD
  let $src_char = &P.PKGSRC_CHAR_FLD
  let $tgt_char = &P.PKGTGT_CHAR_FLD
  let $src_dttm = &P.PKGSRC_DTTM_FLD
  let $tgt_dttm = &P.PKGTGT_DTTM_FLD
  let $src_date = &P.PKGSRC_DATE_FLD
  let $tgt_date = &P.PKGTGT_DATE_FLD
  let $src_time = &P.PKGSRC_TIME_FLD
  let $tgt_time = &P.PKGTGT_TIME_FLD

  If $PkgElmPinType = 'FM' ! Save Effective date values for Formula
     If rtrim(&P.FIELDNAME,' ') = 'EFFDT'
        Let $FMSrcEffDt = $src_date
        Let $FMTgtEffDt = $tgt_date
     End-If
  Else
     Let $FMSrcEffDt = ' '
     Let $FMTgtEffDt = ' '
  End-If

  let #FieldNum = &P.FIELDNUM

  let #Fldtype   = &R.FIELDTYPE
  let $RefFlag   = &P.PIN_NUM_REF_FLAG
  let $Sname     = &Q.SHORTNAME
  let $key_ind   = &P.KEY_FIELD_IND
  let $FieldName = &P.FIELDNAME

!If the field being processed is a Character field, convert any translate fields to their shortname value (use READXLAT.SQC)

 do Checkfields
 If &R.FIELDTYPE = 0

    Let $FieldValue = &P.PKGSRC_CHAR_FLD

    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       let $src_Field = $XlatShortName
       If $src_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $src_Field =  rtrim(&P.PKGSRC_CHAR_FLD, ' ')   ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
          Let $src_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-if

    Let $FieldName = &P.FIELDNAME
    Let $FieldValue = &P.PKGTGT_CHAR_FLD

    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       Let $tgt_Field = $XlatShortName

       If $tgt_Field = ''                                   ! print $FieldValue in the Package Element column on the report
          LET $tgt_Field = rtrim(&P.PKGTGT_CHAR_FLD,' ')    ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
          Let $tgt_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-IF
 End-if

 do PrintModified

   FROM PS_GP_PKGRPT_TMP P, PSDBFLDLABL Q, PSDBFIELD R
     WHERE P.PROCESS_INSTANCE = #LastInstance
       AND P.RECNAME = $Rec_Name
       AND P.GP_PKG_PIN_NUM = #SrcPinNum
       AND P.SEQNO = #Seqno
       AND P.FIELDNAME = Q.FIELDNAME
       AND Q.DEFAULT_LABEL = 1
       AND P.FIELDNAME = R.FIELDNAME
ORDER BY P.SEQNO, P.FIELDNUM, P.PKGSRC_NUM_FLD ASC, P.PKGTGT_NUM_FLD ASC, P.PKGSRC_SNUM_FLD ASC, P.PKGTGT_SNUM_FLD ASC
end-select

 Do DebugProc ('E', 'GPElemDefnFldsEffDt')

 If $PkgElmPinType = 'FM'
 And rtrim($Rec_Name,' ') = 'GP_FORMULA_DTL'
    do formulasource
    do formulatgt

    let $print_formula='N' 
     if substr($src_Field,1,3) ='Msg'
        let $Hold_src_Field =  substr($src_Field,17,53)
        let $print_formula='Y'
        print $Hold_src_Field (+1,{Col_8})
    End-if
    IF substr($tgt_Field,1,3) = 'Msg'
         let $Hold_tgt_Field = substr($tgt_Field,17,53)
         let $print_formula='Y'
        print $Hold_tgt_Field (,{Col_9})
    end-if
    IF $print_formula='N'
       do Print-Formula
    end-if  
 
 End-if
end-procedure ! GPElemDefnFldsEffDt

!************************************
!begin-procedure GPElemDefnBgnEndDt
!************************************
begin-procedure GPElemDefnBgnEndDt
  Do DebugProc ('S', 'GPElemDefnBgnEndDt')
  let $PrevRecname = ''
begin-select DISTINCT
C1.SEQNO
A2.RECNAME
A2.SEQNO
A2.PKGSRC_DATE_FLD
A2.PKGTGT_DATE_FLD

 let #Seqno = &A2.SEQNO
 let $Rec_Name = &A2.RECNAME

 If $PrevRecname <> &A2.RECNAME
    let $NewRecFlag = 'True'
    do Print-RecName
 Else
    let $NewRecFlag = 'False'
 End-if

 let $PrevRecname = &A2.RECNAME

 do GPElemDefnFldsBgnEndDt

   FROM PS_GP_PKGRPT_TMP A2, PS_GP_PIN_FLD_MAP1 B, PS_GP_PKGREC_TMP C1
   WHERE A2.PROCESS_INSTANCE = #LastInstance
     AND A2.PROCESS_INSTANCE = C1.PROCESS_INSTANCE
     AND A2.FIELDNAME = 'BGN_DT'
     AND A2.GP_PKG_PIN_NUM = #SrcPinNum
     AND B.EFFDT_TYPE = 'S'
     AND A2.RECNAME = B.RECNAME
     AND A2.RECNAME = C1.RECNAME
     AND C1.PIN_TYPE = $PkgElmPinType
ORDER BY A2.RECNAME, A2.PKGSRC_DATE_FLD DESC, A2.PKGTGT_DATE_FLD DESC, A2.SEQNO
end-select
  Do DebugProc ('E', 'GPElemDefnBgnEndDt')
  let $Rec_Name =''

end-procedure ! GPElemDefnBgnEndDt

!***************************************
!begin-procedure GPElemDefnFldsBgnEndDt
!***************************************
begin-procedure GPElemDefnFldsBgnEndDt
  Do DebugProc ('S', 'GPElemDefnFldsBgnEndDt')
begin-select
D.RECNAME
D.GP_PKG_PIN_NUM
D.FIELDNAME
D.PIN_NUM_REF_FLAG
D.KEY_FIELD_IND
D.PKGSRC_NUM_FLD
D.PKGSRC_DATE_FLD
D.PKGSRC_DTTM_FLD
D.PKGSRC_SNUM_FLD
D.PKGSRC_CHAR_FLD
D.PKGSRC_TIME_FLD
D.PKGTGT_NUM_FLD
D.PKGTGT_DATE_FLD
D.PKGTGT_DTTM_FLD
D.PKGTGT_SNUM_FLD
D.PKGTGT_CHAR_FLD
D.PKGTGT_TIME_FLD
E.SHORTNAME
F.FIELDTYPE
D.SEQNO
D.FIELDNUM

  If &D.SEQNO <> #lastseqno
    If #lastseqno <> 0
      Let $PrintBlankLineFlag = 'True'
    End-If
    Let #lastseqno = &D.SEQNO
  Else
    Let $PrintBlankLineFlag = 'False'
  End-If

  let #src_num  = &D.PKGSRC_NUM_FLD
  let #tgt_num  = &D.PKGTGT_NUM_FLD
  let #src_snum = &D.PKGSRC_SNUM_FLD
  let #tgt_snum = &D.PKGTGT_SNUM_FLD
  let $src_char = &D.PKGSRC_CHAR_FLD
  let $tgt_char = &D.PKGTGT_CHAR_FLD
  let $src_dttm = &D.PKGSRC_DTTM_FLD
  let $tgt_dttm = &D.PKGTGT_DTTM_FLD
  let $src_date = &D.PKGSRC_DATE_FLD
  let $tgt_date = &D.PKGTGT_DATE_FLD
  let $src_time = &D.PKGSRC_TIME_FLD
  let $tgt_time = &D.PKGTGT_TIME_FLD

  let #FieldNum = &D.FIELDNUM

  let #Fldtype   = &F.FIELDTYPE
  let $RefFlag   = &D.PIN_NUM_REF_FLAG
  let $Sname     = &E.SHORTNAME
  let $key_ind   = &D.KEY_FIELD_IND
  let $FieldName = &D.FIELDNAME

!If the field being processed is a Character field, convert any translate fields to their shortname value (use READXLAT.SQC)

 do Checkfields
 If &F.FIELDTYPE = 0

    Let $FieldValue = &D.PKGSRC_CHAR_FLD
    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       let $src_Field = $XlatShortName
       If $src_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $src_Field =  rtrim(&D.PKGSRC_CHAR_FLD, ' ')   ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
          Let $src_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-if

    Let $FieldName = &D.FIELDNAME
    Let $FieldValue = &D.PKGTGT_CHAR_FLD

    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    if #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       Let $tgt_Field = rtrim($XlatShortName,' ')
       If $tgt_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $tgt_Field = rtrim(&D.PKGTGT_CHAR_FLD,' ')     ! Print the actual field value in the Package Element column on the report
       Else
! If The value is an xlat values, show both short and long names.
          Let $tgt_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-IF

 End-if

 do PrintModified

FROM PS_GP_PKGRPT_TMP D, PSDBFLDLABL E, PSDBFIELD F
 WHERE D.PROCESS_INSTANCE = #LastInstance
AND D.RECNAME = $Rec_Name
AND D.GP_PKG_PIN_NUM = #SrcPinNum
AND D.SEQNO = #Seqno
AND D.FIELDNAME = E.FIELDNAME
AND E.DEFAULT_LABEL = 1
AND D.FIELDNAME = F.FIELDNAME
ORDER BY D.SEQNO, D.FIELDNUM, D.PKGSRC_NUM_FLD ASC, D.PKGTGT_NUM_FLD ASC, D.PKGSRC_SNUM_FLD ASC, D.PKGTGT_SNUM_FLD ASC
END-SELECT
  Do DebugProc ('E', 'GPElemDefnFldsBgnEndDt')
end-procedure ! GPElemDefnFldsBgnEndDt

!**********************************
!begin-procedure GPElemDefnNoEffDt
!**********************************
begin-procedure GPElemDefnNoEffDt
  Do DebugProc ('S', 'GPElemDefnNoEffDt')
  let $PrevRecname = ''
  let #lastseqno = 0
begin-SELECT DISTINCT
A4.RECNAME
A4.SEQNO

 let $Rec_Name = &A4.RECNAME
 let #Seqno = &A4.SEQNO

 If $PrevRecname <> &A4.RECNAME
   let $NewRecFlag = 'True'
   do Print-RecName
 Else
   let $NewRecFlag = 'False'
 End-If

 let $PrevRecname = &A4.RECNAME

 do GPElemDefnFldsNoEffDt

 FROM PS_GP_PKGRPT_TMP A4, PS_GP_PIN_FLD_MAP1 B
   WHERE A4.PROCESS_INSTANCE = #LastInstance
     AND A4.GP_PKG_PIN_NUM = #SrcPinNum
     AND B.EFFDT_TYPE = 'N'
     AND A4.RECNAME = B.RECNAME
     AND A4.RECNAME <> 'GP_PIN'
ORDER BY A4.RECNAME, A4.SEQNO ASC
end-select
  Do DebugProc ('E', 'GPElemDefnNoEffDt')
let $Rec_Name =''

end-procedure ! GPElemDefnNoEffDt

!**************************************
!begin-procedure GPElemDefnFldsNoEffDt
!**************************************
begin-procedure GPElemDefnFldsNoEffDt
  Do DebugProc ('S', 'GPElemDefnFldsNoEffDt')

begin-select
U.RECNAME
U.GP_PKG_PIN_NUM
U.FIELDNAME
U.PIN_NUM_REF_FLAG
U.KEY_FIELD_IND
U.PKGSRC_NUM_FLD
U.PKGSRC_DATE_FLD
U.PKGSRC_DTTM_FLD
U.PKGSRC_SNUM_FLD
U.PKGSRC_CHAR_FLD
U.PKGSRC_TIME_FLD
U.PKGTGT_NUM_FLD
U.PKGTGT_DATE_FLD
U.PKGTGT_DTTM_FLD
U.PKGTGT_SNUM_FLD
U.PKGTGT_CHAR_FLD
U.PKGTGT_TIME_FLD
V.SHORTNAME
W.FIELDTYPE
U.SEQNO
U.FIELDNUM

  If &U.SEQNO <> #lastseqno
    If #lastseqno <> 0
      Let $PrintBlankLineFlag = 'True'
    End-If
  Else
    Let $PrintBlankLineFlag = 'False'
  End-If

  Let #lastseqno = &U.SEQNO

  let #src_num  = &U.PKGSRC_NUM_FLD
  let #tgt_num  = &U.PKGTGT_NUM_FLD
  let #src_snum = &U.PKGSRC_SNUM_FLD
  let #tgt_snum = &U.PKGTGT_SNUM_FLD
  let $src_char = &U.PKGSRC_CHAR_FLD
  let $tgt_char = &U.PKGTGT_CHAR_FLD
  let $src_dttm = &U.PKGSRC_DTTM_FLD
  let $tgt_dttm = &U.PKGTGT_DTTM_FLD
  let $src_date = &U.PKGSRC_DATE_FLD
  let $tgt_date = &U.PKGTGT_DATE_FLD
  let $src_time = &U.PKGSRC_TIME_FLD
  let $tgt_time = &U.PKGTGT_TIME_FLD

  let #Seqno     = &U.SEQNO
  let #Fldtype   = &W.FIELDTYPE
  let $RefFlag   = &U.PIN_NUM_REF_FLAG
  let $Sname     = &V.SHORTNAME
  let $key_ind   = &U.KEY_FIELD_IND
  let $FieldName = &U.FIELDNAME

! If the field being processed is a Character field, convert any translate fields to their shortname value (use READXLAT.SQC)

  do Checkfields
  If &W.FIELDTYPE = 0

    Let $FieldValue = &U.PKGSRC_CHAR_FLD

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    If #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       let $src_Field = $XlatShortName
       If $src_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $src_Field =  rtrim(&U.PKGSRC_CHAR_FLD, ' ')   ! Print the actual field value in the Package Element column on the report
       Else
          ! If The value is an xlat values, show both short and long names.
          Let $src_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-if

    Let $FieldName = &U.FIELDNAME
    Let $FieldValue = &U.PKGTGT_CHAR_FLD

    ! DB2 will abort with error if the value size is larger than the column itself. We therefore need to check if the
    ! maximum length is 4 digits or less

    Let $lenCmpTest = rtrim($FieldValue,' ')
    Let #valLen = length($lenCmpTest)

    If #valLen <= 4
       Let $AsOfDate = $AsOfToday
       Do Read-Translate-Table
       Let $tgt_Field = rtrim($XlatShortName,' ')
       If $tgt_Field = ''                                    ! print $FieldValue in the Package Element column on the report
          LET $tgt_Field = rtrim(&U.PKGTGT_CHAR_FLD,' ')     ! Print the actual field value in the Package Element column on the report
       Else
          ! If The value is an xlat values, show both short and long names.
          Let $tgt_Field = '(' || rtrim($FieldValue,' ') || ') ' || rtrim($XlatLongName,' ')
       End-If
    End-If

  End-if

  do PrintModified

 FROM PS_GP_PKGRPT_TMP U, PSDBFLDLABL V, PSDBFIELD W
  WHERE U.PROCESS_INSTANCE = #LastInstance
    AND U.GP_PKG_ID = &GP_PKG_ID
    AND U.GP_PKG_PIN_NUM = #SrcPinNum
    AND U.RECNAME = $Rec_Name
    AND U.SEQNO = #Seqno
    AND U.FIELDNAME = V.FIELDNAME
    AND V.DEFAULT_LABEL = 1
    AND U.FIELDNAME = W.FIELDNAME
ORDER BY U.SEQNO, U.FIELDNUM
end-select
  Do DebugProc ('E', 'GPElemDefnFldsNoEffDt')
end-procedure ! GPElemDefnFldsNoEffDt

!*****************************
!begin-procedure GPNewElements
!*****************************
begin-procedure GPNewElements
   if #current-line > 8
      New-page
   End-if
 let $Rpt_type = $NEWELE_lbl
 let $CompareTypeFlag = 'N'

  Do DebugProc ('S', 'GPNewElements')
begin-select
ELE.PIN_NUM
ELE.PIN_NUM_TGT
ELE.PIN_TYPE
ELE.PIN_CODE
PIN.PIN_NM
PIN.DESCR
PIN.COMMENTS
T2.DESCR

 let $pin_code = &ELE.PIN_CODE
 let $pin_type =  &T2.DESCR
 let #SrcPinNum = &ELE.PIN_NUM + 50000000
 let #TgtPinNum = &ELE.PIN_NUM_TGT

 let $PkgElmPinType  = &ELE.PIN_TYPE

 do Get-Heading3
 do PrintNew

 let $DataFound = 'Y'

 From PS_GP_PKG_ELEMENTS ELE , PS_GP_PIN_TYPE T2, PS_GP_PIN PIN
    WHERE ELE.GP_PKG_ID = &GP_PKG_ID
    AND ELE.GP_PKG_UPG_ACTION = 'U'
    AND ELE.GP_PKG_NEW_PIN_FLG = 'Y'
    AND ELE.GP_PKG_ELEM_CMP_ST = 'S'
    AND ELE.PIN_TYPE = T2.PIN_TYPE
    AND ELE.GP_PKG_UPG_OPTN = 'Y'
    AND ELE.COUNTRY=$Country
    AND ELE.PIN_NUM + 50000000 = PIN.PIN_NUM
ORDER BY ELE.PIN_CODE
end-select
  Do DebugProc ('E', 'GPNewElements')
if $DataFound = 'N' and $Country <> 'ALL'
   print $NO_DATA_Lbl ({Row_1}) BOLD center
else
   let $DataFound = 'N'
End-if

end-procedure ! GPNewElements

!*****************************
!begin-procedure GPDelElements
!*****************************
begin-procedure GPDelElements
   if #current-line > 8
      New-page
   End-if
    let $Rpt_type =  $DELELE_lbl
    let $CompareTypeFlag = 'D'

  Do DebugProc ('S', 'GPDelElements')
begin-select
ELE1.PIN_NUM
ELE1.PIN_NUM_TGT
ELE1.PIN_TYPE
ELE1.PIN_CODE
PIN1.PIN_NM
PIN1.DESCR
PIN1.COMMENTS
T3.DESCR

    let $pin_code = &ELE1.PIN_CODE
    let $pin_type =  &T3.DESCR
    let #SrcPinNum = &ELE1.PIN_NUM + 50000000
    let #TgtPinNum = &ELE1.PIN_NUM_TGT

    let $PkgElmPinType  = &ELE1.PIN_TYPE

    do Get-Heading3
    do PrintDel

    let $DataFound='Y'

    From PS_GP_PKG_ELEMENTS ELE1, PS_GP_PIN_TYPE T3, PS_GP_PIN PIN1
       WHERE ELE1.GP_PKG_ID = &GP_PKG_ID
       AND ELE1.GP_PKG_UPG_ACTION = 'D'
       AND ELE1.GP_PKG_NEW_PIN_FLG <> 'Y'
       AND ELE1.GP_PKG_ELEM_CMP_ST = 'S'
       AND ELE1.PIN_TYPE = T3.PIN_TYPE
       AND ELE1.GP_PKG_UPG_OPTN = 'Y'
       AND ELE1.COUNTRY=$Country
       AND ELE1.PIN_NUM_TGT = PIN1.PIN_NUM
ORDER BY ELE1.PIN_CODE
end-select
  Do DebugProc ('E', 'GPDelElements')
if $DataFound = 'N' and $Country <> 'ALL'
   print $NO_DATA_Lbl ({Row_1}) BOLD center
else
   let $DataFound = 'N'
End-if

end-procedure ! GPDelElements

!*****************************
!begin-procedure GPUnchanged
!*****************************
begin-procedure GPUnchanged
   if #current-line > 8
      New-page
   End-if
  let $Rpt_type = $UNCHANGEDELE_lbl
  let $CompareTypeFlag = 'U'
  Do DebugProc ('S', 'GPUnchanged')
begin-select
ELE2.PIN_NUM
ELE2.PIN_CODE
ELE2.PIN_TYPE
T4.DESCR


    let $pin_code = &ELE2.PIN_CODE
    let $pin_type =  &T4.DESCR
    let $PkgElmPinType  = &ELE2.PIN_TYPE

    do Get-Heading3

    let $DataFound = 'Y'

   FROM PS_GP_PKG_ELEMENTS ELE2, PS_GP_PIN_TYPE T4
      WHERE ELE2.GP_PKG_ID = &GP_PKG_ID
      AND ELE2.GP_PKG_ELEM_CMP_ST = 'S'
      AND ELE2.PIN_TYPE = T4.PIN_TYPE
      AND ELE2.GP_PKG_UPG_ACTION = 'U'
      AND ELE2.GP_PKG_NEW_PIN_FLG = 'N'
      AND ELE2.GP_PKG_UPG_OPTN = 'Y'
      AND ELE2.COUNTRY=$Country
      AND NOT EXISTS (SELECT TMP5.GP_PKG_PIN_NUM
                        FROM PS_GP_PKGRPT_TMP TMP5
                          WHERE TMP5.PROCESS_INSTANCE = #LastInstance
                            AND TMP5.GP_PKG_ID = ELE2.GP_PKG_ID
                            AND ELE2.PIN_NUM + 50000000 = TMP5.GP_PKG_PIN_NUM)
ORDER BY ELE2.PIN_CODE
end-select
  Do DebugProc ('E', 'GPUnchanged')
if $DataFound = 'N' and $Country <> 'ALL'
   print $NO_DATA_Lbl ({Row_1}) BOLD center
else
   let $DataFound = 'N'
End-if

end-procedure ! GPUnchanged

!****************************
!begin-procedure formulasource
!****************************
begin-procedure formulasource
begin-SELECT
FML1.FRML_STR
TMP1.PKGSRC_DATE_FLD
  Let $src_Field = &FML1.FRML_STR
    FROM PS_GP_PKGFML_TMP FML1 , PS_GP_PKGRPT_TMP TMP1
    WHERE FML1.PROCESS_INSTANCE = #LastInstance
    and FML1.PROCESS_INSTANCE = TMP1.PROCESS_INSTANCE
    AND FML1.GP_PKG_ID = TMP1.GP_PKG_ID
    AND FML1.PIN_NUM = #SrcPinNum
    AND FML1.PIN_NUM = TMP1.GP_PKG_PIN_NUM
    AND FML1.EFFDT = TMP1.PKGSRC_DATE_FLD
    AND FML1.EFFDT = $FMSrcEffDt
END-SELECT

   let #size_src = length($src_Field)

end-procedure !formulasource

!****************************
!begin-procedure formulatgt
!****************************
begin-procedure formulatgt

begin-SELECT
FML2.FRML_STR
TMP2.PKGTGT_DATE_FLD
  let $tgt_Field = &FML2.FRML_STR
 FROM PS_GP_PKGFML_TMP FML2 , PS_GP_PKGRPT_TMP TMP2, PS_GP_PKG_ELEMENTS PKG2
    WHERE FML2.PROCESS_INSTANCE = #LastInstance
    and FML2.PROCESS_INSTANCE = TMP2.PROCESS_INSTANCE 
      AND FML2.GP_PKG_ID = TMP2.GP_PKG_ID
      AND FML2.GP_PKG_ID = PKG2.GP_PKG_ID
      AND PKG2.PIN_NUM = #PkgPinNum
      AND TMP2.GP_PKG_PIN_NUM = #SrcPinNum
      AND FML2.PIN_NUM = #TgtPinNum
      AND FML2.PIN_NUM = PKG2.PIN_NUM_TGT
      AND FML2.EFFDT = TMP2.PKGTGT_DATE_FLD
      AND FML2.EFFDT = $FMTgtEffDt
END-SELECT
    let #size_tgt = length($tgt_Field)
end-procedure ! formulatgt

!*********************************
!begin-procedure Print-RecName
!*********************************
begin-procedure Print-RecName
   let $Rec_Name_to_Print = rtrim($Rec_Name,' ')
   If $flag ='true'
      let $flag ='false'
      POSITION (+2)
      print $Rec_Name_to_Print (,{Col_5})
   else
      POSITION (+2)
      print $Rec_Name_to_Print (,{Col_5})
   End-if
end-procedure !Print-RecName

!****************************
!begin-procedure Get-Pin-Pckg-Ele
!****************************
begin-procedure Get-Pin-Pckg-Ele
   print $GPPIN_lbl  ( ,{Col_5})
   print $PINNUM_lbl  (+1,{Col_5a}) BOLD
   print $Pin_code (,{Col_8})  BOLD
end-procedure !Get-Pin-Pckg-Ele

!****************************
!begin-procedure
!****************************
begin-procedure PrintModified
   let $Sname = rtrim($Sname,' ')
!   if $Sname = 'PIN Number'
   if rtrim($FieldName ,' ') = 'PIN_NUM'
      let $Sname = $PINNUM_lbl
   End-if

   if $key_ind = '1'
   or $key_ind = '2'
      If $PrintBlankLineFlag = 'True' and $NewRecFlag = 'False'
        print ' ' (+1,{Col_5a})
      End-If
      print $Sname (+1,{Col_5a}) BOLD
      print $src_Field (,{Col_8}) BOLD
      print $tgt_Field (,{Col_9}) BOLD
   else
      let $NewRecFlag = 'False'
      print $Sname (+1,{Col_5a})
      let #size_src = length($src_Field)
      let #size_tgt = length($tgt_Field)

      If #Fldtype = 1
      And (#size_src > 40 or #size_tgt > 40) ! Use formula text formatting logic to print long char fields
         Do Print-Formula
      Else
        print $src_Field (,{Col_8}) Wrap 47 4 strip=<10> on=<13>
        print $tgt_Field (,{Col_9}) Wrap 47 4 strip=<10> on=<13>
      End-If

   End-if

   let $pagenew = 'false'
   let $src_Field = ' '
   let $tgt_Field = ' '
end-procedure !PrintModified

!****************************
!begin-procedure PrintNew
!****************************
begin-procedure PrintNew
   If $flag ='true'
      let $flag ='false'
      POSITION (+1)
   End-if

   if #current-line > 65
      New-page
   End-if

   print $GPPIN_lbl  ( ,{Col_5})
   print $PINNUM_lbl  (+1,{Col_5a}) BOLD
   print $pin_code (,{Col_8}) BOLD

   print $NAME_lbl (+1,{Col_5a})
   print &PIN.PIN_NM (,{Col_8})
   print $DESCR_lbl (+1,{Col_5a})
   print &PIN.DESCR (,{Col_8})
   print $COMMENTS_lbl (+1,{Col_5a})

   let #Fldtype = 1
   let $src_Field = &PIN.COMMENTS
   let $tgt_Field = ' '
   let #size_src = length($src_Field)
   let #size_tgt = 0

   If #size_src > 40  ! Use formula text formatting logic to print long char fields
     Do Print-Formula
   Else
      print &PIN.COMMENTS (,{Col_8}) Wrap 47 5 strip=<10> on=<13>
   End-If

   let $pagenew = 'false'

end-procedure ! PrintNew

!****************************
!begin-procedure PrintDel
!****************************
begin-procedure PrintDel

   if #current-line > 65
      New-page
   End-if

   If $flag ='true'
      let $flag ='false'
      POSITION (+1)
   End-if

   print $GPPIN_lbl  (0,{Col_5})
   print $PINNUM_lbl  (+1,{Col_5a}) BOLD
   print $pin_code (,{Col_9}) BOLD
   print $NAME_lbl (+1,{Col_5a})
   print &PIN1.PIN_NM (,{Col_9})
   print $DESCR_lbl (+1,{Col_5a})
   print &PIN1.DESCR (,{Col_9})
   print $COMMENTS_lbl (+1,{Col_5a})

   let #Fldtype = 1
   let $src_Field = ' '
   let $tgt_Field = &PIN1.COMMENTS
   let #size_src = 0
   let #size_tgt = length($tgt_Field)

   If #size_tgt > 40  ! Use formula text formatting logic to print long char fields
    Do Print-Formula
   Else
      print &PIN1.COMMENTS (,{Col_9}) Wrap 47 5 strip=<10> on=<13>
   End-If

   let $pagenew = 'false'

end-procedure ! PrintDel
!
!****************************
!begin-procedure Print-Formula
!****************************
begin-procedure Print-Formula

   If #Fldtype <> 1
      print $FORMTEXT_lbl (+1,{Col_5a})
    End-If

   IF length($src_Field) > 5
      Do ReformatString($src_Field,#srctotalLines,#Fldtype)
   End-if

   IF length($tgt_Field) > 5
      Do ReformatString($tgt_Field,#tgttotalLines,#Fldtype)
   End-if

   If #size_src > #size_tgt
      let #string_size = #size_src
   Else
      let #string_size = #size_tgt
   End-If

   Let $srcFormula = $src_Field || $chr13
   Let $tgtFormula = $tgt_Field || $chr13

! Commenting out the matchmaking process until issues with sequence numbering
! of formulae (product issues not Compare Report issues) are resolved

!   If $ComparetypeFlag = 'M'
!      Do matchMaking
!   End-if

   Do PrintFormula

end-procedure !Print-Formula

!****************************
!begin-procedure Get-LastProcessInstanceID
!****************************
begin-procedure Get-LastProcessInstanceID
IF #prcs_process_instance <> 0 
BEGIN-SELECT
MAX(PRCSINSTANCE) &lastInstance

    Let #LastInstance = &lastInstance

   FROM PSPRCSRQST
   WHERE PRCSTYPE = 'Application Engine'
     AND PRCSNAME = 'GP_PKGCMPRPT'
     AND OPRID    = $prcs_oprid
     AND RUNCNTLID = $GP_PKG_ID
End-SELECT
Else
    do Get-Instance-CA  !to get the instance number when called from Change Assistant
end-if
End-procedure Get-LastProcessInstanceID
!*********************************
!begin-procedure Get-Instance-CA
!*********************************
begin-procedure Get-Instance-CA
Begin-SELECT
MAX(TMP1.PROCESS_INSTANCE)  &TMP1.PROCESS_INSTANCE
    
    Let #LastInstance = &TMP1.PROCESS_INSTANCE
    
From PS_GP_PKGRPT_TMP TMP1
where TMP1.GP_PKG_ID = $GP_PKG_ID
End-SELECT
end-procedure
!*********************************
!begin-procedure Get-Country-Descr
!*********************************
begin-procedure Get-Country-Descr
begin-SELECT
CTRY.DESCR

   let $Country_Descr = rtrim(&CTRY.DESCR,' ')

FROM PS_COUNTRY_TBL CTRY
WHERE CTRY.COUNTRY = $Country
end-SELECT

if $Curr_Language_Cd <> $PSOptions_Language_Cd
begin-SELECT
CTRYLNG.DESCR

  if rtrim(&CTRYLNG.DESCR,' ') <> ''
     let $Country_Descr = rtrim(&CTRYLNG.DESCR,' ')
  End-if

FROM PS_COUNTRYTBL_LANG CTRYLNG
WHERE CTRYLNG.COUNTRY=$Country
AND LANGUAGE_CD =  $Curr_Language_Cd
end-SELECT
End-if

end-procedure !Get-Country-Descr
!
!
!****************************************
! Local Function to realign the formula *
!****************************************
! This Local procedure reformats a formula String. It receives a string value which is processed and reformatted
! All Nested values of a IF condition is set at 1 level indent (3 spaces). The reason being we cannot do nesting due to
! limited space of 47 characters.
! all IF (regardless of whether nested or NOT) will start at position column 1.
!
! Parameters : $strFormula - This by reference variable will contain the restructured formula
!            : #totalLines - This by reference variable will contain the total lines found in the formula.
begin-Procedure ReformatString(:$strFormula,:#totalLines,:#Fldtype)

   Let #startPointer = 1
   Let #cmdIFCounter = 0

   Let #totalLines = 1

   Let $chr13 = chr(13)
   Let $chr10 = chr(10)

   Let $formattedString = ''

   Let $strOfFormula = $strFormula

   If #Fldtype = 1  ! remove any CRLFs or tabs from LONGCHAR fields and just process the entire string.
      let $strOfFormula = replace($strOfFormula, $chr13 , '')
      let $strOfFormula = replace($strOfFormula, $chr10 , ' ')
   End-If

   Let #Loop = 1

  Do DebugProc ('S', 'ReformatString')
   While #Loop = 1

     Let $strOfFormula = ltrim(rtrim($strOfFormula,' '),' ')

     Do Get-Line($strOfFormula,#startPointer,#searchPos)  ! Retrieve a Line.

     if #searchPos > 1 ! assume that a char(13) can never be on the 1st position

        Let $command = ''
        Let #totalLines = #totalLines + 1

        If #Fldtype <> 1
          Let #searchPos = #searchPos - 1  ! move pointer backward 1 position to ignore (13)
        End-If

        Let $StrPartOfFmla = substrp($strOfFormula,#startPointer,#searchPos ) ! extract the string

        If $_finalReformat = 'N'
           Let #searchPos = #searchPos + 3  ! move pointer forward 2 position to include char(10)
        else
           Let #searchPos = #searchPos + 2  ! move pointer forward 2 position to include char(10)
        End-if

        Let $strPartOfFmla = ltrim($strPartOfFmla,' ') ! remove leading spaces
        Let $strPartOfFmla = rtrim($strPartOfFmla,' ') ! remove trailing spaces

        If substrp($strPartOfFmla,1,3) = 'IF ' ! check whether a IF was encountered
           Let $command = 'IF'
           Let #cmdIFCounter = #cmdIFCounter + 1
        End-if

        If substrp($strPartOfFmla,1,5) = 'ENDIF' ! check whether a IF was encountered
           Let #cmdIFCounter = #cmdIFCounter - 1
           Let $command = 'ENDIF'
        End-if

        Let #tempCounter = 0

        If substrp($strPartOfFmla,1,4) = 'ELSE' ! check whether a IF was encountered
           Let $command = 'ELSE'
        End-if

        Let $calcNestedSpaces = ''

        if $command <> 'IF' and $command <> 'ELSE' and $command <> 'ENDIF'
           IF #cmdIFCounter > 0
              Let $calcNestedSpaces = lpad($calcNestedSpaces,3 ,' ') ! forcing 3 spaces always.
           else
               Let $calcNestedSpaces = ''
           End-if
        else
           if #cmdIFCounter > 1
              let #tCount = (#cmdIFCounter - 1)
              Let #tempCounter = #tCount * 3
           End-if
        End-if

        Let $formattedString = $formattedString || $calcNestedSpaces || $StrPartofFmla ||  $chr13

        Let #totalLen = length($strOfFormula)

        Let $strOfFormula = substrp($strOfFormula,#searchPos,#totalLen)

     end-if

     if #searchPos = 1 ! The char13 is at 1st position, which means its a blank line
     or (#Fldtype = 1 and #searchPos < 1)  ! for longchar fields without a CRLF put a char13 (CRLF) at the end of the string

        Let $calcNestedSpaces = ''
        IF #cmdIFCounter > 0
           Let $calcNestedSpaces = lpad($calcNestedSpaces,3 ,' ') ! forcing 3 spaces always.
        else
           Let $calcNestedSpaces = ''
        End-if

        If #Fldtype = 1 ! add a CRLF to the end of the string if it's a long char field
           Let $formattedString = ltrim(rtrim($strOfFormula,' '),' ') || $chr13
        Else
           Let $formattedString = $formattedString || $calcNestedSpaces ||  $chr13
        End-if
        Let #totalLines = #totalLines + 1

        Let #totalLen = length($strOfFormula)

        let #searchPos = #searchPos + 1

        Let $strOfFormula = substrp($strOfFormula,#searchPos,#totalLen)

     End-if

     if #searchPos <= 0 ! if no char13 are found, stop the loop
     or #Fldtype = 1    ! or if it's a longchar field, stop the loop
        Let #Loop = 0
     End-if

   End-While

   Let $strFormula = $formattedString
   Do DebugProc ('E', 'ReformatString')
End-Procedure ! function to reformat code
!
!**********************
! Retrieve a Line     *
!**********************
! This local function / procedure will look for char 13 which is a line terminator. The position where found is returned
! to the calling routine.
! Parameters : $strToRead = This string containing formula is parsed to find the char 13 (end of line) identifier
!            : #startPos  = The position from which the EOL identifier must be found
!            : #PositionFound - This by reference variable returns the position where the EOL was found.
!
Begin-Procedure Get-Line($strToRead,#startPos,:#PositionFound)

   Let #PositionFound = instr($strToRead,chr(13),#startPos)

End-Procedure
!
!****************************************
! Local Function to print the formula *
!****************************************
! This loop performs the printing. It takes the reformatted formula and processes each line for printing
! The processing logic is as follows
! Each line is retrieved from the source and target.
! The lines retrieved are checked if they are too long to be printed in a single line (max column being 47)
! if the lines are longer, they will be broken down to smaller sized lines and printed
! It is possible that the total lines of source may not be same as total lines of target, in which case, the provision
! is made to dump out the remaining lines of the formula.
!
begin-Procedure PrintFormula

   Do DebugProc ('S', 'PrintFormula')
   Let #startPointer = 1

   Let #srccmdIFCounter = 0
   Let #tgtcmdIFCounter = 0

   Let $chr13 = chr(13)
   Let $chr10 = chr(10)

   Let #srcGraphicPos = 1
   Let #tgtGraphicPos = 1

   Let #Loop = 1
   Let #tgtLoop = 1
   Let #LoopLineCounter = 1

    While #Loop <= #string_size

     Let $srcFormula = ltrim(rtrim($srcFormula,' ')' ')
     Let $tgtFormula = ltrim(rtrim($tgtFormula,' ')' ')

     Do Extract-Print-Line ($srcFormula,#srcSearchPos,$srcLine2Print,#srccmdIFCounter)

!     if #Loop <= #srcSearchPos  ! if no char13 are found, stop the loop
!        Let #Loop = #Loop + #srcSearchPos
!     End-if

     Do Extract-Print-Line ($tgtFormula,#tgtSearchPos,$tgtLine2Print,#tgtcmdIFCounter)

     If #size_src > #size_tgt
      if #Loop <= #srcSearchPos  ! if no char13 are found, stop the loop
         Let #Loop = #Loop + #srcSearchPos
      End-if
     Else
      if #Loop <= #tgtSearchPos  ! if no char13 are found, stop the loop
         Let #Loop = #Loop + #tgtSearchPos
      End-if
     End-If

     Let #srcLenofString = length($srcLine2Print)
     Let #tgtLenofString = length($tgtLine2Print)

     Let #srcLineBroken = 0
     Let #tgtLineBroken = 0
     Let #LineBroken    = 0

     if #srcLenofString > {MaxFMLCol}
        Let #srcLineBroken = 1
        Let #LineBroken = 1
        Do Break-Into-MultiLines($srcLine2Print,$srcLine,#srctotalLinesCreated,#srccmdIFCounter)
     End-if

     if #tgtLenofString > {MaxFMLCol}
        Let #LineBroken = 1
        Let #tgtLineBroken = 1
        Do Break-Into-MultiLines($tgtLine2Print,$tgtLine,#tgttotalLinesCreated,#tgtcmdIFCounter)
     End-if

     if $GraphicEnabledInMatch = 'Y'
        Let $srcLineGraphicPointer = ' '
        Let $tgtLineGraphicPointer = ' '

        Let $srcLineGraphicPointer = substrp($srcLineIdentifier,#LoopLineCounter,1)
        Let $tgtLineGraphicPointer = substrp($tgtLineIdentifier,#LoopLineCounter,1)

     End-if

     if #LineBroken = 0
        do printSourceLine
        do printTargetLine
     else
        if (#srcLineBroken = 1 and #tgtLineBroken = 1)  ! both source and target formulas have been broken down
           Let #Lines = 1
           Let #totLines = #srctotalLinesCreated
           if  #totLines < #tgttotalLinesCreated
               Let #totLines = #tgttotalLinesCreated
           End-if

           While #Lines  <= #totLines
                 Do Process-Src-Lines
                 Do Process-Tgt-Lines

                 Do Initiate-New-Page
                 Let #srcLenofString = length($srcLine2Print)
                 Let #tgtLenofString = length($tgtLine2Print)

                 if #srcLenofString > 2
                    Do printSourceLineBroken
                 End-if
                 if #tgtLenofString > 2
                    Do printTargetLineBroken
                 End-if
                 if  #srctotalLinesCreated < #tgttotalLinesCreated ! if sourcelines < targetlines, we may need to add new row
                     if #lines > #srctotalLinesCreated ! the current line is over total source lines
                        print ' ' (+1,1)
                     End-if
                 End-if
                 Let #Lines = #Lines + 1
           End-while

        end-if

        if #srcLineBroken = 0 and #tgtLineBroken = 1
           Let #Lines = 1
           Let #totLines = #tgttotalLinesCreated

           Do printSourceLine

           While #Lines  <= #totLines
                 Do Process-Tgt-Lines
                 Let #tgtLenofString = length($tLine2Print)
                 if #tgtLenofString > 2
                    Do printTargetLineBroken
                    If #Lines  < #totLines
                       print ' ' (+1,1) ! forcing a dummy new row to be printed
                    End-if
                 End-if
                 Let #Lines = #Lines + 1
           End-while
        end-if

        if #srcLineBroken = 1 and #tgtLineBroken = 0
           Let #Lines = 1
           let $display = 'Y'
           Let #totLines = #srctotalLinesCreated
           While #Lines  <= #totLines
                 Do Process-Src-Lines
                 Let #srcLenofString = length($sLine2Print)
                 if #srcLenofString > 2
                    Do printSourceLineBroken
                 End-if
                 if #Lines = 1
                    Do printTargetLine
                 End-if

                 Let #Lines = #Lines + 1
           End-while
        end-if
     End-if

     Let #LoopLineCounter = #LoopLineCounter + 1
     if #srcSearchPos <= 1 and #tgtSearchPos <= 1
        break
     End-if
     let $display = 'N'
   End-While
  Do DebugProc ('E', 'PrintFormula')
End-Procedure ! function to reformat code
!
Begin-Procedure printSourceLine

      if $GraphicEnabledInMatch = 'Y'
         if $srcLineGraphicPointer = '*'
            print $srcLine2Print (+1,{Col_8}) bold
         Else
            print $srcLine2Print (+1,{Col_8})
         End-if
      Else
         If #Lines = 1
           print $srcLine2Print (+1,{Col_8})
         Else
           print $srcLine2Print (+1,{Col_8})
         End-if
      End-if
End-Procedure !
!
Begin-Procedure printTargetLine

        if $GraphicEnabledInMatch = 'Y'
           if $tgtLineGraphicPointer = 'X'
              print $tgtLine2Print (,{Col_9})  shade
           Else
              print $tgtLine2Print (,{Col_9})
           End-if
        Else
           print $tgtLine2Print (,{Col_9})
        End-if
End-Procedure !
!
Begin-Procedure printSourceLineBroken

        if $GraphicEnabledInMatch = 'Y'
           if $srcLineGraphicPointer = '*'
              print $sLine2Print (+1,{Col_8}) bold
           Else
              print $sLine2Print (+1,{Col_8})
           End-if
        Else
           print $sLine2Print (,{Col_8})
        End-if

End-Procedure !
!
Begin-Procedure printTargetLineBroken

        if $GraphicEnabledInMatch = 'Y'
           if $tgtLineGraphicPointer = 'X'
              print $tLine2Print (,{Col_9})  shade
           Else
              print $tLine2Print (,{Col_9})
           End-if
        Else
           If #Lines = 1
              print $tLine2Print (+1,{Col_9})
           End-If
        End-if

End-Procedure !
!
!****************************************
! Process broken lines from source formula
!****************************************
! Extract lines from source formula.
Begin-Procedure Process-Src-Lines

      Do Get-Line($srcLine,1,#searchPos)  ! Retrieve a Line from Source.
      Let #searchPos = #searchPos - 1
      Let $sLine2Print = substrp($srcLine,1,#searchPos)
      if #Lines < #srctotalLinesCreated
         if #searchPos <=0
            Let $sLine2Print = $srcLine
         End-if
      End-if

      Let #searchPos = #searchPos + 2
      Let $srcLine = substrp($srcLine,#searchPos,#string_size)

End-Procedure !
!
!****************************************
! Process broken lines from Target formula
!****************************************
! Extract lines from target formula.
Begin-Procedure Process-Tgt-Lines
      Do Get-Line($tgtLine,1,#searchPos)  ! Retrieve a Line from Source.

      Let #searchPos = #searchPos - 1
      Let $tLine2Print = substrp($tgtLine,1,#searchPos)

      if #Lines <= #tgttotalLinesCreated
         if #searchPos <=0
            Let $tLine2Print = $tgtLine
         End-if
      End-if

      Let #searchPos = #searchPos + 2
      Let $tgtLine = substrp($tgtLine,#searchPos,#string_size)

End-Procedure !
!
!****************************************
! Extract Lines from the formula and ident them accordingly
!****************************************
! extract a line of formula from the 1st position until the char(13) and remove the extract
! line from the main formula code
! Validation is performed on the extracted line to see if it needs to be indented.
!
! Parameters : :$formulaCode - This by reference variable contains the formula string whose content is extracted
!                              and printed. A line is extracted and the value reset by removing the line.
!            : :#searchPos   - This by reference variable contains the position where the EOL is found
!            : :$extractedLine - Thys by reference variable contains the extracted line
!            : :#cmdIFCounter - This by reference variable contains the Number of IF statements found at the time of
!                             - extracting the line.
Begin-Procedure Extract-Print-Line(:$formulaCode,:#searchPos,:$extractedLine,:#cmdIFCounter)

     Let $extractedLine = ''

     Do Get-Line($FormulaCode,1,#searchPos)  ! Retrieve a Line from Source.

     If #Loop <= #string_size  ! extract the line if we're not at the end of the line
        Let $command = ''
        Let #searchPos = #searchPos -1  ! move pointer backward 1 position to ignore (13)

        Let $StrPartOfFmla = substrp($formulaCode,1,#searchPos ) ! extract the string

        Let #searchPos = #searchPos + 2  ! move pointer forward 2 position to include char(10)

        Let $strPartOfFmla = ltrim($strPartOfFmla,' ') ! remove leading spaces
        Let $strPartOfFmla = rtrim($strPartOfFmla,' ') ! remove trailing spaces

        if $strPartOfFmla = '***' or $strPartOfFmla = 'XXX'
           Let $strPartOfFmla = '   '
        End-if

        If substrp($strPartOfFmla,1,3) = 'IF ' ! check whether a IF was encountered
           Let $command = 'IF'
           Let #cmdIFCounter = #cmdIFCounter + 1
        End-if

        If substrp($strPartOfFmla,1,5) = 'ENDIF' ! check whether a IF was encountered
           Let #cmdIFCounter = #cmdIFCounter - 1
           Let $command = 'ENDIF'
        End-if

        Let #tempCounter = 0

        If substrp($strPartOfFmla,1,4) = 'ELSE' ! check whether a IF was encountered
           Let $command = 'ELSE'
        End-if

        Let $calcNestedSpaces = ''

        if $command <> 'IF' and $command <> 'ELSE' and $command <> 'ENDIF'
           IF #cmdIFCounter > 0
              Let $calcNestedSpaces = lpad($calcNestedSpaces,3 ,' ') ! forcing 3 spaces always.
           else
               Let $calcNestedSpaces = ''
           End-if
        else
           if #cmdIFCounter > 1
              let #tCount = (#cmdIFCounter - 1)
              Let #tempCounter = #tCount * 3
           End-if
        End-if

        Let #totalLen = length($formulaCode)

        Let $extractedLine = $calcNestedSpaces || $StrPartofFmla
        Let $formulaCode = substrp($formulaCode,#searchPos,#totalLen)

     end-if

End-Procedure
!
!****************************************
! Break a line into multiple lines
!****************************************
! This procedure function will break a line into multiple lines (when the length is > maxlen= 47
! Words are identified by space between them. if the extracted word is too long to fit in a line, it is moved to the next
! line. Finally a single string with multiple lines are created.
!
! Parameters : $codeLine - Is a line of the formula which must be broken into multiple lines
!            : :$newLines - A by reference variable containing the new - broken down lines of a single line of formula
!            : #NewLinesCreatedCount - by reference variable identifying the number of lines created for a single line
!            : #ifCount - Identifier for the function specifying if the line is part of a IF statement.
!
Begin-Procedure Break-Into-MultiLines($codeLine,:$newLines,:#NewLinesCreatedCount,#ifCount)

  Do DebugProc ('S', 'Break-Into-MultiLines')
   Let #maxLen = 1
   Let #Loop   = 1

   Let $newLines = ''
   Let $newString = ''
   Let $currentLine = ''

   Let #NewLinesCreatedCount = 1
   Let #elementStarted = 0

   Let $lineIsIF = 'N'

   if #ifCount > 0
      Let $lineIsIF = 'Y'
   End-if

   Let #debug = 0
   While #maxLen <= length($codeLine)
         Let $char = substrp($codeLine,#maxLen,1)
         if $char = '['
            Let #elementStarted = 1
         End-if
         if $char = ']'
            Let #elementStarted = 0
         End-if

         if $char = ' '
            if #elementStarted = 0
               Let $newString = $newString || $char

               Let #newStrLen = Length($newString)
               Let #tempCounter = length($currentLine)

               Let #tempCounter = #tempCounter + #newStrLen

               if  #tempCounter >= {MaxFMLCol} ! the total length of merged string + new word is big

                   if #NewLinesCreatedCount = 1
                      Let $newLines = $currentLine
                   else
                      Let $newLines = $newLines || $_Chr13 || $currentLine
                   End-if
                   if #ifCount > 0
                      Let $currentLine = '   ' || $newString
                   else
                      Let $currentLine = $newString
                   End-if

                   Let $newString = ''
                   Let #NewLinesCreatedCount = #NewLinesCreatedCount + 1

               else
                   Let $currentLine = $currentLine || $newString
                   Let $newString = ''
               end-if
            else
               Let $newString = $newString || $char
            end-if
         else
            Let $newString = $newString || $char
         End-if

         Let #maxLen = #maxLen + 1

   End-While

   Let #newStrLen = Length($newString)
   if #newStrLen > 0
      Let #newStrLen = Length($newString)
      Let #newLineLen = Length($newLines)
      Let #tempCounter = length($currentLine)
      Let #tempCounter = #tempCounter + #newStrLen

      if  #tempCounter >= {MaxFMLCol} ! the total length of merged string + new word is big
          if #newLineLen > 2
             if #ifCount > 0
                Let $newString = '   ' || $newString
             End-if
             Let $newLines = $newLines || $_chr13 || $currentLine || $_chr13 || $newString || $_chr13
             Let #NewLinesCreatedCount = #NewLinesCreatedCount + 1
          Else
             Let $newLines = $currentLine || $_chr13 || $newString || $_chr13
             Let #NewLinesCreatedCount = #NewLinesCreatedCount + 1
          End-if
      else
          Let $newLines = $newLines || $_chr13 || $currentLine || $newString || $_chr13
      End-if
   End-if

  Do DebugProc ('E', 'Break-Into-MultiLines')
End-Procedure
!
!**********
Begin-Procedure Initiate-New-Page
   if #current-line > 60
      New-page
   End-if
End-Procedure
!
!****************************************
! Perform Matchmaking to find similar / dis-similar lines so that the report can show the right comparision
!****************************************
Begin-Procedure matchMaking
!#define DEBUGGP
  Do DebugProc ('S', 'matchMaking')
  ! source is what is being loaded into the database.
  ! target is what already exists.

  let #loopCounter = 1 ! Controls the number of lines being processed - Loops for all rows in Source formula

  Let $matchMakeEnabled = 1 ! Setting this = 1 means matchmaking is enabled, while printing, we will lines according to
                            ! their status of new / modified / deleted.

  Let $mstSrcFormula = $srcFormula
  Let $mstTgtFormula = $tgtFormula

  let $srcNewFormula = '' ! the newly structured source formula will be stored here
  let $tgtNewFormula = '' ! the newly structured target formula will be stored here

  Let #tgtLastPrintedLine = 0  ! identify the last processed / printed line from target

  Let #srcLastPrintedLine = 0  ! identify the last processed / printed line from source

  Let #srcSearchPos = 1   ! identify the searchPosition of EOL in source
  Let #tgtSearchPos = 1   ! identify the searchPosition of EOL in target

  Let $srcLineIdentifier = '' ! This string holds a position based identifier to tag new / modified / deleted lines
                              ! in source
  Let $tgtLineIdentifier = '' ! This string holds a position based identifier to tag new / modified / deleted lines
                              ! in source
  While #loopCounter <= #srcTotalLines

     Do ExtractLine($srcFormula,$srcLine, #searchPos)  ! Retrieve a Line from Source.

     if #searchPos <= 1 ! we dont have any proper line to process - so break the loop and check if all target has been
                        ! processed
        break
     End-if

     Do lookupLineInTarget($srcLine,#tgtLineSameAsSource)

     if #tgtLineSameAsSource > 0 ! we found the matching target Line

        If #tgtLineSameAsSource > 1      ! The target line matching the source would ideally be the 1st line, if its not
                                         ! we need to perform reverse matching and identify any lines that must be dumped
                                         ! from source before we match the lines.

                                         ! If a target row is found in source, we will print all skipped rows (as
                                         ! they would be new and print the identified row, We will do this for all
                                         ! the skipped rows in target.

           Let #dumpSrcCounter = 1
           Let #dmysearchPos = 1

           While #dumpSrcCounter < #tgtLineSameAsSource
                 Do ExtractLine($tgtFormula,$dmyLine,#dmysearchPos)  ! Retrieve a Line from Source.

                 if #dmysearchPos <= 1 ! we dont have any proper line to process - so break the loop and check if all target has been
                                       ! processed
                    break
                 End-if

                 Let $srcLineIdentifier = $srcLineIdentifier || ' '
                 Let $tgtLineIdentifier = $tgtLineIdentifier || 'X'


                 Let $srcNewFormula = $srcNewFormula || 'XXX'    || $chr13  ! append a blank line to the source
                 Let $tgtNewFormula = $tgtNewFormula || $dmyLine || $chr13  ! append the line to the target

                 let #dumpSrcCounter = #dumpSrcCounter + 1
                 Let #tgtLastPrintedLine = #tgtLastPrintedLine + 1
            End-While
            ! Having put the target lines as deleted, now include the source and target Line that match
            Let $srcNewFormula = $srcNewFormula || $srcLine || $chr13
            Let $tgtNewFormula = $tgtNewFormula || $srcLine || $chr13

            Let $srcLineIdentifier = $srcLineIdentifier || ' '
            Let $tgtLineIdentifier = $tgtLineIdentifier || ' '

            ! If the line in source is at the same level as target, we can remove this line from target as well

            Do ExtractLine($tgtFormula,$tgtLine, #tgtsearchPos)  ! Retrieve a Line from Source.

            Let #tgtLastPrintedLine = #loopCounter ! SET the line printed as the last target Line.
            Let #srcLastPrintedLine = #loopCounter ! set lastprintedLine counter to the line being processed in source.


        Else                                    ! yes the matching line is the immediate next line, simply print them

                                                ! the source and target are on same level. Put the values into the
                                                ! master variable.
           Let $srcNewFormula = $srcNewFormula || $srcLine || $chr13
           Let $tgtNewFormula = $tgtNewFormula || $srcLine || $chr13

           Let $srcLineIdentifier = $srcLineIdentifier || ' '
           Let $tgtLineIdentifier = $tgtLineIdentifier || ' '

           ! If the line in source is at the same level as target, we can remove this line from target as well

           Do ExtractLine($tgtFormula,$tgtLine, #tgtsearchPos)  ! Retrieve a Line from Source.

           Let #tgtLastPrintedLine = #loopCounter ! SET the line printed as the last target Line.
           Let #srcLastPrintedLine = #loopCounter ! set lastprintedLine counter to the line being processed in source.

        End-if
     Else                                         ! A matching line was not found in target, this could be new in source

        Let $srcLineIdentifier = $srcLineIdentifier || '*'
        Let $tgtLineIdentifier = $tgtLineIdentifier || ' '

        Let #srcLastPrintedLine = #loopCounter ! set lastprintedLine counter to the line being processed in source.

        Let $srcNewFormula = $srcNewFormula || $srcLine || $chr13  ! append the line to the source
        Let $tgtNewFormula = $tgtNewFormula || '***'    || $chr13  ! append a blank line to the target

     End-if

     let #loopCounter = #loopCounter + 1

  End-While

  if #tgtLastPrintedLine < #tgtTotalLines ! if we have any pending targetlines, we will dump them to the output
     While #tgtLastPrintedLine < #tgtTotalLines
            Do ExtractLine($tgtFormula,$dmyLine,#dmysearchPos)  ! Retrieve a Line from Source.

            if #dmysearchPos <= 1 ! we dont have any proper line to process - so break the loop and check if all target has been
                                  ! processed
               break
            End-if

            Let $srcLineIdentifier = $srcLineIdentifier || ' '
            Let $tgtLineIdentifier = $tgtLineIdentifier || 'X'


            Let $srcNewFormula = $srcNewFormula || '   '    || $chr13  ! append the line to the source
            Let $tgtNewFormula = $tgtNewFormula || $dmyLine || $chr13  ! append a blank line to the target

            let #dumpSrcCounter = #dumpSrcCounter + 1
            Let #tgtLastPrintedLine = #tgtLastPrintedLine + 1
       End-While
  End-if

  ! reassign formatted value to variables that is used by the printing routine.

  Let $srcFormula = $srcNewFormula
  Let $tgtFormula = $tgtNewFormula

  ! rebuild the size of the variables - before printing begins
  Let #size_src = length($srcFormula)
  Let #size_tgt = length($tgtFormula)

   If #size_src > #size_tgt
      let #string_size = #size_src
   Else
      let #string_size = #size_tgt
   End-If

   Let $finalReformat = 'Y'

   Do ReformatString($srcFormula,#srctotalLines,#Fldtype)

   Do ReformatString($tgtFormula,#tgttotalLines,#Fldtype)

  Do DebugProc ('E', 'matchMaking')
end-Procedure
!
!**********************
! Retrieve a Line     *
!**********************
! This local function / procedure will look for char 13 which is a line terminator. The position where found is returned
! to the calling routine.
! Parameters : $sourcecode    = This by reference containing formula is parsed to find the char 13 (end of line) identifier
!            : #extractLine   = The extracted line is returned.
!            : #PositionFound - This by reference variable returns the position where the EOL was found.
!
Begin-Procedure ExtractLine(:$sourceCode,:$extractLine,:#PositionFound)

   Let #PositionFound = -1
   let $extractLine = ''

   Let #PositionFound = instr($sourceCode,chr(13),1)

   let #lenOfString = length($sourceCode)

   if #PositionFound > 0
      Let #searchPos = #PositionFound - 1

      Let $extractLine = substrp($sourceCode,1,#searchPos)

      Let #searchPos = #searchPos + 2 ! move position for reading to 1 position after char 13

      Let $sourceCode = substrp($sourceCode,#searchPos,#lenOfString)   ! recreate the variable by removing the extracted line

   End-if

End-Procedure
!
!
!******************************************
! lookupLineInTarget - Search through target formula and find the matching Line
!******************************************
! Parameters :
! $line2Lookup        - The line from source formula that must be searched in Target
! #lastPrintedLine    - The starting point from where search should occur in the target formula.
! #LineMatchingSource - Return back the new line where the match occurred. (-1 if no match was found).
Begin-Procedure lookupLineInTarget($line2Lookup, :#LineMatchingSource)

   let #tgtLoopCounter = 1
   Let #searchPos = 1

   Let $targetFormula = $_TgtFormula ! make a copy of the target formula to work with.

   Let #LineMatchingSource = -1

   Let $Line2Lookup = ltrim($Line2Lookup, ' ')

   While #tgtLoopCounter <= #_tgtTotalLines

      Do ExtractLine($targetFormula,$tgtcodeLine,#searchPos)  ! Retrieve a Line from Source.

      if #searchPos <= 1
         Let #LineMatchingSource = -1
         break
      End-if

      Let $tgtcodeLine = ltrim($tgtcodeLine, ' ')
      if $line2Lookup = $tgtcodeLine ! the lines are similar.
         Let #lineMatchingSource = #tgtLoopCounter
         break
      End-if

      Let #tgtloopCounter = #tgtloopCounter + 1

   End-While

End-Procedure
!
!***********************************************************************
! Additional SQCs included in the report                               *
!***********************************************************************
!
#include 'datetime.sqc'     !Routines for date and time formatting
#include 'datemath.sqc'     !Date conversion procedures
#include 'hrsecty.sqc'      !Get SQR Security parameters
#include 'sqrtrans.sqc'     !Translate SQR strings to given language
#include 'prcsapi.sqc'      !Replaces stdapi.sqc
#include 'prcslng.sqc'      !Replaces getrplng.sqc
#include 'readxlat.sqc'     ! Procedure to read values from xlattable
#include 'reset.sqc'        !Reset printer procedure
#include 'number.sqc'       !Routines to format numbers


Begin-Procedure DebugProc ($step, $procName)

  if $_ShowDebugInfo = 'Y'
     Let $cDate = datenow()
     let $char = ''

     if $step = 'S'
        Let $showStatement = 'Starting : ' || $procName
        Show $showStatement noline
        show ' = ' noline
        show $cDate
     else
        Let $showStatement = 'Ended    : ' || $procName
        Show $showStatement noline
        show ' = ' noline
        show $cDate
     End-if
  End-if
End-Procedure
