!***********************************************************************
!  GPDEKU02:   KUG Health insurance Provider Refund List               *
!***********************************************************************
!                                                                      *
!                                                                      *
!                                                                      *
! This software and related documentation are provided under a         *
! license agreement containing restrictions on use and                 *
! disclosure and are protected by intellectual property                *
! laws. Except as expressly permitted in your license agreement        *
! or allowed by law, you may not use, copy, reproduce,                 *
! translate, broadcast, modify, license, transmit, distribute,         *
! exhibit, perform, publish or display any part, in any form or        *
! by any means. Reverse engineering, disassembly, or                   *
! decompilation of this software, unless required by law for           *
! interoperability, is prohibited.                                     *
! The information contained herein is subject to change without        *
! notice and is not warranted to be error-free. If you find any        *
! errors, please report them to us in writing.                         *
!                                                                      *
!
! Copyright (C) 1988, 2013, Oracle and/or its affiliates.              *
! All Rights Reserved.                                                 *
!----------------------------------------------------------------------
!
!          $Date:  2013/01/18:03:36:11                                 !
!       $Release:  HR92                                                !
!      $Revision:  101                                                 !
!                                                                      *
!***********************************************************************
! changes:
! wdu06-881kug2 created new report
! wdu06-881kug3 only print rows with amounts <> 0
! wdu06-881b10 added process instance for parallel execution of gpdeku01 and gpdeku02
! wdu06-890b5 label changes Soll/Ist
! adj09-900b10 Refund for the Employer Social Insurance Contributions
!
!#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20060516 wdu06-890b5==='
#define gpdeversionstamp '===FUNCTIONAL UPDATE STAMP: 20090317 adj09-900b10'
! #define debug
!
!
!
#include 'setenv.sqc' !set environment


!*****************************************************************************
begin-PROGRAM
  do Init-DateTime
  do Init-Number
  do Get-Current-DateTime
  do Init-Report
  do Process-Main
  do Stdapi-Term
end-PROGRAM



begin-heading 10  FOR-REPORTS   =  (report2)
!
! heading for the report
!
    alter-printer
    font= 4
    point-size = 7.2

    ! notice: if we can have differing values for Pay_Entity, then we must use the 
    !         last-row-version as an input here!
    do Get-Payentity-Data($Ctl_PayEntity, $Ctl_Curr_Pay_End_DT, $hdr_abr_Payentity_name,
      $hdr_abr_Payentity_street,$hdr_abr_Payentity_street2,$hdr_abr_Payentity_street3,
      $hdr_PoBox,$hdr_abr_Payentity_zip_city,$Nation,$Post,$Cit)

    ! 
    do GetProviderData($Ctl_Curr_Pay_End_Dt, $hdr_KUG_Provider,$KK_Name,$KK_Nummer,
                $KK_Street,$KK_ZipCity,$Health_Rate_East,$Health_Rate_West,
                $Beitragskonto,$Zahlstellen_nr,$Ctl_PayEntity)
                
    !do HeadingInfos
    do CX_StandardHeaderBox

    ! switch back the font to body text.
    alter-printer
    font= 3
    point-size =13
end-heading







begin-procedure bodybox
    alter-printer
    font= 4
    point-size =13
    
    let #BoxLine1 = #currLineV        !14
    let #BoxLine2 = #BoxLine1 +1
    let #BoxLine3 = #BoxLine2 +1
    let #BoxLine4 = #BoxLine3 +1
    !
    graphic (#BoxLine2,1,184) box 3 1 12
    graphic (#BoxLine1,#vline1,3) vert-line 1
    
    graphic (#BoxLine1,#vline2,3) vert-line 1
    graphic (#BoxLine2,#vline3,2) vert-line 1
    graphic (#BoxLine1,#vline4,3) vert-line 1
    graphic (#BoxLine1,#vline5,3) vert-line 1
    graphic (#BoxLine1,#vline6,3) vert-line 1
    graphic (#BoxLine1,#vline7,3) vert-line 1        ! after Stkl
    
    graphic (#BoxLine1,#vline8,3) vert-line 1
    graphic (#BoxLine1,#vline9,3) vert-line 1
    graphic (#BoxLine1,#vline10,3) vert-line 1
    graphic (#BoxLine1,#vline11,3) vert-line 1
    
    print 'Lfd.'     (#BoxLine2,2)  bold
    print 'Nr.'      (#BoxLine3,2)  bold
    
    print 'Name, Vorname'        (#BoxLine2,10) bold
    print 'Versicherungsnummer'  (#BoxLine3,10) bold
    
    print '   Ausfallstunden'     (#BoxLine2,49) bold
    print '   '                (#BoxLine3,49) bold
    print 'KrG'                (#BoxLine3,+10) bold
    print '   '                (#BoxLine4,49) bold
    print '   '                (#BoxLine4,+10) bold
    
    print 'Sollentgelt'        (#BoxLine2,69) bold
    print '(ungerundet)'       (#BoxLine3,69) bold
    
    print 'Istentgelt'         (#BoxLine2,83) bold
    print '(ungerundet)'       (#BoxLine3,83) bold
    
    print 'Leistungsgrp./'      (#BoxLine2,96) bold
    print 'Leistungssatz'       (#BoxLine3,96) bold
    
    print 'Rechnerischer'       (#BoxLine2,111) bold
    print 'Leistungssatz'       (#BoxLine3,111) bold
    print 'Sollentgelt'         (#BoxLine4,111) bold
    
! wdu06-890b5 label changes Soll/Ist
    print 'Rechnerischer'       (#BoxLine2,125) bold
    print 'Leistungssatz'       (#BoxLine3,125) bold
    print 'Istentgelt'          (#BoxLine4,125) bold
    
    print 'Durchschnittl.'      (#BoxLine2,139) bold
    print 'Leistungssatz'       (#BoxLine3,139) bold
    print 'pro Stunde'          (#BoxLine4,139) bold
    
    ! jjj-deuev07
    !print 'Berücksichtigtes'    (#BoxLine2,153) bold
    !print 'Neben-'              (#BoxLine3,153) bold
    !print 'einkommen'           (#BoxLine4,153) bold
    print 'Höhe des'            (#BoxLine2,153) bold
    print 'KUG/SKUG'             (#BoxLine3,153) bold

    print 'Ausgezahltes'        (#BoxLine2,169) bold
    print 'Krankengeldgeld'     (#BoxLine3,169) bold
    print 'in Höhe von Kug'     (#BoxLine4,169) bold
end-procedure
!**************************************************************************





begin-procedure Init-Report
    do Stdapi-Init
    do Get-ReqParam
    
    ! wdu jw2005 modified 890 file handling
    let $outputdir = $sqr-report
    
    do GetFileExtension($RQ.OUTDESTFORMAT, $FileExtension)
    do GetOutputDir($RUNLOCATION,$OUTDESTTYPE,$OUTDEST,$outputdir)
    
    #debug show 'outputdir: ' $outputdir
    #debug show 'fileextension: ' $FileExtension
    
    ! wdu-04b4 changed for customer process: 
    ! begin runcontrol data
    ! If no oprid or runcontrol was passed on the commandline, then ask for it.
    ! After that, fetch functional data from the runcontrol.
    ! The input of functional values is no longer supported.
    if $prcs_process_instance = ''
        input $PRCS_OPRID 'OPRID '
        input $PRCS_RUN_CNTL_ID 'RUNCONTROL '
        ! wdu05b6: 'input $outputdir' requested by customer
        input $outputdir
        do Get-Report-Parameters
        ! always override language settings
        let $LANGUAGE_CD = 'GER'
        let $CURR_LANGUAGE_CD = 'GER'
    else
        do Get-Report-Parameters
    end-if
    ! end runcontrol data  
    
    
    move 'GPDEKU02' to $ReportID
    do Init_Report_Translation ($ReportID, $language_cd)
    do Append_Report_Translation ('GPDEGLOB')
    do Report-Translation
    !let $ReportTitle = $TITLE1 || ' ' || rtrim($Ctl_Year,' ')
end-procedure
!*****************************************************************************




begin-setup
  #include 'setupdb.sqc'
  declare-layout report2
    paper-size    = (19,11.69)
    orientation   = LANDSCAPE
    line-height   = 14
    max-columns   = 188
    left-margin   = .4
    bottom-margin = .15
    top-margin    = 0.4
  end-declare
  declare-report report2
    layout = report2
  end-declare
end-setup
!*****************************************************************************




begin-procedure Process-Main
    show {gpdeversionstamp}
    ! wdu05-881b8: backport of MVS changes from 891
    if $prcs_process_instance <> ''
        ! wdu89mp1: filename too long for mvs, removed process-instance in name for this
#ifdef MVS
        let $SqrName = 'GPDEKU02'
#else
        let $SqrName = 'GPDEKU02_' || $prcs_process_instance
#endif     
    else
        let $SqrName = 'GPDEKU02'
    end-if

    ! process instance for temp tables (preparation for new logic)
    let #ReportProcessInstance = 1
    
    do Get_Type_Options

    !
    ! employee independent inits
    !
    let $MinusNull = '-0' || $SDecimal || '00'
    let $PlusNull = '0' || $SDecimal || '00'
   
    do Get_VersionNr

    ! start the reporting
    do PrepareRowData
    do KugReport
end-procedure







!***********************************************************************!
! Report                                                                !
!***********************************************************************!
begin-procedure KugReport
! main procedure for the printing of the list
!
! expected runcontrol parameters:
! $Ctl_PayEntity            
! $Ctl_Curr_Pay_End_DT      =calculated in
!
    ! init vars for vertical lines in boxes
    let #vline0    = 1
    let #vline1    = 9
    let #vline2    = 48
    let #vline3    = 58
    let #vline4    = 68          ! after hours
    let #vline5    = 82
    let #vline6    = 95
    let #vline7    = 110         ! after Stkl
    let #vline8    = 124
    let #vline9    = 138
    let #vline10   = 152
    let #vline11   = 168
    let #vline12   = 184
    ! associated text positions  
    let #txtpos0 = #vline0 + 1
    let #txtpos1 = #vline1 + 1
    let #txtpos2 = #vline2 + 1
    let #txtpos3 = #vline3 + 1
    let #txtpos4 = #vline4 + 1
    let #txtpos5 = #vline5 + 1
    let #txtpos6 = #vline6 + 1
    let #txtpos7 = #vline7 + 1
    let #txtpos8 = #vline8 + 1
    let #txtpos9 = #vline9 + 1
    let #txtpos10 = #vline10 + 1
    let #txtpos11 = #vline11 + 1
    let #txtpos12 = #vline12 + 1
    
    ! get headerstring which only depends on $Ctl_Curr_Pay_End_DT
    do getHeaderDateString
    
    ! override the language for country specific statutory report
    let $curr_language_cd = 'GER'
    
    use-report report2
    let $reportdir = $outputdir || $SqrName || $FileExtension || '{FILESUFFIX}'
    new-report $reportdir
    
    !redundant?
    use-report report2
    alter-printer
    font= 4
    point-size =13
    
    do Print_Employee_Data_KK
end-procedure





begin-procedure Print_Employee_Data_KK
! main select here
    let #counter = 0        ! row counter per group 
    let #currLineN = 0
    let #currLineV = 0
    let #TempCol = 1
    
    ! BREAK detection
    let $lastPeriodEnd = ' '
    let $lastProvider = '-none-'
    let $lastStammNummer = '-none-'
    let #makePageBreak = 0
    
    ! Sums
    let #pageSumKug = 0
    let #groupSumKug = 0
    
    ! Events
    let #eventProviderChange = 0         ! Change of Provider coming up
    let #eventStammNummer = 0           ! Change of Stammnummer coming up
    let #eventFirstRow = 1              ! First row of the page
Begin-Select
K1.EMPLID
K1.CAL_RUN_ID
K1.EMPL_RCD
K1.GP_PAYGROUP
K1.CAL_ID
K1.ORIG_CAL_RUN_ID
K1.RSLT_SEG_NUM
K1.SEG_END_DT
K1.SLICE_END_DT
K1.GPDE_BL_TYPE
K1.PAY_ENTITY
K1.PRD_END_DT
K1.GPDE_AL_CPAY_ENDDT
K1.GPDE_KU_ID_NUM
K1.BGN_DT
K1.END_DT
K1.GPDE_DV_RVNR
K1.GPDE_KU_HKUGSUM
K1.GPDE_KU_HKGKK
K1.GPDE_KU_HKUGINS
K1.GPDE_KU_ENTSOLL
K1.GPDE_KU_ENTIST
K1.GPDE_TX_INC_TX_CLS
K1.GPDE_KU_BEN_GRP
K1.GPDE_KU_BEN_STP
K1.GPDE_KU_LSTSOLL
K1.GPDE_KU_LSTIST
K1.GPDE_KU_AVGLST
K1.GPDE_KU_KUGAMT
K1.GPDE_KU_NEBEN
K1.GPDE_KU_KUGKKAMT
K1.GPDE_SI_PROV_MAND
NM1.NAME
NM1.LAST_NAME
NM1.FIRST_NAME
    ! --- informational fields ---
    ! note: the #counter should only incremented when we really print a line

    let $RowType = &K1.GPDE_BL_TYPE 
    
    let $currentProvider = rtrim(&K1.GPDE_SI_PROV_MAND,' ')
    if ( $currentProvider <> $lastProvider )
        #debug show 'force begin of a new page (eventProviderChange)'
        let #makePageBreak = 1
        let #eventProviderChange = 1
    end-if
    
    let $KUG_Stammnummer = rtrim(&K1.GPDE_KU_ID_NUM,' ')
    if ( $KUG_Stammnummer <> $lastStammNummer )
        #debug show 'force begin of a new page (KUG_Stammnummer)'
        let #makePageBreak = 1
        let #eventStammNummer = 1
    end-if

    let $K1.GPDE_DV_RVNR = &K1.GPDE_DV_RVNR
    let $Emplid = rtrim(&K1.EMPLID,' ')
    let $EmplRcd = &K1.EMPL_RCD
   
    let $K1.PRD_END_DT = &K1.PRD_END_DT
!    if ( $K1.PRD_END_DT <> $lastPeriodEnd )
!        #debug show 'force begin of a new page (K1.PRD_END_DT)'
!        let #makePageBreak = 1
!    end-if

    ! parameter for row-date output
    !--let $SegmentDate = &K1.GPDE_AL_CPAY_ENDDT
    let $SegmentDate = &K1.PRD_END_DT
    do MakeRowDate      ! returns: $RowDateText  in format: MM.YY neu/alt
    
    #debug show 'Progressinfo: ' $Emplid ' / ' $KUG_Provider ' / ' $lastProvider ' - ' $hdr_KUG_Stammnummer
    
    let $NM1.NAME = rtrim(&NM1.NAME,' ')
    
! uncomment this if emplid should be printed
! #if debug    
!    ! debug: add Emplid
!    let $NM1.NAME = $NM1.NAME || ',' || $Emplid
! #endif    

    ! -- when name is printed in regular font we need to truncate at length 28
    if length($NM1.NAME) > 41
        let $NM1.NAME = substr($NM1.NAME,1,41)
    end-if

    let $K1.GPDE_TX_INC_TX_CLS = &K1.GPDE_TX_INC_TX_CLS
    let $K1.GPDE_KU_BEN_STP = &K1.GPDE_KU_BEN_STP
    let $K1.GPDE_KU_BEN_GRP = &K1.GPDE_KU_BEN_GRP
    
 
    ! --- numeric values ---
    ! --- HOURS --- 
    ! notice, that we need 4 digits because we can have negative hours in retro
    let #K1.GPDE_KU_HKUGSUM = &K1.GPDE_KU_HKUGSUM
    let #K1.GPDE_KU_HKUGSUM = 0        ! do not show on provider list
    do Format-Number(#K1.GPDE_KU_HKUGSUM,$K1.GPDE_KU_HKUGSUM,'B999.99')
    let #K1.GPDE_KU_HKGKK = &K1.GPDE_KU_HKGKK
    do Format-Number(#K1.GPDE_KU_HKGKK,$K1.GPDE_KU_HKGKK,'B999.99')
    let #wag=0    
    do Format-Number(#wag,$K1.GPDE_KU_HWAG,'B999.99')
    let #K1.GPDE_KU_HKUGINS = &K1.GPDE_KU_HKUGINS
    let #K1.GPDE_KU_HKUGINS = 0        ! do not show on provider list
    do Format-Number(#K1.GPDE_KU_HKUGINS,$K1.GPDE_KU_HKUGINS,'B999.99')

    let #K1.GPDE_KU_ENTSOLL = &K1.GPDE_KU_ENTSOLL
    do Format-Number(#K1.GPDE_KU_ENTSOLL,$K1.GPDE_KU_ENTSOLL,'B99,999.99')
    let #K1.GPDE_KU_ENTIST = &K1.GPDE_KU_ENTIST
    do Format-Number(#K1.GPDE_KU_ENTIST,$K1.GPDE_KU_ENTIST,'B99,999.99')
    
    let #K1.GPDE_KU_LSTSOLL = &K1.GPDE_KU_LSTSOLL
    do Format-Number(#K1.GPDE_KU_LSTSOLL,$K1.GPDE_KU_LSTSOLL,'B99,999.99')
    let #K1.GPDE_KU_LSTIST = &K1.GPDE_KU_LSTIST
    do Format-Number(#K1.GPDE_KU_LSTIST,$K1.GPDE_KU_LSTIST,'B99,999.99')
    
    ! jjj-DEUEV
    let #COL10 = #K1.GPDE_KU_LSTSOLL - #K1.GPDE_KU_LSTIST
    do Format-Number(#COL10,$COL10,'B99,999.99')

    let #K1.GPDE_KU_AVGLST = &K1.GPDE_KU_AVGLST
    do Format-Number(#K1.GPDE_KU_AVGLST,$K1.GPDE_KU_AVGLST,'B99,999.99')
    
    ! we dont want KUG amount to show on provider list
    let #K1.GPDE_KU_KUGAMT = &K1.GPDE_KU_KUGAMT
    ! let #K1.GPDE_KU_KUGAMT = 0
    do Format-Number(#K1.GPDE_KU_KUGAMT,$K1.GPDE_KU_KUGAMT,'B99,999.99')

    let #K1.GPDE_KU_KUGKKAMT = &K1.GPDE_KU_KUGKKAMT
    do Format-Number(#K1.GPDE_KU_KUGKKAMT,$K1.GPDE_KU_KUGKKAMT,'B99,999.99')
    
    let #K1.GPDE_KU_NEBEN = &K1.GPDE_KU_NEBEN
    do Format-Number(#K1.GPDE_KU_NEBEN,$K1.GPDE_KU_NEBEN,'B99,999.99')
    
    if #K1.GPDE_KU_KUGKKAMT <> 0
        ! show 'printing ' &K1.EMPLID
        let #counter = #counter + 1
        do Format-Number(#counter,$counter,'B9999')
        !
        do Print_KUG_line
    end-if
    !
    !
    ! the headinginfo issue:
    ! when a change is detected, then the new values are already loaded into the variables,
    ! but the page is not yet printed. 
    ! At this moment the heading is called and prints the values for the new row
    ! for the data of the old page.
    ! That is the reason why we need to keep the last-copies of all variables that are
    ! printed in the heading.
    !
    ! If we do not provide PAY_ENTITY as mandatory input, then we need to manage it too
    let $lastStammNummer = $KUG_Stammnummer
    let $hdr_KUG_Stammnummer = $lastStammNummer
    let $lastProvider = $currentProvider
    let $hdr_KUG_Provider = $lastProvider

    let $lastPeriodEnd = &K1.GPDE_AL_CPAY_ENDDT
    !
    ! if we had a break, it was evaluated and is no longer valid
    let #makePageBreak = 0
    
from PS_GPDE_RP_KU1_WRK K1
,PS_NAMES NM1
WHERE NM1.EMPLID=K1.EMPLID
AND NM1.EFFDT=(SELECT MAX(NM2.EFFDT ) FROM PS_NAMES NM2
    WHERE NM2.EMPLID=NM1.EMPLID
    )
AND K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.PROCESS_INSTANCE = #ReportProcessInstance
!
! For the providers we only want to see lines with KG
AND K1.GPDE_KU_KUGKKAMT <> 0
!
!no: AND K1.GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
ORDER BY K1.PAY_ENTITY,K1.GPDE_SI_PROV_MAND,NM1.NAME,K1.PRD_END_DT DESC 
!--,K1.GPDE_AL_CPAY_ENDDT
!
End-Select

    !
    ! --- general cleanup ---
    !
    if #counter = 0
        show 'Es wurden keine Daten zu den Eingaben gefunden.'
    end-if
    
    ! print the last footer, unless we have a new page 
    ! 
    !
    if #eventFirstRow = 0
        let #eventProviderChange = 1   ! pending change of value to nothing
        do ManagePrintPageSum
        ! report totals here
    end-if
end-procedure





begin-procedure Print_KUG_line
    ! print KUG line
    
    ! prepare the check for a new page because the page was full
    let #mm = 4 + #current-line
    
    ! check if we need a new page because of data content
    if #makePageBreak > 0
        ! page break needed because of a datachange
        ! we only do it when this is NOT the first row on the page
        if #eventFirstRow = 0
            ! we have a functional BREAK
            ! trick to force a new page: simulate we have printed enough for the page
            let #mm = 1000
        end-if
    end-if
    
    if #mm > 55
        ! we need a new page because the page is full
            ! but first finish the page before, this way we get a sum not on every page
            do ManagePrintPageSum
        new-page
        #debug show 'new page at emplid=' $Emplid
        let #eventFirstRow = 1
    end-if
    
    ! some line arithmetics
    let #currLineV = -10 + #current-line
    let #currLineN = #currLineV + 1
    if #currLineV <= 0
        let #currLineV = 1
        let #currLineN = 2
    end-if
    
    if #eventFirstRow > 0
        ! we have hit an empty page body, paint the column headings
        let #eventFirstRow = 0
        do bodybox
        let #currLineN = #currLineN + 4
        let #currLineV = #currLineV + 4
        let #TempCol = #TempCol + 4
    end-if
    
    let #TempCol = 1 + #currLineV
    
    !show 'current line N ' #currLineN
    !show 'current line V ' #currLineV
    !show 'TempCol  ' #TempCol
    
    graphic (#currLineN,1,184) box 3 1
    graphic (#currLineV,#vline1,3) vert-line 1
    
    graphic (#currLineV,#vline2,3) vert-line 1
    graphic (#currLineV,#vline3,3) vert-line 1
    graphic (#currLineV,#vline4,3) vert-line 1          ! after hours
    graphic (#currLineV,#vline5,3) vert-line 1
    graphic (#currLineV,#vline6,3) vert-line 1
    graphic (#currLineV,#vline7,3) vert-line 1         ! after Stkl
    
    graphic (#currLineV,#vline8,3) vert-line 1
    graphic (#currLineV,#vline9,3) vert-line 1
    graphic (#currLineV,#vline10,3) vert-line 1
    graphic (#currLineV,#vline11,3) vert-line 1
    
    alter-printer
    font = 3
    point-size = 16
    !  ---  Line#1  ---
    
    print $counter                (#TempCol,2)

    !print $RowDateText            (#TempCol,+3)  ! 9 chars
    
    ! -- name in smaller font
    alter-printer
    font = 4
    point-size = 12
    
    print $NM1.NAME               (#TempCol,+3)
    alter-printer
    font = 3
    point-size = 16
    
    !print 'Kug:'                  (#TempCol,48)
    print $K1.GPDE_KU_HKUGSUM     (#TempCol,48)
    print $K1.GPDE_KU_HKGKK       (#TempCol,+3)
    
    
    
    print $K1.GPDE_KU_ENTSOLL     (#TempCol,+3)
    print $K1.GPDE_KU_ENTIST      (#TempCol,+3)
    
    !print $K1.GPDE_TX_INC_TX_CLS  (#TempCol,+5)
    print $K1.GPDE_KU_BEN_GRP     (#TempCol,+6)
    print '/'                     (#TempCol,+1)
    print $K1.GPDE_KU_BEN_STP     (#TempCol,+1)
    
    print ' '                     (#TempCol,+3)
    
    print $K1.GPDE_KU_LSTSOLL     (#TempCol,+4)
    print $K1.GPDE_KU_LSTIST      (#TempCol,+4)
    
    print $K1.GPDE_KU_AVGLST      (#TempCol,+4)

    print $COL10                  (#TempCol,+6)

    print $K1.GPDE_KU_KUGKKAMT    (#TempCol,+6)

    
    ! ----  Line#2  ----
    let #TempCol = 1 + #TempCol
    alter-printer
    font = 4
    point-size = 13
    ! data
    
    alter-printer
    font = 3
    point-size = 16
    
    ! -- VSNR also in smaller font (like name)
    alter-printer
    font = 4
    point-size = 12
    print 'VSNR: '                (#TempCol,10)
    print $K1.GPDE_DV_RVNR        (#TempCol,+1)

    alter-printer
    font = 3
    point-size = 16
    
    print $K1.GPDE_KU_HWAG        (#TempCol,48)
    print $K1.GPDE_KU_HKUGINS     (#TempCol,+3)
    ! ---


    
    ! ----  Line#3  ----
    alter-printer
    font = 4
    point-size = 12
    let #TempCol = 1 + #TempCol
    print $RowDateText             (#TempCol,38)
    
    ! --- update the sums after the values were printed ---
    let #pageSumKug = #pageSumKug + #K1.GPDE_KU_KUGKKAMT
    !
    
    ! clean up
    alter-printer
    font = 3
    point-size = 16
    
NoPr2Kug:
end-procedure
!*************************************************************************************






begin-procedure ManagePrintPageSum
! print the page sum and update the total sum
! this is called BEFORE the current line is printed
!
    ! --- graphics for the Sums ---
    ! we reuse last used #TempCol 
    let #TempCol = #TempCol + 1         ! add an empty line
    let #thisLine1 = #TempCol
    let #thisLine2 = #TempCol +1
    let #tempw = #vline12 - #vline7
    graphic (#thisLine2,#vline7,#tempw) box 2 1
    graphic (#thisLine1,#vline10,2) vert-line 1
    graphic (#thisLine1,#vline11,2) vert-line 1
    ! ---
    
    let #TempCol = #TempCol + 1
    ! switch font, typewriter: font=3   proportional: font=4     
        alter-printer
        font = 4
        point-size = 13
    
    print 'Alle Beträge in Euro'       (#TempCol,#txtpos0)
     
    do Format-Number(#pageSumKug,$pageSumKug,'B999,999.99')
    print 'Summe Seite'                (#TempCol,#txtpos7)
    ! switch font, typewriter: font=3   proportional: font=4     
        alter-printer
        font = 3
        point-size = 16
    print $pageSumKug                  (#TempCol,#txtpos11)
    ! switch font, typewriter: font=3   proportional: font=4     
        alter-printer
        font = 4
        point-size = 13
 
    !
    ! --- Manage Total
    let #groupSumKug = #groupSumKug + #pageSumKug
    let #pageSumKug = 0
    !
    !
    let #TempCol = #TempCol + 1
   
    ! whenever we have an event then a pagebreak needs to happen
    if  #eventStammNummer = 1
        ! for now we only forward the event
        let #eventProviderChange = 1 
        let #eventStammNummer = 0
    end-if
    
    if  #eventProviderChange = 1
        ! a new Provider is coming up, print final sum
        let #eventProviderChange = 0
        !
        do Format-Number(#groupSumKug,$groupSumKug,'B999,999.99')
        print 'Gesamtsumme Stammnummer'     (#TempCol,#txtpos7)
        ! switch font, typewriter: font=3   proportional: font=4     
            alter-printer
            font = 3
            point-size = 16
        print $groupSumKug                  (#TempCol,#txtpos11)

        ! reset the group sum
        let #groupSumKug = 0
    else
        ! normal page change with intermediate sum
        do Format-Number(#groupSumKug,$groupSumKug,'B999,999.99')
        print 'Zwischensumme Stammnummer'   (#TempCol,#txtpos7)
        ! switch font, typewriter: font=3   proportional: font=4     
            alter-printer
            font = 3
            point-size = 16
        print $groupSumKug                  (#TempCol,#txtpos10)
        !
    end-if    
end-procedure



! #############
! #############
! ############# UTILS
! #############
! #############
!**********************************************************************
begin-procedure Get_VersionNr
begin-select
VERS.GPDE_VERSION_NR
VERS.NAME
from PS_GPDE_VERSION VERS
end-select
let $VersionsNr = rtrim(&VERS.GPDE_VERSION_NR,' ')
let $Bezeichn   = rtrim(&VERS.NAME, ' ')
end-procedure
!**********************************************************************





!************************************************************************
begin-procedure Get-ReqParam
Begin-Select
RQ.PRCSINSTANCE
RQ.PRCSTYPE
RQ.PRCSNAME
RQ.RUNLOCATION
RQ.OPSYS
RQ.DBTYPE
RQ.DBNAME
RQ.OPRID
RQ.BEGINDTTM
RQ.ENDDTTM
RQ.RUNSTATUS
RQ.RUNCNTLID
RQ.OUTDESTTYPE
RQ.OUTDESTFORMAT
RQ.TIMEZONE
RQ.SERVERNAMERUN
! wdu jw2005--file handling
OD.PRCSOUTPUTDIR
OD.OUTDEST
FROM PSPRCSPARMS OD , PSPRCSRQST  RQ
WHERE OD.PRCSINSTANCE  = RQ.PRCSINSTANCE
AND   RQ.PRCSINSTANCE = #prcs_process_instance

End-Select
  let $OUTDEST       = rtrim(&OD.OUTDEST,' ')
  let $RQ.OUTDESTTYPE = rtrim(&RQ.OUTDESTTYPE,' ')
  let $RQ.OUTDESTFORMAT = rtrim(&RQ.OUTDESTFORMAT,' ')
  let $Process_Inst  = to_char(&RQ.PRCSINSTANCE)
! wdu jw2005--file handling
  move 'RUNLOCATION'  to $FieldName
  move &RQ.RUNLOCATION to $FieldValue
  do Read-Translate-Table
  let $RUNLOCATION = rtrim(ltrim($XlatlongName,' '),' ')
  
  move 'OUTDESTTYPE'  to $FieldName
  move &RQ.OUTDESTTYPE to $FieldValue
  do Read-Translate-Table
  let $OUTDESTTYPE = rtrim(ltrim($XlatlongName,' '),' ')
  move 'OUTDESTFORMAT'  to $FieldName
  move &RQ.OUTDESTFORMAT to $FieldValue
  do Read-Translate-Table
  let $OUTDESTFORMAT = rtrim(ltrim($XlatlongName,' '),' ')
  evaluate $RQ.OUTDESTFORMAT
  when = '1'
    let $OUTDESTFORM = 'PDF'
    break
  when = '2'
    let $OUTDESTFORM = 'PDF'
    break
  when = '3'
    let $OUTDESTFORM = 'CSV'
    break
  when = '4'
    let $OUTDESTFORM = 'HP'
    break
  when = '5'
    let $OUTDESTFORM = 'HTM'
    break
  when = '6'
    let $OUTDESTFORM = 'LP'
    break
  when = '7'
    let $OUTDESTFORM = 'WKS'
    break
  when = '8'
    let $OUTDESTFORM = 'XLS'
    break
  when = '9'
    let $OUTDESTFORM = 'DOC'
    break
  when = '10'
    let $OUTDESTFORM = 'PS'
    break
  when = '11'
    let $OUTDESTFORM = 'RPT'
    break
  when = '12'
    let $OUTDESTFORM = 'RTF'
    break
  when = '13'
    let $OUTDESTFORM = 'SPF'
    break
  when = '14'
    let $OUTDESTFORM = 'TXT'
    break
  when = '15'
    let $OUTDESTFORM = 'PDF'
    break
  when = '16'
    let $OUTDESTFORM = 'PDF'
    break
  when-other
    let $OUTDESTFORM = 'PDF'
    break
  end-evaluate
end-procedure





!****************************************************************************
Begin-Procedure Report-Translation
  do Get_Field_Information ('GPDEGLOB', 'EMPLID',        $HD_EMPLID, #CW)
  do Get_Field_Information ('GPDEGLOB', 'BIRTHDATE',     $HD_BIRTHDT,#CW)
  do Get_Field_Information ('GPDEGLOB', 'HIRE_DT',       $HD_HIREDT, #CW)
  do Get_Field_Information ('GPDEGLOB', 'TERMINATION_DT',$HD_TERMDT, #CW)
  do Get_Field_Information ('GPDEGLOB', 'PRINTCLASS',    $PRINTCLASS,#CW)
  do Get_Field_Information ('GPDEGLOB', 'AMOUNT_SPEC',         $AMOUNT_SPEC,#CW)
  do Get_Field_Information ('GPDEGLOB', 'EURO',        $EUROCHAR,     #CW)
end-Procedure



!****************************************************************************************
begin-procedure Get_Type_Options
let $Name_Type       = ''
let $Addr_Type       = ''
let $Phone_Type      = ''
let $Email_Type      = ''
let $BirthName_Type  = ''
begin-select distinct
INST.NAME_TYPE
INST.ADDRESS_TYPE
INST.PHONE_TYPE
INST.E_ADDR_TYPE
INST.GPDE_BIRTH_NM_TYPE
   let $Name_Type      = &INST.NAME_TYPE
   let $Addr_Type      = &INST.ADDRESS_TYPE
   let $Phone_Type     = &INST.PHONE_TYPE
   let $Email_Type     = &INST.E_ADDR_TYPE
   let $BirthName_Type = &INST.GPDE_BIRTH_NM_TYPE
from PS_GPDE_AL_INSTALL INST
end-select
end-procedure



begin-procedure CX_StandardHeaderBox
!
!  Print a standard Header Box for the Report GPDETX03
!
#debug show 'CX_StandardHeaderBox Stamm=' $hdr_KUG_Provider

! -- display $SeitenNr

    let $AMOUNT_SPEC1 = $AMOUNT_SPEC || ' ' || $sav_CurrencyA
    !do Get_Job_Position
    let $HD_Title1 = 'KUG Abrechnungsliste Krankengeld  ' || $HeaderDateString 
    let $HD_Title2 = ' '
    
    alter-printer
    font= 4
    point-size =28
    print $HD_Title1        (1,1) bold
    
    alter-printer
    font= 4
    point-size =20
    print $HD_Title2        (3,1) bold
    
    alter-printer
    font= 4
    point-size =16

    graphic (5,1,184) horz-line 10
    !(horizontal line was printed)
    ! ---
       

    ! --- right header block with date/pagenum/version ---
    alter-printer
    font= 4
    point-size =13

    print 'Seite :'               (1,132)
    print '['                     (1,140)
    if #page-count < 10
    print #page-count          (0,0) edit 9
    else
    print #page-count          (0,0) edit 99
    end-if
    print ']'                     (0,0)
    do Format-DateTime($AsOfToday, $hdr_abr_header_date, {DEFDATE}, '', '')
    print 'Datum :'               (2,132)
    print $hdr_abr_header_date    (2,140)
    !
    ! Version number
    let $Bemerk = $Bezeichn || ' ' || $VersionsNr
    print $Bemerk (3,132)
    ! ---

    
    ! --- employer address line below headline ---
    !
    let $HD_Firma = $hdr_abr_Payentity_name
    let $HD_Strasse = $hdr_abr_Payentity_street
    let $HD_Ort = $hdr_abr_Payentity_zip_city
    let $HD_BetrNr =  $GPDE_DO_BTNR
    !
    let $temp_str = rtrim($HD_Firma,' ') || ',  ' ||rtrim($HD_Strasse,' ') || ',  ' ||rtrim($HD_Ort,' ')
    ! print bigger
    alter-printer
    font= 4
    point-size =16 
    print $temp_str          (5,1) bold
    ! ---


    ! --- report specific heading text below the header line ---
    print 'Krankenkasse    : '    (8,1) bold
    let $temp_str = $hdr_KUG_Provider || ' ' || $KK_Name
    print $temp_str          (8,30) bold

    print 'Kug-Stammnummer : '    (9,1) bold
    print $hdr_KUG_Stammnummer        (9,30) bold
    ! ---


    !switch back font
    alter-printer
    font= 4
    point-size =13
end-procedure






begin-procedure Get-PayEntity-Data($payentity, $curr_pay_end_dt, :$PayentityName,
                :$PayentityStreet,:$PayentityStreet2,:$PayentityStreet2,:$PoBox,
                :$PayentityZipCity,:$Nation,:$Post,:$Cit)
let $PayentityName    = ' '
let $PayentityStreet  = ' '
let $PayentityStreet2 = ' '
let $PayentityStreet3 = ' '
let $PoBox = ' '
let $PayentityZipCity = ' '
let $Nation = ' '
let $Post = ' '
let $Cit = ' '
begin-SELECT
CP.DESCR
CT.ADDRESS1
CT.ADDRESS2
CT.ADDRESS3
CT.ADDRESS4
CT.CITY
CT.POSTAL
CT.COUNTRY
  let $PayentityName = rtrim(&CP.DESCR,' ')
  let $PayentityStreet = rtrim(&CT.ADDRESS1,' ')
  let $PayentityStreet2 = rtrim(&CT.ADDRESS2,' ')
  let $PayentityStreet3 = rtrim(&CT.ADDRESS3,' ')
  let $PoBox = rtrim(&CT.ADDRESS4,' ')
  let $Nation = rtrim(&CT.COUNTRY,' ')
  let $Post = rtrim(&CT.POSTAL,' ')
  let $Cit = rtrim(&CT.CITY,' ')
  let $PayentityZipCity = rtrim(&CT.POSTAL,' ') || ' ' || rtrim(&CT.CITY,' ')
FROM  PS_GP_PYENT CP, PS_GP_PYENT_DTL CT
WHERE CP.PAY_ENTITY = CT.PAY_ENTITY
AND   CP.PAY_ENTITY = $payentity
AND   CT.EFFDT = (SELECT MAX(EFFDT) FROM   PS_GP_PYENT_DTL CT1
      WHERE  CT1.PAY_ENTITY = CT.PAY_ENTITY AND  CT1.EFFDT  <= $curr_pay_end_dt)
end-SELECT
end-procedure


begin-procedure get-values
! a callback from some sqc, do not remove
end-procedure





begin-procedure PrepareRowData
! prepare the current('C') and before('B') rows from the WA
!
show 'processing data for :' $Ctl_Curr_Pay_End_DT

! We need KUG information for the current calculation and the version before that
! for each CAL_ID which was handled (retro+current) in the current calculation.
!
! We may not have rows in GPDE_RP_KU01 for both periods, so we need another
! record as driver table (GPDE_RP_0001)
!
do CreateRowDriver

begin-sql
DELETE FROM PS_GPDE_RP_KU1_WRK WHERE PROCESS_INSTANCE = #ReportProcessInstance
end-sql


! ------------ get current calculation data including retro as 'C'
! 'N' is similar to 'C' but means, that no old version exists

begin-sql
INSERT INTO PS_GPDE_RP_KU1_WRK (
PROCESS_INSTANCE,
EMPLID,
CAL_RUN_ID,
EMPL_RCD,
GP_PAYGROUP,
CAL_ID,
ORIG_CAL_RUN_ID,
RSLT_SEG_NUM,
SEG_END_DT,
SLICE_END_DT,
GPDE_BL_TYPE,
PAY_ENTITY,
PRD_END_DT,
GPDE_AL_CPAY_ENDDT,
GPDE_KU_ID_NUM,
BGN_DT,
END_DT,
GPDE_DV_RVNR,
GPDE_KU_HKUGSUM,
GPDE_KU_HKGKK,
GPDE_KU_HKUGINS,
GPDE_KU_ENTSOLL,
GPDE_KU_ENTIST,
GPDE_TX_INC_TX_CLS,
GPDE_KU_BEN_GRP,
GPDE_KU_BEN_STP,
GPDE_KU_LSTSOLL,
GPDE_KU_LSTIST,
GPDE_KU_AVGLST,
GPDE_KU_KUGAMT,
GPDE_KU_KUGKKAMT,
GPDE_KU_NEBEN,
GPDE_SI_PROV_MAND,
GPDE_KU_QUALI_ELIG,
GPDE_KU_SI_REFUND,
GPDE_KU_TARGET_REG
)
SELECT
D1.PROCESS_INSTANCE, 
K1.EMPLID,
K1.CAL_RUN_ID,
K1.EMPL_RCD,
K1.GP_PAYGROUP,
K1.CAL_ID,
K1.ORIG_CAL_RUN_ID,
K1.RSLT_SEG_NUM,
K1.SEG_END_DT,
K1.SLICE_END_DT,
D1.GPDE_BL_TYPE,
K1.PAY_ENTITY,
K1.PRD_END_DT,
K1.GPDE_AL_CPAY_ENDDT,
K1.GPDE_KU_ID_NUM,
K1.BGN_DT,
K1.END_DT,
K1.GPDE_DV_RVNR,
K1.GPDE_KU_HKUGSUM,
K1.GPDE_KU_HKGKK,
K1.GPDE_KU_HKUGINS,
K1.GPDE_KU_ENTSOLL,
K1.GPDE_KU_ENTIST,
K1.GPDE_TX_INC_TX_CLS,
K1.GPDE_KU_BEN_GRP,
K1.GPDE_KU_BEN_STP,
K1.GPDE_KU_LSTSOLL,
K1.GPDE_KU_LSTIST,
K1.GPDE_KU_AVGLST,
K1.GPDE_KU_KUGAMT,
K1.GPDE_KU_KUGKKAMT,
K1.GPDE_KU_NEBEN,
K1.GPDE_SI_PROV_MAND,
K1.GPDE_KU_QUALI_ELIG,
K1.GPDE_KU_SI_REFUND,
K1.GPDE_KU_TARGET_REG
FROM PS_GPDE_RP_KU01 K1
,PS_GPDE_RP_KU_DRV D1
WHERE K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.EMPLID = D1.EMPLID
AND K1.CAL_RUN_ID = D1.CAL_RUN_ID
AND K1.EMPL_RCD = D1.EMPL_RCD
AND K1.GP_PAYGROUP = D1.GP_PAYGROUP
AND K1.CAL_ID = D1.CAL_ID
AND K1.ORIG_CAL_RUN_ID = D1.ORIG_CAL_RUN_ID
! no: --AND K1.RSLT_SEG_NUM = D1.RSLT_SEG_NUM
AND K1.SEG_END_DT = D1.SEG_END_DT
AND K1.PRD_END_DT = D1.PRD_END_DT
AND K1.PAY_ENTITY = D1.PAY_ENTITY
AND K1.GPDE_AL_CPAY_ENDDT = D1.GPDE_AL_CPAY_ENDDT
AND D1.GPDE_BL_TYPE IN  ('C','N')
AND D1.PROCESS_INSTANCE = #ReportProcessInstance
end-sql



! ------------ get previous (=before) row for each current calculation row as 'B'

begin-sql
INSERT INTO PS_GPDE_RP_KU1_WRK (
PROCESS_INSTANCE,
EMPLID,
CAL_RUN_ID,
EMPL_RCD,
GP_PAYGROUP,
CAL_ID,
ORIG_CAL_RUN_ID,
RSLT_SEG_NUM,
SEG_END_DT,
SLICE_END_DT,
GPDE_BL_TYPE,
PAY_ENTITY,
PRD_END_DT,
GPDE_AL_CPAY_ENDDT,
GPDE_KU_ID_NUM,
BGN_DT,
END_DT,
GPDE_DV_RVNR,
GPDE_KU_HKUGSUM,
GPDE_KU_HKGKK,
GPDE_KU_HKUGINS,
GPDE_KU_ENTSOLL,
GPDE_KU_ENTIST,
GPDE_TX_INC_TX_CLS,
GPDE_KU_BEN_GRP,
GPDE_KU_BEN_STP,
GPDE_KU_LSTSOLL,
GPDE_KU_LSTIST,
GPDE_KU_AVGLST,
GPDE_KU_KUGAMT,
GPDE_KU_KUGKKAMT,
GPDE_KU_NEBEN,
GPDE_SI_PROV_MAND,
GPDE_KU_QUALI_ELIG,
GPDE_KU_SI_REFUND,
GPDE_KU_TARGET_REG
)
SELECT 
D1.PROCESS_INSTANCE,
K1.EMPLID,
K1.CAL_RUN_ID,
K1.EMPL_RCD,
K1.GP_PAYGROUP,
K1.CAL_ID,
K1.ORIG_CAL_RUN_ID,
K1.RSLT_SEG_NUM,
K1.SEG_END_DT,
K1.SLICE_END_DT,
D1.GPDE_BL_TYPE,
K1.PAY_ENTITY,
K1.PRD_END_DT,
K1.GPDE_AL_CPAY_ENDDT,
K1.GPDE_KU_ID_NUM,
K1.BGN_DT,
K1.END_DT,
K1.GPDE_DV_RVNR,
-K1.GPDE_KU_HKUGSUM,
-K1.GPDE_KU_HKGKK,
-K1.GPDE_KU_HKUGINS,
-K1.GPDE_KU_ENTSOLL,
-K1.GPDE_KU_ENTIST,
K1.GPDE_TX_INC_TX_CLS,
K1.GPDE_KU_BEN_GRP,
K1.GPDE_KU_BEN_STP,
-K1.GPDE_KU_LSTSOLL,
-K1.GPDE_KU_LSTIST,
-K1.GPDE_KU_AVGLST,
-K1.GPDE_KU_KUGAMT,
-K1.GPDE_KU_KUGKKAMT,
-K1.GPDE_KU_NEBEN,
K1.GPDE_SI_PROV_MAND,
K1.GPDE_KU_QUALI_ELIG,
K1.GPDE_KU_SI_REFUND,
K1.GPDE_KU_TARGET_REG
FROM PS_GPDE_RP_KU01 K1
,PS_GPDE_RP_KU_DRV D1
WHERE K1.PAY_ENTITY = $Ctl_PayEntity
AND K1.EMPLID = D1.EMPLID
AND K1.CAL_RUN_ID = D1.CAL_RUN_ID
AND K1.EMPL_RCD = D1.EMPL_RCD
AND K1.GP_PAYGROUP = D1.GP_PAYGROUP
AND K1.CAL_ID = D1.CAL_ID
AND K1.ORIG_CAL_RUN_ID = D1.ORIG_CAL_RUN_ID
! no: --AND K1.RSLT_SEG_NUM = D1.RSLT_SEG_NUM
AND K1.SEG_END_DT = D1.SEG_END_DT
AND K1.PRD_END_DT = D1.PRD_END_DT
AND K1.PAY_ENTITY = D1.PAY_ENTITY
AND K1.GPDE_AL_CPAY_ENDDT = D1.GPDE_AL_CPAY_ENDDT
AND D1.GPDE_BL_TYPE = 'B'
AND D1.PROCESS_INSTANCE = #ReportProcessInstance
end-sql

end-procedure




begin-procedure MakeRowDate
! in:  $SegmentDate
! out: $RowSegDate      date in the format:  mm.yy
! out: $RowTypeInd      an indicator for old/new/-
! out: $RowDateText     date + indicator
!
   let #Date_Type1 = {DateType}
   do ConvertToComponents($SegmentDate,$yy1a,$mm1a,$dd1a)
   evaluate #Date_Type1
   when = 2
      let $RowSegDate = $yy1a || '{PTDateDelim}' || $mm1a
      break
   when-other
      let $RowSegDate = $mm1a || '{PTDateDelim}' || $yy1a
      break
   end-evaluate
   
   if $RowType = 'B'
        let $RowTypeInd = ' alt'
   else 
        if $RowType = 'C'
            let $RowTypeInd = ' neu'
        else
            ! for 'N' do not print indicator and date
            let $RowTypeInd = '    '
            let $RowSegDate = ' '
        end-if
   end-if

   let $RowDateText = $RowSegDate || $RowTypeInd
end-procedure





begin-procedure CreateRowDriver
!-------------------------------------------------------
! NOTICE: the driver is generic (does not depend on KUG)
! it can be copied and reused for all delta reports.
!-------------------------------------------------------
! create a helper table with a row for the current and previous calculation.
! we will use this later to find our rows from the KUG WA table
!
! GPDE_BL_TYPE
! 'C'   current calculation
! 'B'   before current calculation
! 'R'   raw data, discarded later
! 'N'   current calculation with no previous data
!
!
begin-sql
DELETE FROM PS_GPDE_RP_KU_DRV WHERE PROCESS_INSTANCE = #ReportProcessInstance
end-sql

! Find the current and the previous version for each calculation period
! -- when the emplid ever had KUG in our PAY-entity
! ==> raw driver
begin-sql
INSERT INTO PS_GPDE_RP_KU_DRV (
  PROCESS_INSTANCE
 ,EMPLID 
 ,CAL_RUN_ID 
 ,EMPL_RCD 
 ,GP_PAYGROUP 
 ,CAL_ID 
 ,ORIG_CAL_RUN_ID 
 ,RSLT_SEG_NUM 
 ,SEG_END_DT 
 ,PRD_END_DT 
 ,PAY_ENTITY 
 ,GPDE_AL_CPAY_ENDDT 
 ,GPDE_BL_TYPE
)
SELECT 
 #ReportProcessInstance
 ,A.EMPLID 
 ,A.CAL_RUN_ID 
 ,A.EMPL_RCD 
 ,A.GP_PAYGROUP 
 ,A.CAL_ID 
 ,A.ORIG_CAL_RUN_ID 
 ,A.RSLT_SEG_NUM 
 ,A.SEG_END_DT 
 ,A.PRD_END_DT 
 ,A.PAY_ENTITY 
 ,A.GPDE_AL_CPAY_ENDDT 
 ,'R'
  FROM PS_GPDE_RP_0001 A 
where A.PAY_ENTITY = $Ctl_PayEntity
AND (A.GPDE_AL_CPAY_ENDDT = (SELECT MAX(A2.GPDE_AL_CPAY_ENDDT) 
      from PS_GPDE_RP_0001 A2
      WHERE A2.EMPLID = A.EMPLID
        !no: AND A2.CAL_RUN_ID = A.CAL_RUN_ID 
        AND A2.EMPL_RCD = A.EMPL_RCD 
        !no: AND A2.GP_PAYGROUP = A.GP_PAYGROUP 
        AND A2.CAL_ID = A.CAL_ID
        AND A2.GPDE_AL_CPAY_ENDDT < $Ctl_Curr_Pay_End_DT
    )
    OR A.GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
)
AND A.EMPLID IN (SELECT DISTINCT EMPLID FROM PS_GPDE_RP_KU01 WHERE PAY_ENTITY=$Ctl_PayEntity)
end-sql

! mark rows from the current calculation
! these will always be printed if a KUG WA row exists.
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='C' 
WHERE GPDE_AL_CPAY_ENDDT = $Ctl_Curr_Pay_End_DT
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql


! mark rows from previous periods only when:
!   -- a row exists for the same calendar which is marked 'C'
!
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='B' 
WHERE EXISTS (
    SELECT 'X' FROM PS_GPDE_RP_KU_DRV DRV2
    WHERE 0=0
        AND DRV2.EMPLID = PS_GPDE_RP_KU_DRV.EMPLID 
!no:    AND DRV2.CAL_RUN_ID = PS_GPDE_RP_KU_DRV.CAL_RUN_ID 
        AND DRV2.EMPL_RCD = PS_GPDE_RP_KU_DRV.EMPL_RCD 
!no:    AND DRV2.GP_PAYGROUP = PS_GPDE_RP_KU_DRV.GP_PAYGROUP 
        AND DRV2.CAL_ID = PS_GPDE_RP_KU_DRV.CAL_ID 
!no:     AND DRV2.ORIG_CAL_RUN_ID = PS_GPDE_RP_KU_DRV.ORIG_CAL_RUN_ID 
!no:     AND DRV2.RSLT_SEG_NUM = PS_GPDE_RP_KU_DRV.RSLT_SEG_NUM 
!no:     AND DRV2.SEG_END_DT = PS_GPDE_RP_KU_DRV.SEG_END_DT 
        AND DRV2.PRD_END_DT = PS_GPDE_RP_KU_DRV.PRD_END_DT 
        AND DRV2.PAY_ENTITY = PS_GPDE_RP_KU_DRV.PAY_ENTITY 
!no:     AND DRV2.GPDE_AL_CPAY_ENDDT = PS_GPDE_RP_KU_DRV.GPDE_AL_CPAY_ENDDT 
        AND DRV2.GPDE_BL_TYPE = 'C'
        AND DRV2.PROCESS_INSTANCE = #ReportProcessInstance
)
AND GPDE_BL_TYPE='R' 
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql

! Mark rows which are new and have no corresponding old row
! these should be printed without "neu" label
!
begin-sql
UPDATE PS_GPDE_RP_KU_DRV SET GPDE_BL_TYPE='N' 
WHERE NOT EXISTS (
    SELECT 'X' FROM PS_GPDE_RP_KU_DRV DRV2
    WHERE 0=0
        AND DRV2.EMPLID = PS_GPDE_RP_KU_DRV.EMPLID 
!no:    AND DRV2.CAL_RUN_ID = PS_GPDE_RP_KU_DRV.CAL_RUN_ID 
        AND DRV2.EMPL_RCD = PS_GPDE_RP_KU_DRV.EMPL_RCD 
!no:    AND DRV2.GP_PAYGROUP = PS_GPDE_RP_KU_DRV.GP_PAYGROUP 
        AND DRV2.CAL_ID = PS_GPDE_RP_KU_DRV.CAL_ID 
!no:     AND DRV2.ORIG_CAL_RUN_ID = PS_GPDE_RP_KU_DRV.ORIG_CAL_RUN_ID 
!no:     AND DRV2.RSLT_SEG_NUM = PS_GPDE_RP_KU_DRV.RSLT_SEG_NUM 
!no:     AND DRV2.SEG_END_DT = PS_GPDE_RP_KU_DRV.SEG_END_DT 
        AND DRV2.PRD_END_DT = PS_GPDE_RP_KU_DRV.PRD_END_DT 
        AND DRV2.PAY_ENTITY = PS_GPDE_RP_KU_DRV.PAY_ENTITY 
!no:     AND DRV2.GPDE_AL_CPAY_ENDDT = PS_GPDE_RP_KU_DRV.GPDE_AL_CPAY_ENDDT 
        AND DRV2.GPDE_BL_TYPE = 'B'
        AND DRV2.PROCESS_INSTANCE = #ReportProcessInstance
)
AND GPDE_BL_TYPE='C' 
AND PROCESS_INSTANCE = #ReportProcessInstance
end-sql


end-procedure


begin-procedure Get-Translate-Value

  evaluate $HD_mm
    when = '01'
      let $HD_Month_Name = 'Januar'
      break
    when = '02'
      let $HD_Month_Name = 'Februar'
      break
    when = '03'
      let $HD_Month_Name = 'März'
      break
    when = '04'
      let $HD_Month_Name = 'April'
      break
    when = '05'
      let $HD_Month_Name = 'Mai'
      break
    when = '06'
      let $HD_Month_Name = 'Juni'
      break
    when = '07'
      let $HD_Month_Name = 'Juli'
      break
    when = '08'
      let $HD_Month_Name = 'August'
      break
    when = '09'
      let $HD_Month_Name = 'September'
      break
    when = '10'
      let $HD_Month_Name = 'Oktober'
      break
    when = '11'
      let $HD_Month_Name = 'November'
      break
    when = '12'
      let $HD_Month_Name = 'Dezember'
      break
    when-other
      let $HD_Month_Name = 'XXXXXXX'
      break
  end-evaluate
  #DEBUG show 'Month Name = ' $HD_Month_Name
  #DEBUG show  '$HD_mm = ' $HD_mm
end-procedure





begin-procedure getHeaderDateString
!
!
  do ConvertToComponents($Ctl_Curr_Pay_End_DT,$HD_yy,$HD_mm,$HD_dd)

  evaluate $HD_mm
    when = '01'
      let $HD_Month_Name = 'Januar'
      break
    when = '02'
      let $HD_Month_Name = 'Februar'
      break
    when = '03'
      let $HD_Month_Name = 'März'
      break
    when = '04'
      let $HD_Month_Name = 'April'
      break
    when = '05'
      let $HD_Month_Name = 'Mai'
      break
    when = '06'
      let $HD_Month_Name = 'Juni'
      break
    when = '07'
      let $HD_Month_Name = 'Juli'
      break
    when = '08'
      let $HD_Month_Name = 'August'
      break
    when = '09'
      let $HD_Month_Name = 'September'
      break
    when = '10'
      let $HD_Month_Name = 'Oktober'
      break
    when = '11'
      let $HD_Month_Name = 'November'
      break
    when = '12'
      let $HD_Month_Name = 'Dezember'
      break
    when-other
      let $HD_Month_Name = 'XXXXXXX'
      break
  end-evaluate
  
  let $HeaderDateString = $HD_Month_Name || ' ' || $HD_yy
  
  #DEBUG show 'Month Name = ' $HD_Month_Name
  #DEBUG show  '$HD_mm = ' $HD_mm
end-procedure





!
! from SI10 Beitragsnachweis
! was: Get-Provider-Data
!
begin-procedure GetProviderData($curr_pay_end_dt, $si_provider,:$KK_Name,:$KK_Nummer,
                :$KK_Street,:$KK_ZipCity,:$Health_Rate_East,:$Health_Rate_West,
                :$Beitragskonto,:$Zahlstellen_nr,$Payentity)
   let $KK_Name          = ' '
   let $KK_Nummer        = ' '
   let $KK_Street        = ' '
   let $KK_ZipCity       = ' '
   let $Health_Rate_East = ' '
   let $Health_Rate_West = ' '
   let $Beitragskonto    = ' '
   let $Zahlstellen_nr   = ' '
begin-SELECT
PTD.DESCR
PTD.GPDE_SI_PROV_ID
PTD1.ADDRESS1
PTD1.POSTAL
PTD1.CITY
  let $KK_Name          = &PTD.DESCR
  let $KK_Nummer        = &PTD.GPDE_SI_PROV_ID
  let $KK_Street        = rtrim(&PTD1.ADDRESS1,' ')
  let $KK_ZipCity       = rtrim(&PTD1.POSTAL,' ') || ' ' || rtrim(&PTD1.CITY,' ')
  do GetBeitragsKonto($si_Provider, $curr_pay_end_dt, $Payentity,
                $Beitragskonto, $Zahlstellen_nr)
  let $_si_provider_id = rtrim($KK_Nummer,' ')
FROM PS_GPDE_SI_PROV PTD,PS_GPDE_SI_PRV_ADR PTD1
WHERE PTD.GPDE_SI_PROV = $si_provider
AND   PTD1.GPDE_SI_PROV = PTD.GPDE_SI_PROV
AND   PTD.EFFDT = (SELECT MAX(EFFDT)
                   FROM PS_GPDE_SI_PROV PTD1
                   WHERE PTD1.GPDE_SI_PROV = PTD.GPDE_SI_PROV
                   AND PTD1.EFFDT <= $curr_pay_end_dt)
AND   PTD1.EFFDT = (SELECT MAX(EFFDT)
                   FROM PS_GPDE_SI_PRV_ADR PTD2
                   WHERE PTD2.GPDE_SI_PROV = PTD1.GPDE_SI_PROV
                   AND PTD2.EFFDT <= $curr_pay_end_dt)
end-SELECT
end-procedure



!
! from SI10 Beitragsnachweis
! was: Get-SI_PRV_ACCT_DEU
!
begin-procedure GetBeitragsKonto($SI_Provider, $Ctl_Curr_Pay_End_Dt, $Ctl_Payentity,
                :$Beitragskonto, :$Zahlstellen_nr)
let $Beitragskonto  = ' '
let $Zahlstellen_nr = ' '
begin-SELECT
PTV.GPDE_SI_CUST_ACTV
PTV.GPDE_SI_CUST_PENS
  let $Beitragskonto = &PTV.GPDE_SI_CUST_ACTV
  let $Zahlstellen_nr = &PTV.GPDE_SI_CUST_PENS
FROM PS_GPDE_AL_PE_SID PTV
WHERE PTV.GPDE_SI_PROV = $SI_Provider
AND   PTV.PAY_ENTITY = $Ctl_Payentity
AND   PTV.EFFDT = (SELECT MAX(EFFDT)
                   FROM PS_GPDE_AL_PE_SID PTV1
                   WHERE PTV1.GPDE_SI_PROV = PTV.GPDE_SI_PROV
                   AND PTV1.EFFDT <= $Ctl_Curr_Pay_End_Dt
                   AND PTV1.PAY_ENTITY = PTV.PAY_ENTITY)
end-SELECT
end-procedure


!*************************************************************************
#include 'number.sqc'    !routines to format numbers
!#include 'gpdetx03.sqc'  !get run control parameter values
#include 'gpdeut01.sqc'  !sqr strings table procedures
#include 'gpdeut03.sqc'  !get ask report parameters
#include 'gpdeut02.sqc'  !get ask report parameters
#include 'gpdeut04.sqc'  !get pay entity data
!#include 'gpdeut05.sqc'  !get employee address
#include 'gpdeut06.sqc'  !get run control parameter values
#include 'gpdeut07.sqc'  !get run control parameter values
#include 'curdttim.sqc'  !get-current-datetime procedure
#include 'datemath.sqc'  !function for date-calculation
#include 'validdt.sqc'   !validate date routine
#include 'readxlat.sqc'  !read-translate-table procedure
#include 'datetime.sqc'  !routines for date and time formatting
#include 'stdapi.sqc'    !routines to update run status
#include 'sqrtrans.sqc'  !sqr strings table procedures
!#include 'timemath.sqc'

