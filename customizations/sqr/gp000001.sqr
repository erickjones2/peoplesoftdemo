!**********************************************************************!
! gp000001:  GP Payroll Results Register                               !
!**********************************************************************!
!                                                                      !
!                                                                      !
!                                                                      !
!                                                                      !
! This software and related documentation are provided under a         !
! license agreement containing restrictions on use and                 !
! disclosure and are protected by intellectual property                !
! laws. Except as expressly permitted in your license agreement        !
! or allowed by law, you may not use, copy, reproduce,                 !
! translate, broadcast, modify, license, transmit, distribute,         !
! exhibit, perform, publish or display any part, in any form or        !
! by any means. Reverse engineering, disassembly, or                   !
! decompilation of this software, unless required by law for           !
! interoperability, is prohibited.                                     !
! The information contained herein is subject to change without        !
! notice and is not warranted to be error-free. If you find any        !
! errors, please report them to us in writing.                         !
!                                                                      !
!                                                                      !
! Copyright (C) 1988, 2016, Oracle and/or its affiliates.              !
! All Rights Reserved.                                                 !
!**********************************************************************!
!                                                                      !
!       $Release:  HR92                                                !
!           $Bug:  24571070                                            !
!                                                                      !
!**********************************************************************!

!***********************************************************************
!   This report prints the payroll results that have been extracted    *
!   from the Payroll Results tables via Report Data.                   *
!                                                                      *
!***********************************************************************
!                                                                      *
!   NOTE - Throughout this report, debugw, debugy, and debugz flags    *
!          are used. debugw tracks the report execution/flow, debugy   *
!          tracks variable values, and debugz prevents the guide and   *
!          and detail tables from Report Data being deleted.           *
!          For information on how to use these flags for debugging,    *
!          refer to SQR documentation.                                 *
!                                                                      *
!***********************************************************************
!                                                                      *
!          In Addition, if you encounter a function, procedure call    *
!          or bit of code you cannot decipher, go to the top of the    *
!          report and search for the string.  It is likely explained   *
!          via comments earlier in the report on the first occurrence. *
!                                                                      *
!***********************************************************************

#include 'setenv.sqc'   !Set environment
#include 'setup32.sqc'  !page layout and Printer definition
#include 'number.sqc'   !Routines to format numbers
#include 'datetime.sqc' !Routines for date and time formatting
#include 'prcsapi.sqc'  !Replaces stdapi.sqc

begin-report

#ifdef debugw
        Show 'do Init-Processing'
#end-if
         do Init-Processing

#ifdef debugw
        Show 'do Select-Parameters'
#end-if
        do Select-Parameters

#ifdef debugw
        Show 'do Process-Main'
#end-if
        do Process-Main

#ifdef debugw
        Show 'do Reset'
#end-if
        do Reset                        ! called from reset1.sqc

#ifdef debugw
        Show 'do Update-Prcs-Run-Status'
#end-if
        do Update-Prcs-Run-Status

#ifdef debugw
        Show 'do Delete-Tmp-Tbl'
#end-if
        do Delete-Tmp-Tbl

  show ' '
  let $DateEnd = datenow()
  show $RptEnd_lbl noline
  show ' ' $DateEnd

end-report


!***********************************************************************
! Init-Processing                                                      *
!                                                                      *
! Called By:    begin-report                                           *
!                                                                      *
! Calls:        Init-Datetime           - datetime.sqc                 *
!               Get-Current-Datetime    - prcsapi.sqc (curdttim.sqc)   *
!               Define-Prcs-Vars        - prcsapi.sqc (prcsdef.sqc)    *
!               Get-Run-Control-Parms   - prcsapi.sqc                  *
!               Init-report                                            *
!               Init-Number             - number.sqc                   *
!               Get-Language-Codes      - prcslng.sqc                  *
!                                                                      *
! Description:  Standard PeopleSoft initialization processing.         *
!***********************************************************************

begin-procedure Init-Processing

#ifdef debugw
        Show 'do Init-Datetime'
#end-if
        do Init-Datetime

#ifdef debugw
        Show 'do Get-Current-Datetime'
#end-if
        do Get-Current-Datetime

#ifdef debugw
        Show 'do Define-Prcs-Vars'
#end-if
        do Define-Prcs-Vars

#ifdef debugw
        Show 'do Get-Run-Control-Parms'
#end-if
        do Get-Run-Control-Parms

#ifdef debugw
        Show 'do Init-report'
#end-if
        do Init-report

#ifdef debugw
        Show 'do Init-Number'
#end-if
        do Init-Number

#ifdef debugw
        Show 'do Get-Language-Codes'
#end-if
        do Get-Language-Codes

end-procedure ! Init-Processing


!***********************************************************************
! Init-report                                                          *
!                                                                      *
! Called By:    Init-Processing                                        *
!                                                                      *
! Calls:        Init_Report_Translation    - sqrtrans.sqc              *
!               Append_Report_Translation  - sqrtrans.sqc              *
!               Get_Field_Information                                  *
!                                                                      *
! Description:  Initializes variables, defines values for variables    *
!               used in report header & throughout report.  Performs   *
!               Strings Table translation.  #Defines variables for     *
!               use throughout report in Printing columns.             *
!***********************************************************************

begin-procedure Init-report

#ifdef debugw
    Show 'Inside procedure Init-report'
#end-if

!***********************************************************************
!                                                                      *
! print column definitions.  Some fields are lined up vertically with  *
! other fields on the report.  The first occurence of a column         *
! location is defined.  After that, fields that occur in the same      *
! column use the first field's column definition.  Field labels end    *
! in _lbl.  Other column definitions are for the field values.         *
!                                                                      *
!***********************************************************************

    #define Col_ED_Instance         21
    #define Col_ED_Slice_Dates      26
    #define Col_ED_Field135         37
    #define Col_ED_Field246         58
    #define Col_ED_Amt_lbl          81
    #define Col_ED_Base_lbl         104
    #define Col_ED_Rate_lbl         130
    #define Col_ED_Unit_lbl         151
    #define Col_ED_Source_lbl       171
    #define Col_ED_Amt              79
    #define Col_ED_Base             102
    #define Col_ED_Rate             125
    #define Col_ED_Unit             148
    #define Col_ED_Source           171
    #define Col_ED_Amt_Total         75
    #define Col_ED_Unit_Total       144

    #define Col_ACM_From_To         21
    #define Col_ACM_Value_lbl       40
    #define Col_ACM_Value           32
    #define Col_ACM_Key1            55
    #define Col_ACM_Key2            81
    #define Col_ACM_Slice_Dates     107
    #define Col_ACM_Adjust_lbl      126
    #define Col_ACM_Adjust          119
    #define Col_ACM_Period_lbl      151
    #define Col_ACM_Period          142

    #define Col_ARR_Instance        21
    #define Col_ARR_Slice_Dates     26
    #define Col_ARR_Amt_Adj_lbl     39
    #define Col_ARR_Amt_Adj         38
    #define Col_ARR_Not_Taken_lbl   62
    #define Col_ARR_Not_Taken       61
    #define Col_ARR_Payback_lbl     87
    #define Col_ARR_Payback         84
    #define Col_ARR_Arrears_lbl     108
    #define Col_ARR_Arrears         106
    #define Col_ARR_Balance_lbl     131
    #define Col_ARR_Balance         130

    #define Col_SUM_Amt_lbl        34
    #define Col_SUM_Amt            25
    #define Col_SUM_Adj_lbl        59
    #define Col_SUM_Amt_Adj        54
    #define Col_SUM_Unit_lbl       97
    #define Col_SUM_Unit           85
    #define Col_SUM_Unit_Adj_lbl   120
    #define Col_SUM_Unit_Adj       115

!***********************************************************************
!                                                                      *
! Translations procedures & Strings Table retrievals.                  *
!                                                                      *
!***********************************************************************

! Get_Field_Information procedure Called from sqrtrans.sqc
! Gets The Strings from PS_STRINGS_TBL

    let $ReportID = 'GP000001'

    do Init_Report_Translation ($ReportID, $curr_language_cd)

    do Append_Report_Translation ('GP000001')
    do Get_Field_Information ('GP000001', 'STDHDG_CO_NM',   $stdhdg_co_nm,       #DW)
    do Get_Field_Information ('GP000001', 'STDHDG_REP_ID',  $stdhdg_rep_id,      #DW)
    do Get_Field_Information ('GP000001', 'STDHDG_PAGE_NO', $stdhdg_page_no,     #DW)
    do Get_Field_Information ('GP000001', 'STDHDG_RUN_DT',  $stdhdg_run_dt,      #DW)
    do Get_Field_Information ('GP000001', 'STDHDG_RUN_TM',  $stdhdg_run_tm,      #DW)
    do Get_Field_Information ('GP000001', 'STDHDG_END_RPT', $stdhdg_end_rep,     #DW)
    do Get_Field_Information ('GP000001', 'NO_DATA_MSG',    $NoDataMsg,          #DW)
    do Get_Field_Information ('GP000001', 'NO_DATA_SEG_MSG',$NoSegMsg,           #DW)
    do Get_Field_Information ('GP000001', 'LANG',           $Lang_lbl,           #DW)

    do Get_Field_Information ('GP000001', 'RPT_START',      $RptStart_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'RPT_END',        $RptEnd_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'SUBMIT_BY',      $SubmitBy_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'RUN_BY',         $RunBy_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'RUN_CNTRL',      $RunCntrl_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'RPT_TYPE',       $RptType_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'PRD_TYPE',       $PrdType_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'DATE_FROM',      $FromDt_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'DATE_TO',        $ToDt_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'YEAR',           $Year_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'QTR',            $Qtr_lbl,            #DW)
    do Get_Field_Information ('GP000001', 'ELEM_LIST',      $ElemList_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'LIST_SET',       $ListSet_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'COUNTRY',        $Country_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'SORT',           $Sort_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'SORT_MSG',       $SortMsg,            #DW)
    do Get_Field_Information ('GP000001', 'PAYEE_SORT',     $PayeeSort_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'POP_METHOD',     $PopMethod_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'GP_GROUP',       $GPGroup_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'HR_GROUP',       $HRGroup_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'GRP_DT',         $GrpAsof_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'REFINE_DT',      $RefineDt_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'REBUILD_GRP',    $Rebuild_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'PAYEES',         $Payees_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'ORG_LBL1',       $Org_lbl1,           #DW)
    do Get_Field_Information ('GP000001', 'ORG_LBL2',       $Org_lbl2,           #DW)
    do Get_Field_Information ('GP000001', 'BUS_LBL1',       $Bus_lbl1,           #DW)
    do Get_Field_Information ('GP000001', 'BUS_LBL2',       $Bus_lbl2,           #DW)
    do Get_Field_Information ('GP000001', 'VALUE',          $Value_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'RPT_DATA',       $RptData_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'RPT_CNTRY',      $Country_lbl2,       #DW)
    do Get_Field_Information ('GP000001', 'CALGRP_LBL',     $CalGrp2_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'PAYENT_LBL',     $PayEnt2_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'PAYGRP_LBL',     $PayGrp2_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'COMP_LBL',       $Comp2_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'DEPT_LBL',       $Dept2_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'LOCN_LBL',       $Locn2_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'ESTAB_LBL',      $Estab2_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'RUN_TYPE_LBL',   $RunType2_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'CURR_LBL',       $Curr2_lbl,          #DW)

    do Get_Field_Information ('GP000001', 'RPT_TITLE1',     $Dflt_RptTitle1,     #DW)
    do Get_Field_Information ('GP000001', 'EEDTL_TITLE',    $EEDTL_Title,        #DW)
    do Get_Field_Information ('GP000001', 'EESUM_TITLE',    $EESUM_Title,        #DW)
    do Get_Field_Information ('GP000001', 'ORGSUM_TITLE',   $ORGSUM_Title,       #DW)
    do Get_Field_Information ('GP000001', 'ERN_TITLE',      $Dflt_ErnTitle,      #DW)
    do Get_Field_Information ('GP000001', 'DED_TITLE',      $Dflt_DedTitle,      #DW)
    do Get_Field_Information ('GP000001', 'ACM_TITLE',      $Dflt_AcmTitle,      #DW)
    do Get_Field_Information ('GP000001', 'ARR_TITLE',      $Dflt_ArrTitle,      #DW)

    do Get_Field_Information ('GP000001', 'PAY_ENT',        $PayEnt_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'PAY_GRP',        $PayGrp_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'COMP',           $Comp_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'DEPT',           $Dept_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'LOCN',           $Locn_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'ESTAB',          $Estab_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'CNTRCT',         $Contract_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'CAL_ID',         $Cal_ID_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'CAL_RUN_ID',     $CalGrp_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'CALC_STATUS',    $Calc_Stat_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'PR_STAT_FINAL',  $Calc_Stat_Final,    #DW)
    do Get_Field_Information ('GP000001', 'PR_STAT_OPEN',   $Calc_Stat_Open,     #DW)
    do Get_Field_Information ('GP000001', 'CURRENCY',       $Curr_lbl,           #DW)

    do Get_Field_Information ('GP000001', 'EMPLID',         $Emplid_lbl,         #DW)
    do Get_Field_Information ('GP000001', 'REC_NUM',        $Rec_Num_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'EMP_NM',         $Emp_Nm_lbl,         #DW)

    do Get_Field_Information ('GP000001', 'CAL_PRD_ID',     $Cal_Prd_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'RUN_TYPE',       $Run_Type_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'PAY_PRD_BEG_DT', $Pay_Prd_Beg_Dt_lbl, #DW)
    do Get_Field_Information ('GP000001', 'PAY_PRD_END_DT', $Pay_Prd_End_Dt_lbl, #DW)
    do Get_Field_Information ('GP000001', 'PYMT_DT',        $Pymt_Dt_lbl,        #DW)

    do Get_Field_Information ('GP000001', 'SEG_NUM',        $Seg_Num_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'VER_NUM',        $Ver_Num_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'REV_NUM',        $Rev_Num_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'SEG_STAT',       $Seg_Stat_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'SEG_BEG_DT',     $Seg_Beg_Dt_lbl,     #DW)
    do Get_Field_Information ('GP000001', 'SEG_END_DT',     $Seg_End_Dt_lbl,     #DW)
    do Get_Field_Information ('GP000001', 'PYMT_KEYS',      $Pymt_Keys_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'GROSS_PAY',      $Gross_Pay_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'NET_PAY',        $Net_Pay_lbl,        #DW)

    do Get_Field_Information ('GP000001', 'ELEM_NM',        $Elem_Nm_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'INSTANCE',       $Instance_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'SLICE_DT',       $Slice_Dt_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'AMT/ADJ',        $Amt_Adj_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'BASE/ADJ',       $Base_Adj_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'RATE',           $Rate_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'UNIT/ADJ',       $Unit_Adj_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'AMOUNT_LBL',     $Sum_Amt_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'AMOUNT_ADJ_LBL', $Sum_Adj_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'UNITS_LBL',      $Sum_Unit_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'UNITS_ADJ_LBL',  $Sum_Unit_Adj_lbl,   #DW)
    do Get_Field_Information ('GP000001', 'PERC',           $Perc_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'AMT_NOT_TAKEN',  $Amt_Not_Taken_lbl,  #DW)
    do Get_Field_Information ('GP000001', 'PAYBK_AMT',      $Paybk_Amt_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'AMT_TO_ARREARS', $Amt_To_Arrears_lbl, #DW)
    do Get_Field_Information ('GP000001', 'FROM_TO',        $From_To_lbl,        #DW)
    do Get_Field_Information ('GP000001', 'KEY135',         $Key1_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'KEY246',         $Key2_lbl,           #DW)
    do Get_Field_Information ('GP000001', 'FIELD135',       $Field135_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'FIELD246',       $Field246_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'VALUE',          $Value_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'ADJ',            $Adj_lbl,            #DW)
    do Get_Field_Information ('GP000001', 'PRD',            $Prd_lbl,            #DW)
    do Get_Field_Information ('GP000001', 'SRC',            $Src_lbl,            #DW)
    do Get_Field_Information ('GP000001', 'DED_ARREARS',    $Ded_Arrears_lbl,    #DW)
    do Get_Field_Information ('GP000001', 'ARREARS_BAL',    $Arr_Bal_lbl,        #DW)

    do Get_Field_Information ('GP000001', 'TOT',            $Total_lbl,          #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_CALGRP', $Tot_CalGrp_lbl,     #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_PAYENT', $Tot_PayEnt_lbl,     #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_PAYGRP', $Tot_PayGrp_lbl,     #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_COMP',   $Tot_Comp_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_DEPT',   $Tot_Dept_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_LOCN',   $Tot_Locn_lbl,       #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_ESTAB',  $Tot_Estab_lbl,      #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_RUNTYPE',$Tot_RunType_lbl,    #DW)
    do Get_Field_Information ('GP000001', 'TOT_FOR_CURR',   $Tot_Curr_lbl,       #DW)

!***********************************************************************
! Report variables.                                                    *
!***********************************************************************

    let $ReportID              = 'GP000001'          ! Printed in header

    let $End_Report            = 'N'
    let $Report_Language       = $curr_language_cd   ! curr_language_cd resolved in prcslng.sqc
    let #Maxlines              = 55                  ! # rows on a page, used for page Breaking
    let $First_Section         = 'Y'                 ! Used for page Breaking
    let #MaxHeadLines          = 15 + #Max_Sort
    let $Seg_FirstTimeThru     = 'Y'                 ! Used for page Breaking
    let $Current_Emplid        = $Last_Emplid        ! Used for page Breaking
    let #Current_Seg_Num       = #Last_Seg_Num       ! Used for page Breaking
    let $Page_Break_Indicator  = 'Reset'             ! Used for page Breaking
    let $Rpt_Hdr_FirstTimeThru = 'True'              ! Used for page Breaking
    let $flag                  = 'N'
    let $SQLQuote = ''''
    let $ERNWhere = '(DTLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '10' || $SQLQuote
    let $ERNWhere = $ERNWhere || ' OR (DTLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $ERNWhere = $ERNWhere || ' AND DTLED.PIN_TYPE = ' || $SQLQuote || 'ER' || $SQLQuote || '))'
    let $DEDWhere = '(DTLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '20' || $SQLQuote
    let $DEDWhere = $DEDWhere || ' OR (DTLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $DEDWhere = $DEDWhere || ' AND DTLED.PIN_TYPE = ' || $SQLQuote || 'DD' || $SQLQuote || '))'

    let $ERNWhere2 = '(STLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '10' || $SQLQuote
    let $ERNWhere2 = $ERNWhere2 || ' OR (STLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $ERNWhere2 = $ERNWhere2 || ' AND STLED.PIN_TYPE = ' || $SQLQuote || 'ER' || $SQLQuote || '))'
    let $DEDWhere2 = '(STLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '20' || $SQLQuote
    let $DEDWhere2 = $DEDWhere2 || ' OR (STLED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $DEDWhere2 = $DEDWhere2 || ' AND STLED.PIN_TYPE = ' || $SQLQuote || 'DD' || $SQLQuote || '))'

    let $ERNWhere3 = '(SMED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '10' || $SQLQuote
    let $ERNWhere3 = $ERNWhere3 || ' OR (SMED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $ERNWhere3 = $ERNWhere3 || ' AND SMED.PIN_TYPE = ' || $SQLQuote || 'ER' || $SQLQuote || '))'
    let $DEDWhere3 = '(SMED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '20' || $SQLQuote
    let $DEDWhere3 = $DEDWhere3 || ' OR (SMED.GP_RGST_SECT_TYPE = ' || $SQLQuote || '50' || $SQLQuote
    let $DEDWhere3 = $DEDWhere3 || ' AND SMED.PIN_TYPE = ' || $SQLQuote || 'DD' || $SQLQuote || '))'

    let $Pymt_Keys_lbl = rtrim($Pymt_Keys_lbl,' ')
    let $Pymt_Keys_lbl = substr($Pymt_Keys_lbl,1,22)
    let #pmtlen = length($Pymt_keys_lbl)
    let #Col_Pymt_Key_Lbl = 85 + ((22 - #pmtlen) / 2)
    #ifdef debugy
      show '$Pymt_Keys_lbl= ' $Pymt_Keys_lbl
      show '#pmtlen= ' #pmtlen
      show '#Col_Pymt_Key_Lbl= ' #Col_Pymt_Key_Lbl
    #end-if

!***********************************************************************
!                                                                      *
! Dates:   All of Europe uses date format DD/MM/YYYY                   *
!          The US uses date format of MM/DD/YYYY                       *
!                                                                      *
! Numbers: The U.S. and the U.K. use NN,NNN.NN                         *
!          The rest of Europe uses NN.NNN,NN                           *
!                                                                      *
!***********************************************************************

#ifdef debugy
   show '$curr_language_cd' $curr_language_cd
#end-if

!    if $curr_language_cd      = 'ENG'
!        let $ReportDateType   = '0'             ! resolved in datetime.sqc
!    else
!        let $ReportDateType   = '1'
!    end-if

!***********************************************************************
!                                                                      *
! Initialize date formatting.                                          *
!                                                                      *
!***********************************************************************

    let $Date_Init = '1900-01-01 00:00:00.000'

    #ifdef ORACLE
         let $Date_Init = '01-NOV-00'
    #end-if

    let $ReportDate            = datenow()      ! Printed in header

    do Format-DateTime($ReportDate, $out1, {DEFDATE}, '', '')
    let $ReportDate = $out1
#ifdef debugy
   show '$curr_language_cd' $curr_language_cd
   show '$ReportDate' $ReportDate
#end-if

end-procedure ! Init-report


!***************************
begin-heading 17
!***************************
#ifdef debugw
    Show 'begin-HEADING'
#end-if

if #rows_selected > 0
   #include 'gprgsth1.sqc'
end-if

end-heading


!***********************************************************************
! Get-PR-Status                                                        *
!                                                                      *
! Called By:    begin-report                                           *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieves calc status to print in report header.       *
!***********************************************************************

begin-procedure Get-PR-Status

#ifdef debugw
        Show 'Inside procedure Get-PR-Status'
#end-if

begin-Select

#ifdef debugw
        Show 'Inside SELECT, procedure Get-PR-Status'
#end-if

CALRUN.RUN_FINALIZED_IND    &CALRUN.RUN_FINALIZED_IND

    let $Finalized_Ind      = &CALRUN.RUN_FINALIZED_IND

    if $Finalized_Ind  = 'Y'
        let $Calc_Stat = $Calc_Stat_Final
    else
        let $Calc_Stat = $Calc_Stat_Open
    end-if

FROM PS_GP_CAL_RUN CALRUN
WHERE CALRUN.CAL_RUN_ID = $Cal_Run_ID
end-Select

#ifdef debugy
   show '$Calc_Stat ' $Calc_Stat
#end-if

end-procedure ! Get-PR-Status


!***********************************************************************
! Get-Header-Descriptions                                              *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Calls:        Get-PayEntity-Rel-Lang                                 *
!               Get-PayGroup-Rel-Lang                                  *
!               Get-Company-Rel-Lang                                   *
!               Get-Dept-Rel-Lang                                      *
!               Get-Estab-Rel-Lang                                     *
!               Get-Locn-Rel-Lang                                      *
!               Get-RunType-Rel-Lang                                   *
!               Get-CalPrd-Rel-Lang                                    *
!               Get-Currency-Rel-Lang                                  *
!                                                                      *
! Description:  Retrieves descriptions for information to print in     *
!               the report header.  if report language is different    *
!               from the installation base language, calls program to  *
!               retrieve the description translation from the          *
!               appropriate related language table.                    *
!***********************************************************************

begin-procedure Get-Header-Descriptions

#ifdef debugw
    Show 'Inside procedure Get-Header-Descriptions'
#end-if

!***********************************************************************
! Retrieve Calendar Group description.  Trim to fit report.  No related*
! language table exists for calendar group                             *
!***********************************************************************

 if $Last_CalGrp <> $Cal_Run_Id
    do Get-CalGroup-Base-Lang
    do Get-PR-Status
 end-if

!***********************************************************************
! Retrieve Pay Entity description.  Trim to fit report.  Retrieve      *
! related language entry if necessary.                                 *
!***********************************************************************

 if $Last_PayEnt <> $Pay_Entity
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-Payentity-Rel-Lang
       if $PayEnt_Descr = ''
          do Get-Payentity-Base-Lang
       end-if
    else
       do Get-Payentity-Base-Lang
    end-if
 end-if

!**********************************************************************!
! Retrieve Paygroup description.  Retrieve related language entry if   !
! necessary.                                                           !
!**********************************************************************!

 if $curr_language_cd <> $Psoptions_Language_Cd
    do Get-Paygroup-Rel-Lang
    if $PayGrp_Descr = ''
       do Get-Paygroup-Base-Lang
    end-if
 else
    do Get-Paygroup-Base-Lang
 end-if


!***********************************************************************
! Retrieve Company description.  Retrieve related language entry if    *
! necessary.                                                           *
!***********************************************************************

 if $Last_Comp <> $Company
       and #Comp_Sort <> 0
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-Company-Rel-Lang
       if $Comp_Descr = ''
          do Get-Company-Base-Lang
       end-if
    else
       do Get-Company-Base-Lang
    end-if
 end-if

!***********************************************************************
! Retrieve Department description.  Retrieve related language entry if *
! necessary.                                                           *
!***********************************************************************

 if $Last_Dept <> $Department
       and #Dept_Sort <> 0
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-Dept-Rel-Lang
       if $Dept_Descr = ''
          do Get-Dept-Base-Lang
       end-if
    else
       do Get-Dept-Base-Lang
    end-if
 end-if

!***********************************************************************
! Retrieve Location description.  Retrieve related language entry if   *
! necessary.                                                           *
!***********************************************************************

 if $Last_Locn <> $Location
       and #Locn_Sort <> 0
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-Locn-Rel-Lang
       if $Locn_Descr = ''
          do Get-Locn-Base-Lang
       end-if
    else
          do Get-Locn-Base-Lang
    end-if
 end-if

 !***********************************************************************
 ! Retrieve Establishment description.  Retrieve related language entry *
 ! if necessary.                                                        *
 !***********************************************************************

  if $Last_Estab <> $Establishment
        and #Estab_Sort <> 0
     if $curr_language_cd <> $Psoptions_Language_Cd
        do Get-Estab-Rel-Lang
        if $Dept_Descr = ''
           do Get-Estab-Base-Lang
        end-if
     else
        do Get-Estab-Base-Lang
     end-if
  end-if

!***********************************************************************
! Retrieve Calendar Period ID description.  Trim to fit report.        *
! Retrieve related language entry if necessary.                        *
!***********************************************************************

 if $Last_CalPrd <> $Cal_Prd_ID
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-CalPrd-Rel-Lang
       if $CalPrd_Descr = ''
          do Get-CalPrd-Base-Lang
       end-if
    else
       do Get-CalPrd-Base-Lang
    end-if
end-if

!***********************************************************************
! Retrieve Run Type description.  Trim to fit report.                  *
! Retrieve related language entry if necessary.                        *
!***********************************************************************

 if $Last_RunType <> $Run_Type
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-RunType-Rel-Lang
       if $RunType_Descr = ''
          do Get-RunType-Base-Lang
       end-if
    else
       do Get-RunType-Base-Lang
    end-if
 end-if

 !***********************************************************************
 ! Retrieve Currency Code description.  Trim to fit report.             *
 ! Retrieve related language entry if necessary.                        *
 !***********************************************************************

 if $Last_Currency_Value <> $Currency_Value
    if $curr_language_cd <> $Psoptions_Language_Cd
       do Get-Currency-Rel-Lang
       if $Currency_Descr = ''
          do Get-Currency-Base-Lang
       end-if
    else
       do Get-Currency-Base-Lang
    end-if

 end-if

end-procedure ! Get-Header-Descriptions

!***********************************************************************
! Get-CalGroup-Base-Lang                                               *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve Calendar Group base language entry.           *
!***********************************************************************

begin-procedure Get-CalGroup-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-CalGroup-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-CalGroup-Base-Lang'
#end-if

CALGRP.DESCR     &CALGRP.DESCR

    let $CalGrp_Descr = &CALGRP.DESCR

FROM PS_GP_CAL_RUN CALGRP
WHERE CALGRP.CAL_RUN_ID = $Cal_Run_ID

end-Select

end-procedure ! Get-CalGroup-Base-Lang


!***********************************************************************
! Get-Payentity-Base-Lang                                              *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve payentity base language entry.                *
!***********************************************************************

begin-procedure Get-Payentity-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Payentity-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Payentity-Base-Lang'
#end-if

PYENT.DESCR     &PYENT.DESCR

    let $PayEnt_Descr = &PYENT.DESCR

FROM PS_GP_PYENT PYENT
WHERE PYENT.PAY_ENTITY = $Pay_Entity

end-Select

end-procedure ! Get-Payentity-Base-Lang


!***********************************************************************
! Get-Payentity-Rel-Lang                                               *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve payentity related language entry.             *
!***********************************************************************

begin-procedure Get-Payentity-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Payentity-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Payentity-Rel-Lang'
#end-if

PYENTYLANG.DESCR     &PYENTYLANG.DESCR

    let $PayEnt_Descr = &PYENTYLANG.DESCR

FROM PS_GP_PYENT_LANG PYENTYLANG
WHERE PYENTYLANG.PAY_ENTITY = $Pay_Entity
  AND PYENTYLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Payentity-Rel-Lang


!***********************************************************************
! Get-Paygroup-Base-Lang                                               *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve paygroup base language entry.                 *
!***********************************************************************

begin-procedure Get-Paygroup-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Paygroup-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Paygroup-Base-Lang'
#end-if

PYGRP.DESCR     &PYGRP.DESCR

    let $PayGrp_Descr = &PYGRP.DESCR

FROM PS_GP_PYGRP PYGRP
WHERE PYGRP.GP_PAYGROUP = $Paygroup

end-Select

end-procedure ! Get-Paygroup-Base-Lang


!***********************************************************************
! Get-Paygroup-Rel-Lang                                                *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve paygroup related language entry.              *
!***********************************************************************

begin-procedure Get-Paygroup-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Paygroup-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Paygroup-Rel-Lang'
#end-if


PYGRPLANG.DESCR     &PYGRPLANG.DESCR

    let $PayGrp_Descr = &PYGRPLANG.DESCR

FROM PS_GP_PYGRP_LANG PYGRPLANG
WHERE PYGRPLANG.GP_PAYGROUP = $Paygroup
  AND PYGRPLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Paygroup-Rel-Lang


!***********************************************************************
! Get-Company-Base-Lang                                                *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve company base language entry.                  *
!***********************************************************************

begin-procedure Get-Company-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Company-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Company-Base-Lang'
#end-if

COMP.DESCR     &COMP.DESCR

    let $Comp_Descr = &COMP.DESCR

FROM PS_COMPANY_TBL COMP
WHERE COMP.COMPANY = $Company

end-Select

end-procedure ! Get-Company-Base-Lang

!***********************************************************************
! Get-Company-Rel-Lang                                                 *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve company related language entry.               *
!***********************************************************************

begin-procedure Get-Company-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Company-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Company-Rel-Lang'
#end-if

COMPLANG.DESCR     &COMPLANG.DESCR

    let $Comp_Descr = &COMPLANG.DESCR

FROM PS_COMPNY_TBL_LANG COMPLANG
WHERE COMPLANG.COMPANY = $Company
  AND COMPLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Company-Rel-Lang


!***********************************************************************
! Get-Dept-Base-Lang                                                   *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve department base language entry.               *
!***********************************************************************

begin-procedure Get-Dept-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Dept-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Dept-Base-Lang'
#end-if

DEPT.DESCR     &DEPT.DESCR


    let $Dept_Descr = &DEPT.DESCR

FROM PS_DEPT_TBL DEPT
WHERE DEPT.DEPTID = $Department

end-Select

end-procedure ! Get-Dept-Base-Lang

!***********************************************************************
! Get-Dept-Rel-Lang                                                    *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve department related language entry.            *
!***********************************************************************

begin-procedure Get-Dept-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Dept-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Dept-Rel-Lang'
#end-if

DEPTLANG.DESCR     &DEPTLANG.DESCR

    let $Dept_Descr = &DEPTLANG.DESCR

FROM PS_DEPT_TBL_LANG DEPTLANG
WHERE DEPTLANG.DEPTID = $Department
  AND DEPTLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Dept-Rel-Lang

!***********************************************************************
! Get-Locn-Base-Lang                                                   *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve location base language entry.                 *
!***********************************************************************

begin-procedure Get-Locn-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Locn-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Locn-Base-Lang'
#end-if

LOCN.DESCR     &LOCN.DESCR

    let $Locn_Descr = &LOCN.DESCR

FROM PS_LOCATION_TBL LOCN
WHERE LOCN.LOCATION = $Location

end-Select

end-procedure ! Get-Locn-Base-Lang

!***********************************************************************
! Get-Locn-Rel-Lang                                                    *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve location related language entry.              *
!***********************************************************************

begin-procedure Get-Locn-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Locn-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Locn-Rel-Lang'
#end-if

LOCNLANG.DESCR     &LOCNLANG.DESCR

    let $Locn_Descr = &LOCNLANG.DESCR

FROM PS_LOCATION_LANG LOCNLANG
WHERE LOCNLANG.LOCATION = $Location
  AND LOCNLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Locn-Rel-Lang


!***********************************************************************
! Get-Estab-Base-Lang                                                  *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve department base language entry.               *
!***********************************************************************

begin-procedure Get-Estab-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Estab-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Estab-Base-Lang'
#end-if

ESTAB.DESCR     &ESTAB.DESCR

    let $Estab_Descr = &ESTAB.DESCR

FROM PS_ESTAB_TBL ESTAB
WHERE ESTAB.ESTABID = $Establishment

end-Select

end-procedure ! Get-Estab-Base-Lang

!***********************************************************************
! Get-Estab-Rel-Lang                                                   *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve department related language entry.            *
!***********************************************************************

begin-procedure Get-Estab-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-Estab-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Estab-Rel-Lang'
#end-if

ESTABLANG.DESCR     &ESTABLANG.DESCR

    let $Estab_Descr = &ESTABLANG.DESCR

FROM PS_ESTAB_TBL_LANG ESTABLANG
WHERE ESTABLANG.ESTABID = $Establishment
  AND ESTABLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-Estab-Rel-Lang

!***********************************************************************
! Get-RunType-Base-Lang                                                *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve run type base language entry.                 *
!***********************************************************************

begin-procedure Get-RunType-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-RunType-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-RunType-Base-Lang'
#end-if

RUNTYPE.DESCR     &RUNTYPE.DESCR

    let $RunType_Descr = &RUNTYPE.DESCR

FROM PS_GP_RUN_TYPE RUNTYPE
WHERE RUN_TYPE = $Run_Type

end-Select

end-procedure ! Get-RunType-Base-Lang


!***********************************************************************
! Get-RunType-Rel-Lang                                                 *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve run type related language entry.              *
!***********************************************************************

begin-procedure Get-RunType-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-RunType-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-RunType-Rel-Lang'
#end-if

RUNTYPLANG.DESCR     &RUNTYPLANG.DESCR

    let $RunType_Descr = &RUNTYPLANG.DESCR

FROM PS_GP_RUN_TYP_LANG RUNTYPLANG
WHERE RUNTYPLANG.RUN_TYPE    = $Run_Type
  AND RUNTYPLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-RunType-Rel-Lang


!***********************************************************************
! Get-CalPrd-Base-Lang                                                 *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve calendar period base language entry.  Trim    *
!               to fit report.                                         *
!***********************************************************************

begin-procedure Get-CalPrd-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-CalPrd-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-CalPrd-Base-Lang'
#end-if

CALPRD.DESCR     &CALPRD.DESCR

    let $CalPrd_Descr = &CALPRD.DESCR

FROM PS_GP_CAL_PRD CALPRD
WHERE CAL_PRD_ID = $Cal_Prd_ID

end-Select

end-procedure ! Get-CalPrd-Base-Lang


!***********************************************************************
! Get-CalPrd-Rel-Lang                                                  *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve calendar period related language entry.  Trim *
!               to fit report.                                         *
!***********************************************************************

begin-procedure Get-CalPrd-Rel-Lang

#ifdef debugw
    Show 'Inside procedure Get-CalPrd-Rel-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-CalPrd-Rel-Lang'
#end-if

CALPRDLANG.DESCR     &CALPRDLANG.DESCR

    let $CalPrd_Descr = &CALPRDLANG.DESCR

FROM PS_GP_CAL_PRD_LANG CALPRDLANG
WHERE CALPRDLANG.CAL_PRD_ID  = $Cal_Prd_ID
  AND CALPRDLANG.LANGUAGE_CD = $curr_language_cd

end-Select

end-procedure ! Get-CalPrd-Rel-Lang

!***********************************************************************
! Get-Currency-Base-Lang                                               *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve currency base language entry.                 *
!***********************************************************************

begin-procedure Get-Currency-Base-Lang

#ifdef debugw
    Show 'Inside procedure Get-Currency-Base-Lang'
#end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Currency-Base-Lang'
#end-if

CURR.DESCR     &CURR.DESCR

    let $Currency_Descr = &CURR.DESCR

FROM PS_CURRENCY_CD_TBL CURR
WHERE CURRENCY_CD = $Currency_value

end-Select

#ifdef debugy
  show '$Currency_value= ' $Currency_value
  show '$Currency_Descr= ' $Currency_Descr
#end-if


end-procedure ! Get-Currency-Base-Lang


!***********************************************************************
! Get-Currency-Rel-Lang                                                *
!                                                                      *
! Called By:    Get-Header-Descriptions                                *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve currency related language entry.              *
!***********************************************************************

begin-procedure Get-Currency-Rel-Lang

  #ifdef debugw
     Show 'Inside procedure Get-Currency-Rel-Lang'
  #end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Currency-Rel-Lang'
#end-if

CURRLANG.DESCR     &CURRLANG.DESCR

    let $Currency_Descr = &CURRLANG.DESCR

FROM PS_CURRCD_TBL_LANG CURRLANG
WHERE CURRLANG.CURRENCY_CD    = $Currency_value
  AND CURRLANG.LANGUAGE_CD = $curr_language_cd

end-Select

#ifdef debugy
  show '$Currency_value= ' $Currency_value
  show '$Currency_Descr= ' $Currency_Descr
#end-if

end-procedure ! Get-Currency-Rel-Lang


!***********************************************************************
! Process-Main                                                         *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               Get-Rslt-Ern-Ded                                       *
!               Get-Rslt-Accum                                         *
!               Get-Ded-Arrears                                        *
!                                                                      *
! Description:  Retrieves segment information to be Printed in page    *
!               header.  Manages segment-level page Breaking.  Manages *
!               which report sections to run based on run control.     *
!***********************************************************************

begin-procedure Process-Main

  do Get-List-Set-Data

  evaluate $Rpt_Type
    when = '10'
      do Prcs-Detail-Register
      break
    when = '20'
      do Prcs-Summary-Register
      break
    when = '30'
      do Prcs-Org-Summary
      break
  end-evaluate


end-procedure !Process-Main

!***********************************************************************
! Get-List-Set-Data                                                    *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Description:  Retrieves Element List Set Attributes for report title *
!               then populates the report title variables based on     *
!               options chosen.                                        *
!***********************************************************************

begin-procedure Get-List-Set-Data

#ifdef debugw
  show 'Inside procedure Get-List-Set-Data'
#end-if
begin-SELECT

#ifdef debugw
  show 'Inside SELECT, procedure Get-List-Set-Data'
#end-if
ELN.GP_ELN_ATTR1   &SETATTR1
ELN.GP_ELN_ATTR2   &SETATTR2
ELN.GP_ELN_ATTR3   &SETATTR3
ELN.GP_ELN_ATTR4   &SETATTR4
ELN.GP_ELN_ATTR5   &SETATTR5
ELN.GP_ELN_ATTR6   &SETATTR6
ELN.GP_ELN_ATTR7   &SETATTR7
ELN.GP_ELN_ATTR8   &SETATTR8
ELN.GP_ELN_ATTR9   &SETATTR9
ELN.GP_ELN_ATTR10  &SETATTR10

  let $Attr_RptTitle1 = RTRIM(LTRIM(&SETATTR1,' '),' ')
  let $Attr_RptTitle2 = RTRIM(LTRIM(&SETATTR2,' '),' ')
  let $Str_RptTitle1  = RTRIM(LTRIM(&SETATTR3,' '),' ')
  let $Str_RptTitle2  = RTRIM(LTRIM(&SETATTR4,' '),' ')
  let $Text_RptTitle1 = RTRIM(LTRIM(&SETATTR5,' '),' ')
  let $Text_RptTitle2 = RTRIM(LTRIM(&SETATTR6,' '),' ')
  let $ThousandAttr   = RTRIM(LTRIM(&SETATTR7,' '),' ')
  let $DecimalAttr    = RTRIM(LTRIM(&SETATTR8,' '),' ')
  let $AmtAttr        = RTRIM(LTRIM(&SETATTR9,' '),' ')
  let $UnitAttr       = RTRIM(LTRIM(&SETATTR10,' '),' ')

  evaluate $ThousandAttr
     when = '10'
        let $ReportSThousand = ','
        break
     when = '20'
        let $ReportSThousand = '.'
        break
     when = '30'
        let $ReportSThousand = ' '
        break
  end-evaluate

  evaluate $DecimalAttr
     when = '10'
        let $ReportSDecimal = ','
        break
     when = '20'
        let $ReportSDecimal = '.'
        break
     when = '30'
        let $ReportSDecimal = ' '
        break
  end-evaluate

  evaluate $AmtAttr
     when = '10'
        let $AmtMask = '999,999,999,999'
        let $TotAmtMask = '999,999,999,999,999'
        break
     when = '20'
        let $AmtMask = '999,999,999,999.9'
        let $TotAmtMask = '999,999,999,999,999.9'
        break
     when = '30'
        let $AmtMask = '999,999,999,999.99'
        let $TotAmtMask = '999,999,999,999,999.99'
        break
     when = '40'
        let $AmtMask = '999,999,999,999.999'
        let $TotAmtMask = '999,999,999,999,999.999'
        break
     when = '50'
        let $AmtMask = '999,999,999,999.9999'
        let $TotAmtMask = '999,999,999,999,999.9999'
        break
     when = '60'
        let $AmtMask = '999,999,999,999.99999'
        let $TotAmtMask = '999,999,999,999,999.99999'
        break
     when = '70'
        let $AmtMask = '999,999,999,999.999999'
        let $TotAmtMask = '999,999,999,999,999.999999'
        break
  end-evaluate

  evaluate $UnitAttr
       when = '10'
          let $UntMask = '999,999,999,999'
          let $TotUntMask = '999,999,999,999,999'
          break
       when = '20'
          let $UntMask = '999,999,999,999.9'
          let $TotUntMask = '999,999,999,999,999.9'
          break
       when = '30'
          let $UntMask = '999,999,999,999.99'
          let $TotUntMask = '999,999,999,999,999.99'
          break
       when = '40'
          let $UntMask = '999,999,999,999.999'
          let $TotUntMask = '999,999,999,999,999.999'
          break
       when = '50'
          let $AmtMask = '999,999,999,999.9999'
          let $TotUntMask = '999,999,999,999,999.9999'
          break
       when = '60'
          let $UntMask = '999,999,999,999.99999'
          let $TotUntMask = '999,999,999,999,999.99999'
          break
       when = '70'
          let $UntMask = '999,999,999,999.999999'
          let $TotUntMask = '999,999,999,999,999.999999'
          break
  end-evaluate


  let $ED_Total       = RTRIM(LTRIM(&SETATTR7,' '),' ')

FROM PS_GP_ELN_SET_ATTR ELN
WHERE ELN.COUNTRY = $ELNCountry
AND ELN.GP_ELN_SET = $ELNSet
AND ELN.EFFDT = (SELECT MAX(EFFDT) FROM PS_GP_ELN_SET_ATTR A
                                    WHERE A.COUNTRY = ELN.COUNTRY
                                      AND A.GP_ELN_SET = ELN.GP_ELN_SET
                                      AND EFFDT <= $AsOfToday)
end-SELECT

#ifdef debugy
    show '$Attr_RptTitle1 :' $Attr_RptTitle1
    show '$Attr_RptTitle2 :' $Attr_RptTitle2
    show '$Str_RptTitle1  :' $Str_RptTitle1
    show '$Str_RptTitle2  :' $Str_RptTitle2
    show '$TextRptTitle1  :' $Text_RptTitle1
    show '$TextRptTitle2  :' $Text_RptTitle2
    show '$ED_Total       :' $ED_Total
    show '$ThousandAttr   :' $ThousandAttr
    show '$DecimalAttr    :' $DecimalAttr
    show '$AmtAttr        :' $AmtAttr
    show '$UnitAttr       :' $UnitAttr
#end-if

!
! Build Report Title 1 based on options from Element List
!
evaluate $Attr_RptTitle1

      when = '10'                                  ! Default Title
         let $RptTitle1 = $Dflt_RptTitle1
         break
      when = '20'                                  ! String Entry
         do Get_Field_Information ('GP000001', $Str_RptTitle1, $RptTitle1,    #DW)
         break
      when = '30'                                  ! Text
         let $RptTitle1 = $Text_RptTitle1
         break
      when = '40'                                  ! Do Not print
         let $RptTitle1 = ' '
         break
   end-evaluate
!
! Build Report Title 2 based on options from Element List
!
   evaluate $Attr_RptTitle2
      when = '10'                                   ! Default Title
          evaluate $Rpt_Type
             when = '10'
                let $RptTitle2 = $EEDTL_Title
                break
             when = '20'
                let $RptTitle2 = $EESUM_Title
                break
             when = '30'
                let $RptTitle2 = $ORGSUM_Title
                break
         end-evaluate
         break
      when = '20'                                   ! String Entry
         do Get_Field_Information ('GP000001', $Str_RptTitle2, $RptTitle2,     #DW)
         show 'String Report Title 2' $RptTitle2
         break
      when = '30'                                   ! Text
         let $RptTitle2 = $Text_RptTitle2
         break
      when = '40'                                   ! Do Not print
         let $RptTitle2 = ' '
         break
    end-evaluate

    #ifdef debugy
       show '$RptTitle1:  ' $RptTitle1
       show '$RptTitle2:  ' $RptTItle2
    #end-if

    do Get-Element-Headers

end-procedure ! Get-List-Set-Data


begin-procedure Get-Element-Headers

#ifdef debugw
  show 'Inside Get-Element-Headers'
#end-if

  let $Sect = 'E'
  let $SectType = '10'
  do Get-Element-Titles
  let $PrintErn = $SectMapped
  let $ErnTitle = $SectTitle

  let $Sect = 'D'
  let $SectType = '20'
  do Get-Element-Titles
  let $PrintDed = $SectMapped
  let $DedTitle = $SectTitle

  let $Sect = 'A'
  let $SectType = '30'
  do Get-Element-Titles
  let $PrintAcm = $SectMapped
  let $AcmTitle = $SectTitle

  let $Sect = 'R'
  let $SectType = '40'
  do Get-Element-Titles
  let $PrintArr = $SectMapped
  let $ArrTitle = $SectTitle

end-procedure

!***********************************************************************
! Get-Element-Titles                                                   *
!                                                                      *
! Description:  Retrieves Element List Set Attributes for section      *
!               title.  If multiple element groups the title is taken  *
!               from the first section encountered. If no row is found *
!               a variable is set for the section so it is not printed *
!***********************************************************************

begin-procedure Get-Element-Titles

#ifdef debugw
  show 'Inside procedure Get-Element-Titles'
#end-if

  let $SectMapped = 'N'

begin-SELECT loops=1
#ifdef debugw
  show 'Inside SELECT, procedure Get-Element-Titles'
#end-if
LST.GP_ELN_ATTR2      &LST.GP_ELN_ATTR2
LST.GP_ELN_ATTR3      &LST.GP_ELN_ATTR3
LST.GP_ELN_ATTR4      &LST.GP_ELN_ATTR4

    let $Attr_SectTitle = rtrim(&LST.GP_ELN_ATTR2, ' ')
    let $Attr_SectString = rtrim(&LST.GP_ELN_ATTR3, ' ')
    let $Attr_SectText = rtrim(&LST.GP_ELN_ATTR4,' ')
    let $SectMapped = 'Y'

FROM PS_GP_ELN_SET_LST LST
WHERE LST.COUNTRY = $ELNCountry
  AND LST.GP_ELN_SET = $ELNSet
  AND LST.GP_ELN_ATTR1 IN ($SectType, '50')
  AND LST.EFFDT = (SELECT MAX(EFFDT) FROM PS_GP_ELN_SET_LST L
                                    WHERE L.COUNTRY = LST.COUNTRY
                                      AND L.GP_ELN_SET = LST.GP_ELN_SET
                                      AND EFFDT <= $AsOfToday)
end-SELECT

let $SectTitle = ' '
evaluate $Attr_SectTitle
  when = '10'
     evaluate $Sect
       When = 'E'
         let $SectTitle = $Dflt_ErnTitle
         break
       When = 'D'
         let $SectTitle = $Dflt_DedTitle
         break
       When = 'A'
         let $SectTitle = $Dflt_AcmTitle
         break
       When = 'R'
         let $SectTitle = $Dflt_ArrTitle
         break
     end-evaluate
  when = '20'
     do Get_Field_Information ('GP000001', $Attr_SectString,       $SectTitle,         #DW)
     break
  when = '30'
     let $SectTitle = $Attr_SectText
     break
  when = '40'
     let $SectTitle = ''
     break
end-evaluate

#ifdef debugy
 show '$Attr_SectTitle= ' $Attr_SectTitle
 show '$Attr_SectString= ' $Attr_SecString
 show '$Attr_SectText= ' $Attr_SectText
 show '$Sect= ' $Sect
 show '$SectTitle= ' $SectTitle
#end-if

end-procedure !Get-Element-Titles


!***********************************************************************
! Print-Dynamic-Header                                                 *
!                                                                      *
! Description:  This procedure formats the dynamic header based on the *
!               sorting options chosen in the run control              *
!***********************************************************************

begin-procedure Print-Dynamic-Header

     #ifdef debugw
        show 'inside print-Dynamic-Header'
     #end-if

    let #i = 1
    let #j = 1
    while #i <= #max_sort
      let $Head_lbl = ''
      let $Head_value = ''
      let $Head_descr = ''
      if #CalGrp_Sort = #i
         let $Head_Lbl = $CalGrp_lbl
         if $Page_Break_Indicator = 'Empl_Change'
               or $Page_Break_Indicator = 'Totals'
            let $Head_value = $Last_CalGrp
            let $Head_descr = $Last_CalGrp_Descr
         else
            let $Head_value = $Cal_Run_ID
            let $Head_descr = $CalGrp_Descr
         end-if

         if #i = 1
            print $Head_lbl   (,  {Col_Sort_Label1})
         else
            print $Head_lbl   (+1,{Col_Sort_Label1})
         end-if
         print $Head_value    (,  {Col_Sort_Value1})
         print $Head_descr    (,  {Col_Sort_Descr1})
         print $Calc_Stat_lbl (,  {Col_Sort_Label2})
         print $Calc_Stat     (,  {Col_Sort_Value2})
         let #j = 1
      else
        if #PayEnt_Sort = #i
           let $Head_Lbl = $PayEnt_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                  or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_PayEnt
              let $Head_descr = $Last_PayEnt_Descr
           else
              let $Head_value = $Pay_Entity
              let $Head_descr = $PayEnt_Descr
           end-if
        end-if
        if #PayGrp_Sort = #i
           and $Rpt_Type <> '30'
           let $Head_Lbl = $PayGrp_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_PayGrp
              let $Head_descr = $Last_PayGrp_Descr
           else
              let $Head_value = $Paygroup
              let $Head_descr = $PayGrp_Descr
           end-if
        end-if

        if #Comp_Sort = #i
           let $Head_Lbl = $Comp_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_Comp
              let $Head_descr = $Last_Comp_Descr
           else
              let $Head_value = $Company
              let $Head_descr = $Comp_Descr
           end-if
        end-if

        if #Dept_Sort = #i
           let $Head_Lbl = $Dept_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_Dept
              let $Head_descr = $Last_Dept_Descr
           else
              let $Head_value = $Department
              let $Head_descr = $Dept_Descr
           end-if
        end-if

        if #Estab_Sort = #i
           let $Head_Lbl = $Estab_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                  or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_Estab
              let $Head_descr = $Last_Estab_Descr
           else
              let $Head_value = $Establishment
              let $Head_descr = $Estab_Descr
           end-if
        end-if

        if #Locn_Sort = #i
           let $Head_Lbl = $Locn_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_Locn
              let $Head_descr = $Last_Locn_Descr
           else
              let $Head_value = $Location
              let $Head_descr = $Locn_Descr
           end-if
        end-if

        if #RunType_Sort = #i
           let $Head_Lbl = $Run_Type_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                  or $Page_Break_Indicator = 'Totals'
               let $Head_value = $Last_RunType
               let $Head_descr = $Last_RunType_Descr
           else
               let $Head_value = $Run_Type
               let $Head_descr = $RunType_Descr
           end-if
        end-if

        if #Curr_Sort = #i
           let $Head_Lbl = $Curr_lbl
           if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
              let $Head_value = $Last_Currency_Value
              let $Head_descr = $Last_Currency_Descr
           else
              let $Head_value = $Currency_Value
              let $Head_descr = $Currency_Descr
           end-if
        end-if

        if #i = 1
           print $Head_lbl       (,  {Col_Sort_Label1})
           print $Head_value     (,  {Col_Sort_Value1})
           print $Head_descr     (,  {Col_Sort_Descr1})
           let #j = 2
        else
           if #j = 1
              print $Head_lbl    (+1,{Col_Sort_Label1})
              print $Head_value  (,  {Col_Sort_Value1})
              print $Head_descr  (,  {Col_Sort_Descr1})
              let #j = 2
           else
              print $Head_lbl    (,  {Col_Sort_Label2})
              print $Head_value  (,  {Col_Sort_Value2})
              print $Head_descr  (,  {Col_Sort_Descr2})
              let #j = 1
           end-if
        end-if

      end-if
      let #i = #i +1
   end-while

end-procedure ! Print-Dynamic-Header


begin-procedure Print-Employee-Header

   if #RunType_Sort = 0
      if $Rpt_Type = '20'
         graphic (+2, 1, 180) box 1
      else
         print ' ' (+2,1)
      end-if
   else
      if $Rpt_Type = '20'
         graphic (+2, 1, 180) box 1
      else
         print ' ' (+1,1)
      end-if
   end-if

   if $Page_Break_Indicator = 'Empl_Change'
             or $Page_Break_Indicator = 'Totals'
      print $Emplid_lbl      (,  {Col_Sort_Label1})   Bold
      print $Last_Emplid     (,  {Col_Sort_Value1})   Bold
      print $Rec_Num_lbl     (,  {Col_Sort_Descr1})   Bold
      print #Last_Empl_Rec   (,  {Col_Rec_Num_Value}) Bold  Edit 9
      print $Emp_Nm_lbl      (,  {Col_Sort_Label2})   Bold
      print $Last_Name       (,  {Col_Name_Value})    Bold
   else
      print $Emplid_lbl      (,  {Col_Sort_Label1})   Bold
      print $Emplid          (,  {Col_Sort_Value1})   Bold
      print $Rec_Num_lbl     (,  {Col_Sort_Descr1})   Bold
      print #Empl_Rec        (,  {Col_Rec_Num_Value}) Bold  Edit 9
      print $Emp_Nm_lbl      (,  {Col_Sort_Label2})   Bold
      print $Name            (,  {Col_Name_Value})    Bold
   end-if

end-procedure ! Print-Employee-Header

!***********************************************************************
! Print-Dynamic-Cal-Header                                             *
!                                                                      *
! Description:  This procedure formats the dynamic calendar header     *
!               based on the sorting options chosen in the run control *
!***********************************************************************

begin-procedure Print-Dynamic-Cal-Header

     #ifdef debugw
        show 'inside Print-Dynamic-Cal-Header'
     #end-if

    if #RunType_Sort <> 0
       print ' ' (+1,1)
    end-if

    let #i = 1
    let #j = 1
    while #i <= #cal_pos
      let $Head_lbl = ''
      let $Head_value = ''
      let $Head_descr = ''

      if #PayEnt_Cal = #i
         let $Head_Lbl = $PayEnt_lbl
         if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
            let $Head_value = $Last_PayEnt
            let $Head_descr = $Last_PayEnt_Descr
         else
            let $Head_value = $Pay_Entity
            let $Head_descr = $PayEnt_Descr
         end-if
      end-if

      if #PayGrp_Cal = #i
         let $Head_Lbl = $PayGrp_lbl
         if $Page_Break_Indicator = 'Empl_Change'
                or $Page_Break_Indicator = 'Totals'
            let $Head_value = $Last_PayGrp
            let $Head_descr = $Last_PayGrp_Descr
         else
            let $Head_value = $Paygroup
            let $Head_descr = $PayGrp_Descr
         end-if
      end-if

      if #CalId_Cal = #i
         let $Head_Lbl = $Cal_ID_lbl
         if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
            let $Head_value = $Last_Cal_ID
            let $Head_descr = ' '
         else
            let $Head_value = $Cal_ID
            let $Head_descr = ' '
         end-if
      end-if

      if #RunType_Cal = #i
         let $Head_Lbl = $Run_Type_lbl
         if $Page_Break_Indicator = 'Empl_Change'
                 or $Page_Break_Indicator = 'Totals'
            let $Head_value = $Last_RunType
            let $Head_descr = $Last_RunType_Descr
         else
            let $Head_value = $Run_Type
            let $Head_descr = $RunType_Descr
         end-if
      end-if

      if #i = 1
         print $Head_lbl       (+1,  {Col_Sort_Label1})
         print $Head_value     (,  {Col_Sort_Value1})
         print $Head_descr     (,  {Col_Sort_Descr1})
         let #j = 2
      else
         if #j = 1
            print $Head_lbl    (+1,{Col_Sort_Label1})
            print $Head_value  (,  {Col_Sort_Value1})
            print $Head_descr  (,  {Col_Sort_Descr1})
            let #j = 2
         else
            print $Head_lbl    (,  {Col_Sort_Label2})
            print $Head_value  (,  {Col_Sort_Value2})
            print $Head_descr  (,  {Col_Sort_Descr2})
            let #j = 1
         end-if
      end-if

      let #i = #i +1
   end-while

   if $Page_Break_Indicator = 'Empl_Change'
          or $Page_Break_Indicator = 'Totals'
       print $Cal_Prd_lbl                (+1,{Col_Sort_Label1})
       print $Last_CalPrd                (,  {Col_Sort_Value1})
       print $Last_CalPrd_Descr          (,  {Col_Sort_Descr1})
       print $Pay_Prd_Beg_Dt_lbl         (,  {Col_Sort_Label2})
       print $Last_Period_Begin_Date     (,  +2)
       print $Pay_Prd_End_Dt_lbl         (,  +2)
       print $Last_Period_End_Date       (,  {Col_End_Date_Value})
       print $Pymt_Dt_lbl                (,  {Col_Currency_Label})
       print $Last_Payment_Date          (,  {Col_Currency_Value})
   else
       print $Cal_Prd_lbl           (+1,{Col_Sort_Label1})
       print $Cal_Prd_ID            (,  {Col_Sort_Value1})
       print $CalPrd_Descr          (,  {Col_Sort_Descr1})
       print $Pay_Prd_Beg_Dt_lbl    (,  {Col_Sort_Label2})
       print $Period_Begin_Date     (,  +2)
       print $Pay_Prd_End_Dt_lbl    (,  +2)
       print $Period_End_Date       (,  {Col_End_Date_Value})
       print $Pymt_Dt_lbl           (,  {Col_Currency_Label})
       print $Payment_Date          (,  {Col_Currency_Value})
   end-if

end-procedure ! Print-Dynamic-Cal-Header

!***********************************************************************
! Process-Detail-Register                                              *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Description:  Process Detail Payroll Results Register                *
!***********************************************************************

begin-procedure Prcs-Detail-Register

#ifdef debugw
      show 'Inside procedure Prcs-Detail-Register'
#end-if

 let $DynPrefix = 'GUI'
 let $ClauseType = 'O'
 do Build-Dynamic-Clause
 let $Order_By_Clause = $DynClause

 let #rows_selected = 0

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Prcs-Detail-Register'
#end-if

GUI.GP_PAYGROUP            &GUI.GP_PAYGROUP
GUI.COMPANY                &GUI.COMPANY
GUI.DEPTID                 &GUI.DEPTID
GUI.LOCATION               &GUI.LOCATION
GUI.ESTABID                &GUI.ESTABID
GUI.PYE_PRC_IND            &GUI.PYE_PRC_IND
GUI.SEL_STAT               &GUI.SEL_STAT
GUI.SEL_ACTION             &GUI.SEL_ACTION
GUI.CURRENCY_CD            &GUI.CURRENCY_CD
GUI.RUN_TYPE               &GUI.RUN_TYPE
GUI.PRD_BGN_DT             &GUI.PRD_BGN_DT
GUI.PRD_END_DT             &GUI.PRD_END_DT
GUI.PAY_ENTITY             &GUI.PAY_ENTITY
GUI.PYMT_DT                &GUI.PYMT_DT
GUI.CALC_TYPE              &GUI.CALC_TYPE
GUI.CAL_PRD_ID             &GUI.CAL_PRD_ID
GUI.NAME                   &GUI.NAME
GUI.EMPLID                 &GUI.EMPLID
GUI.CAL_RUN_ID             &GUI.CAL_RUN_ID
GUI.EMPL_RCD               &GUI.EMPL_RCD
GUI.CAL_ID                 &GUI.CAL_ID
GUI.RSLT_SEG_NUM           &GUI.RSLT_SEG_NUM
GUI.RSLT_VER_NUM           &GUI.RSLT_VER_NUM
GUI.RSLT_REV_NUM           &GUI.RSLT_REV_NUM
GUI.CALC_ACTION            &GUI.CALC_ACTION
GUI.PYE_CALC_STAT          &GUI.PYE_CALC_STAT
GUI.SEG_BGN_DT             &GUI.SEG_BGN_DT
GUI.SEG_END_DT             &GUI.SEG_END_DT
GUI.SEG_STATUS             &GUI.SEG_STATUS
GUI.PYMT_KEY1              &GUI.PYMT_KEY1
GUI.PYMT_KEY2              &GUI.PYMT_KEY2
GUI.PYMT_KEY3              &GUI.PYMT_KEY3
GUI.PYMT_KEY4              &GUI.PYMT_KEY4
GUI.CUR_RT_TYPE            &GUI.CUR_RT_TYPE
GUI.PIN_GROSS_VAL          &GUI.PIN_GROSS_VAL
GUI.PIN_NET_VAL            &GUI.PIN_NET_VAL
GUI.ORIG_CAL_RUN_ID        &GUI.ORIG_CAL_RUN_ID

    add 1 to #rows_selected

!***********************************************************************
!                                                                      *
! Read-Translate-Table reads in a field name and value, and returns    *
!   $XlatShortName and XlatLongName from XLATTABLE.                    *
!                                                                      *
!***********************************************************************

    let $FieldName = 'SEG_STATUS'
    let $FieldValue = &GUI.SEG_STATUS
    do Read-Translate-Table

!***********************************************************************
!                                                                      *
! Format-DateTime formats dates.  The format is controlled by          *
!   $ReportDateType which is conditionally set earlier in the report.  *
!                                                                      *
!***********************************************************************

    let $Date1 = &GUI.PRD_BGN_DT
    do Format-DateTime($Date1, $out1, {DEFDATE}, '', '')

    let $Date2 = &GUI.PRD_END_DT
    do Format-DateTime($Date2, $out2, {DEFDATE}, '', '')

    let $Date3 = &GUI.PYMT_DT
    do Format-DateTime($Date3, $out3, {DEFDATE}, '', '')

    let $Date4 = &GUI.SEG_BGN_DT
    do Format-DateTime($Date4, $out4, {DEFDATE}, '', '')

    let $Date5 = &GUI.SEG_END_DT
    do Format-DateTime($Date5, $out5, {DEFDATE}, '', '')


!***********************************************************************
!                                                                      *
! Format-Number formats numbers.  The format is controlled by          *
!   $ReportSDecimal and $ReportSThousand which are conditionally set   *
!   earlier in the report.                                             *
!                                                                      *
!***********************************************************************
    let $Currency_Value     = rtrim(&GUI.CURRENCY_CD,' ')

    let #GrossIn = &GUI.PIN_GROSS_VAL
    do Format-Number(#GrossIn, $GrossOut, $AmtMask)

    let #NetIn = &GUI.PIN_NET_VAL
    do Format-Number(#NetIn, $NetOut, $AmtMask)

    let $Pay_Entity         = rtrim(&GUI.PAY_ENTITY,' ')
    let $Cal_Run_ID         = rtrim(&GUI.CAL_RUN_ID,' ')
    let $Cal_ID             = &GUI.CAL_ID
    let $Cal_Prd_ID         = &GUI.CAL_PRD_ID
    let $Paygroup           = rtrim(&GUI.GP_PAYGROUP,' ')
    let $Company            = rtrim(&GUI.COMPANY,' ')
    let $Department         = rtrim(&GUI.DEPTID,' ')
    let $Establishment      = rtrim(&GUI.ESTABID,' ')
    let #Seg_Num            = &GUI.RSLT_SEG_NUM
    let $Location           = rtrim(&GUI.LOCATION,' ')

    let $Run_Type           = &GUI.RUN_TYPE
    let $Emplid             = &GUI.EMPLID
    let #Empl_Rec           = &GUI.EMPL_RCD
    let #Ver_Num            = &GUI.RSLT_VER_NUM
    let #Rev_Num            = &GUI.RSLT_REV_NUM

    let $Pymt_Key1          = &GUI.PYMT_KEY1
    let $Pymt_Key2          = &GUI.PYMT_KEY2
    let $Pymt_Key3          = &GUI.PYMT_KEY3
    let $Pymt_Key4          = &GUI.PYMT_KEY4
    do Get-Payment-Key-Labels

    let $Seg_Cur_Rt_Typ     = &GUI.CUR_RT_TYPE
    let $Orig_Cal_Run_ID    = &GUI.ORIG_CAL_RUN_ID
    let $Seg_Status         = $XlatLongName
    let $Gross              = $GrossOut
    let $Net                = $NetOut
    let $Period_Begin_Date  = $out1
    let $Period_End_Date    = $out2
    let $Payment_Date       = $out3
    let $Seg_Begin          = $out4
    let $Seg_End            = $out5
    let $Name               = &GUI.NAME

#ifdef debugy
    Show 'SEGMENT EMPL INFO'
    Show '$Emplid:          ' $Emplid
    Show '#Empl_Rec:        ' #Empl_Rec
    Show '#Seg_Num:         ' #Seg_Num
    Show '#Last_Seg_Num:    ' #Last_Seg_Num
#end-if
    do Get-Header-Descriptions

!***********************************************************************
!                                                                      *
! New page on employee change.                                         *
!                                                                      *
!***********************************************************************

   if not(isnull($Last_Emplid))
      if $Cal_Run_ID <> $Last_CalGrp
            or $Pay_Entity <> $Last_PayEnt
            or $PayGroup <> $Last_PayGrp
            or $Company <> $Last_Comp
            or $Department <> $Last_Dept
            or $Establishment <> $Last_Estab
            or $Location <> $Last_Locn
            or $Currency_value <> $Last_Currency_Value
            or $Cal_ID <> $Last_Cal_ID
            or $Run_Type <> $Last_RunType
          do Check-for-Segment-Change
      else
         if $Emplid <> $Last_Emplid or #Empl_Rec <> #Last_Empl_Rec
            if $Page_Break_Indicator = 'Totals'
               new-page
               let $Page_Break_Indicator = 'Reset'
            else
               let $Page_Break_Indicator = 'Empl_Change'
               new-page
               let $Page_Break_Indicator = 'Reset'
            end-if
         end-if
      end-if
   end-if

!***********************************************************************
!                                                                      *
! New page on segment number change within the same employee.          *
!                                                                      *
!***********************************************************************

   if not(isnull($Last_Emplid))
      if $Emplid = $Last_Emplid
         if $Seg_FirstTimethru = 'N'
            if #Seg_Num <> #Last_Seg_Num
               let $Page_Break_Indicator = 'Seg_Change'
               new-page
               let $Page_Break_Indicator = 'Reset'
            end-if
         end-if
      end-if
   end-if

   let $First_ED_Section = 'Y'

   if $PrintERN = 'Y'
      let $SectType = 'E'
      do Get-Rslt-Ern-Ded
   end-if

   if $PrintDED = 'Y'
      let $SectType = 'D'
      do Get-Rslt-Ern-Ded
   end-if

   if $PrintAcm = 'Y'
      do Get-Rslt-Accum
   end-if

   if $PrintArr = 'Y'
      do Get-Ded-Arrears
   end-if

   let $Seg_FirstTimeThru          = 'N'

!***********************************************************************
!                                                                      *
! Keep track of previous segment information for purposes of writing   *
!   out headers.  This info is used in GPRGSTRC.SQC                    *
!                                                                      *
!***********************************************************************

    let $Last_PayEnt                 = $Pay_Entity
    let $Last_CalGrp                 = $Cal_Run_ID
    let $Last_Cal_ID                 = $Cal_ID
    let $Last_CalPrd                 = $Cal_Prd_ID
    let $Last_PayGrp                 = $PayGroup
    let $Last_Currency_Value         = $Currency_Value
    let $Last_RunType                = $Run_Type
    let $Last_Emplid                 = $Emplid
    let #Last_Empl_Rec               = #Empl_Rec
    let #Last_Seg_Num                = #Seg_Num
    let #Last_Ver_Num                = #Ver_Num
    let #Last_Rev_Num                = #Rev_Num
    let $Last_Pymt_Key1              = $Pymt_Key1
    let $Last_Pymt_Key2              = $Pymt_Key2
    let $Last_Pymt_Key3              = $Pymt_Key3
    let $Last_Pymt_Key4              = $Pymt_Key4
    let $Last_Pymt_Key1_lbl          = $Pymt_Key1_lbl
    let $Last_Pymt_Key2_lbl          = $Pymt_Key2_lbl
    let $Last_Pymt_Key3_lbl          = $Pymt_Key3_lbl
    let $Last_Pymt_Key4_lbl          = $Pymt_Key4_lbl

    let $Last_Seg_Status             = $Seg_Status
    let $Last_Gross                  = $Gross
    let $Last_Net                    = $Net
    let $Last_Period_Begin_Date      = $Period_Begin_Date
    let $Last_Period_End_Date        = $Period_End_Date
    let $Last_Payment_Date           = $Payment_Date
    let $Last_Seg_Begin              = $Seg_Begin
    let $Last_Seg_End                = $Seg_End
    let $Last_Comp                   = $Company
    let $Last_Dept                   = $Department
    let $Last_Estab                  = $Establishment
    let $Last_Locn                   = $Location
    let $Last_Name                   = $Name
    let $Last_Orig_Cal_Run_ID        = $Orig_Cal_Run_ID

    let $Last_CalGrp_Descr           = $CalGrp_Descr
    let $Last_PayEnt_Descr           = $PayEnt_Descr
    let $Last_PayGrp_Descr           = $PayGrp_Descr
    let $Last_RunType_Descr          = $RunType_Descr
    let $Last_CalPrd_Descr           = $CalPrd_Descr
    let $Last_Comp_Descr             = $Comp_Descr
    let $Last_Dept_Descr             = $Dept_Descr
    let $Last_Locn_Descr             = $Locn_Descr
    let $Last_Estab_Descr            = $Estab_Descr
    let $Last_Currency_Descr         = $Currency_Descr

FROM PS_GP_RGST_GDE_TMP GUI
WHERE GUI.PROCESS_INSTANCE = #prcs_process_instance - 1
[$Order_By_Clause]

end-Select

   if not #rows_selected
      #include 'gprgsth2.sqc'
      print $NoDataMsg   (+5,10)
   else
      let $End_Report = 'Y'
      do Locate-Detail-Break-Level
   end-if

end-procedure ! Prcs-Detail-Register

begin-procedure Check-for-Segment-Change

#ifdef debugw
    show 'Inside procedure Check-for-Segment-Change'
#end-if

#ifdef debugy
     show '$Last_Emplid  ' $Last_Emplid
     show '$Emplid       ' $Emplid
     show '#Last_Empl_Rec' #Last_Empl_Rec
     show '#Empl_Rec     ' #Empl_Rec
     show '$Last_CalGrp  ' $Last_CalGrp
     show '$Cal_Run_Id   ' $Cal_Run_Id
     show '$Last_PayEnt  ' $Last_PayEnt
     show '$Pay_Entity   ' $Pay_Entity
     show '$Last_PayGrp  ' $Last_PayGrp
     show '$PayGroup     ' $PayGroup
     show '$Last_Dept    ' $Last_Dept
     show '$Department   ' $Department
     show '$Last_Estab   ' $Last_Estab
     show '$Establishment' $Establishment
     show '$Last_Locn    ' $Last_Locn
     show '$Location     ' $Location
     show '$Run_Type     ' $Run_Type
     show '$Last_RunType ' $Last_RunType
     show '$Last_Currency_value ' $Last_Currency_Value
     show '$Currency_value ' $Currency_Value
#end-if

  if $Run_Type <> $Last_RunType
        or $Cal_ID <> $Last_Cal_ID
        or $PayGroup <> $Last_PayGrp
        or $Pay_Entity <> $Last_PayEnt
        or $Currency_Value <> $Last_Currency_Value
        or $Last_Emplid <> $Emplid
        or #Empl_Rec <> #Last_Empl_Rec
      let $Page_Break_Indicator = 'Empl_Change'
  else
     if #CalGrp_Sort <> 0
           and $Cal_Run_ID <> $Last_Cal_Run_ID
        let #Page_Break_Indicator = 'Empl_Change'
     else
        if #Comp_Sort <> 0
                 and $Company <> $Last_Comp
           let #Page_Break_Indicator = 'Empl_Change'
        else
           if #Dept_Sort <> 0
                 and $DeptId <> $Last_DeptID
              let #Page_Break_Indicator = 'Empl_Change'
           else
              if #Estab_Sort <> 0
                    and $Establistment <> $Last_Estab
                 let #Page_Break_Indicator = 'Empl_Change'
              end-if
           end-if
        end-if
     end-if
  end-if

  if $Page_Break_Indicator = 'Empl_Change'
     new-page
     let $Page_Break_Indicator = 'Reset'
  end-if

#ifdef debugy
      show '$Page_Break_Indicator: ' $Page_Break_Indicator
#end-if

end-procedure !Check-for-Segment-Change

!***********************************************************************
! Process-Summary-Register                                             *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Description:  Process Summary Payroll Results Register               *
!***********************************************************************

begin-procedure Prcs-Summary-Register

#ifdef debugw
    show 'Inside procedure Process-Summary-Register'
#end-if

 let $DynPrefix = 'SGUI'
 let $ClauseType = 'O'
 do Build-Dynamic-Clause
 let $Order_By_Clause = $DynClause
 do Build-Dynamic-Select-Fields

 let $DynPrefix = 'STLED'
 do Build-Dynamic-Clause
 let $Order_By_Clause2 = $DynClause

 let $ClauseType = 'G'
 do Build-Dynamic-Clause
 let $Group_By = $DynClause

 let #rows_selected = 0

begin-Select Distinct

#ifdef debugw
    Show 'Inside SELECT, procedure Process-Summary-Register'
#end-if
[$Sel_CalGrp]               &SGUI.CAL_RUN_ID=char
[$Sel_PayEnt]               &SGUI.PAY_ENTITY=char
[$Sel_PayGrp]               &SGUI.GP_PAYGROUP=char
[$Sel_Comp]                 &SGUI.COMPANY=char
[$Sel_Dept]                 &SGUI.DEPTID=char
[$Sel_Locn]                 &SGUI.LOCATION=char
[$Sel_Estab]                &SGUI.ESTABID=char
[$Sel_RunType]              &SGUI.RUN_TYPE=char
[$Sel_Curr]                 &SGUI.CURRENCY_CD=char
SGUI.EMPLID                 &SGUI.EMPLID
SGUI.EMPL_RCD               &SGUI.EMPL_RCD
SGUI.NAME                   &SGUI.NAME

    Add 1 to #rows_selected

    if $Sel_CalGrp <> ''
       let $Cal_Run_ID         = rtrim(&SGUI.CAL_RUN_ID,' ')
    end-if

    if $Sel_PayEnt <> ''
       let $Pay_Entity         = rtrim(&SGUI.PAY_ENTITY,' ')
    end-if

    if $Sel_PayGrp <> ''
       let $Paygroup           = rtrim(&SGUI.GP_PAYGROUP,' ')
    end-if

    if $Sel_Comp <> ''
       let $Company            = rtrim(&SGUI.COMPANY,' ')
    end-if

    if $Sel_Dept <> ''
       let $Department         = rtrim(&SGUI.DEPTID,' ')
    end-if

    if $Sel_Locn <> ''
       let $Location           = rtrim(&SGUI.LOCATION,' ')
    end-if

    if $Sel_Estab <> ''
       let $Establishment      = rtrim(&SGUI.ESTABID,' ')
    end-if

    if $Sel_RunType <> ''
       let $Run_Type           = rtrim(&SGUI.RUN_TYPE,' ')
    end-if

    if $Sel_Curr <> ''
       let $Currency_Value     = rtrim(&SGUI.CURRENCY_CD,' ')
    end-if

    let $Emplid             = &SGUI.EMPLID
    let #Empl_Rec           = &SGUI.EMPL_RCD
    let $Name               = &SGUI.NAME

 #ifdef debugy
    Show 'EMPL INFO'
    Show '$Emplid:          ' $Emplid
    Show '#Empl_Rec:        ' #Empl_Rec
#end-if

    do Get-Header-Descriptions

!***********************************************************************
!                                                                      *
! New page on employee change.                                         *
!                                                                      *
!***********************************************************************

   if not(isnull($Last_Emplid))
      if $Emplid <> $Last_Emplid or #Empl_Rec <> #Last_Empl_Rec
             or $Cal_ID <> $Last_Cal_ID or $Paygroup <> $Last_PayGrp
             or $Pay_Entity <> $Last_PayEnt or $Last_Currency <> $Currency_Value
             or $Company <> $Last_Comp or $Location <> $Last_Locn or $Establishment <> $Last_Estab
             or $Run_Type <> $Last_RunType
         let $Page_Break_Indicator = 'Empl_Change'
         new-page
         let $Page_Break_Indicator = 'Reset'
      end-if
   end-if

   do Build-Sum-Where-Clause
   let $SumWhere = $DynClause

   if $PrintERN = 'Y'
      let $SectType = 'E'
      do Get-Rslt-Ern-Ded-Sum
   end-if

   if $PrintDED = 'Y'
      let $SectType = 'D'
      do Get-Rslt-Ern-Ded-Sum
   end-if


   let $Seg_FirstTimeThru          = 'N'

!***********************************************************************
!                                                                      *
! Keep track of previous segment information for purposes of writing   *
!   out headers.  This info is used in GPRGSTRC.SQC                    *
!                                                                      *
!***********************************************************************

    let $Last_PayEnt                 = $Pay_Entity
    let $Last_CalGrp                 = $Cal_Run_ID
    let $Last_Cal_ID                 = $Cal_ID
    let $Last_CalPrd                 = $Cal_Prd_ID
    let $Last_PayGrp                 = $PayGroup
    let $Last_RunType                = $Run_Type
    let $Last_Currency_Value         = $Currency_Value
    let $Last_Emplid                 = $Emplid

    let $Last_Comp                   = $Company
    let $Last_Dept                   = $Department
    let $Last_Estab                  = $Establishment
    let $Last_Locn                   = $Location
    let $Last_Name                   = $Name
    let #Last_Empl_Rec               = #Empl_Rec

    let $Last_CalGrp_Descr           = $CalGrp_Descr
    let $Last_PayEnt_Descr           = $PayEnt_Descr
    let $Last_PayGrp_Descr           = $PayGrp_Descr
    let $Last_Comp_Descr             = $Comp_Descr
    let $Last_Dept_Descr             = $Dept_Descr
    let $Last_Locn_Descr             = $Locn_Descr
    let $Last_Estab_Descr            = $Estab_Descr
    let $Last_RunType_Descr          = $RunType_Descr
    let $Last_Currency_Descr         = $Currency_Descr

FROM PS_GP_RGST_GDE_TMP SGUI
WHERE SGUI.PROCESS_INSTANCE = #prcs_process_instance - 1
[$Order_By_Clause]
end-Select

   if not #rows_selected
      #include 'gprgsth2.sqc'
      print $NoDataMsg   (+5,10)
   end-if

end-procedure ! Prcs-Summary-Register


begin-procedure Build-Dynamic-Select-Fields

#ifdef debugw
    Show 'Inside procedure Build-Dynamic-Select-Fields'
#end-if

!********************************************************************
!  Build Dynamic Sort Fields since only the organizational fields   *
!  which are included in the sort should be included in the Select  *
!********************************************************************

    if #calgrp_sort <> 0
       let $Sel_CalGrp = $DynPrefix || '.CAL_RUN_ID'
    else
       let $Sel_CalGrp = ''
    end-if

    if #payent_sort <> 0
       let $Sel_PayEnt = $DynPrefix || '.PAY_ENTITY'
    else
       let $Sel_PayEnt = ''
    end-if

    if #paygrp_sort <> 0
       let $Sel_PayGrp = $DynPrefix || '.GP_PAYGROUP'
    else
       let $Sel_PayGrp = ''
    end-if

    if #comp_sort <> 0
       let $Sel_Comp = $DynPrefix || '.COMPANY'
    else
       let $Sel_Comp = ''
    end-if

    if #dept_sort <> 0
       let $Sel_Dept = $DynPrefix || '.DEPTID'
    else
       let $Sel_Dept = ''
    end-if

    if #locn_sort <> 0
       let $Sel_Locn = $DynPrefix || '.LOCATION'
    else
       let $Sel_Locn = ''
    end-if

    if #estab_sort <> 0
       let $Sel_Estab = $DynPrefix || '.ESTABID'
    else
       let $Sel_Estab = ''
    end-if

    if #RunType_Sort <> 0
       let $Sel_RunType = $DynPrefix || '.RUN_TYPE'
    else
       let $Sel_RunType = ''
    end-if

    if #curr_sort <> 0
       let $Sel_Curr = $DynPrefix || '.CURRENCY_CD'
     else
       let $Sel_Curr = ''
    end-if

#ifdef debugy
    show '$Sel_CalGrp ' $Sel_CalGrp
    show '$Sel_PayEnt ' $Sel_PayEnt
    show '$Sel_PayGrp ' $Sel_PayGrp
    show '$Sel_Comp   ' $Sel_Comp
    show '$Sel_Dept   ' $Sel_Dept
    show '$Sel_Locn   ' $Sel_Locn
    show '$Sel_Estab  ' $Sel_Estab
    show '$Sel_RunType ' $Sel_RunType
    show '$Sel_Curr   ' $Sel_Curr
#end-if
end-procedure ! Build-Dynamic-Select-Fields


begin-procedure Find-Detail-Sort-Sequence

 #ifdef debugw
   show 'Inside Find-Detail-Sort-Sequence'
 #end-if

  if #CalGrp_Sort = #k
      if $Last_CalGrp <> $Cal_Run_ID
           or ($Force_Break = 'Y' and (#CalGrp_Amt <> 0 or #CalGrp_Unt <> 0))
         let $Tot_lbl = $Tot_CalGrp_lbl || ' ' || $Cal_Run_ID
      end-if
   end-if

   if #PayEnt_Sort = #k
      if $Last_PayEnt <> $Pay_Entity
            or ($Force_Break = 'Y' and (#PayEnt_Amt <> 0 or #PayEnt_Unt <> 0))
         let $Tot_lbl = $Tot_PayEnt_lbl || ' ' || $Pay_Entity
      end-if
   end-if

   if #PayGrp_Sort = #k
      if $Last_PayGrp <> $PayGroup
            or ($Force_Break = 'Y' and (#PayGrp_Amt <> 0 or #PayGrp_Unt <> 0))
         let $Tot_lbl = $Tot_PayGrp_lbl || ' ' || $PayGroup
      end-if
   end-if

   if #Comp_Sort = #k
      if $Last_Comp <> $Company
            or ($Force_Break = 'Y' and (#Comp_Amt <> 0 or #Comp_Unt <> 0))
         let $Tot_lbl = $Tot_Comp_lbl || ' ' || $Company
      end-if
   end-if

   if #Dept_Sort = #k
      if $Last_Dept <> $Department
            or ($Force_Break = 'Y' and (#Dept_Amt <> 0 or #Dept_Unt <> 0))
         let $Tot_lbl = $Tot_Dept_lbl || ' ' || $Department
      end-if
   end-if

   if #Locn_Sort = #k
      if $Last_Locn <> $Location
            or ($Force_Break = 'Y' and (#Locn_Amt <> 0 or #Locn_Unt <> 0))
         let $Tot_lbl = $Tot_Locn_lbl || ' ' || $Location
      end-if
   end-if

   if #Estab_Sort = #k
      if $Last_Estab <> $Establishment
            or ($Force_Break = 'Y' and (#Estab_Amt <> 0 or #Estab_Unt <> 0))
         let $Tot_lbl = $Tot_Estab_lbl || ' ' || $Establishment
      end-if
   end-if

  if #RunType_Sort = #k
        if $Last_RunType_Value <> $Run_Type
              or ($Force_Break = 'Y' and (#Curr_Amt <> 0 or #Curr_Unt <> 0))
           let $Tot_lbl = $Tot_RunType_lbl || ' ' || $Run_Type
        end-if
   end-if

   if #Curr_Sort = #k
      if $Last_Currency_Value <> $Currency_Value
            or ($Force_Break = 'Y' and (#Curr_Amt <> 0 or #Curr_Unt <> 0))
         let $Tot_lbl = $Tot_Curr_lbl || ' ' || $Currency_Value
      end-if
   end-if

end-procedure ! Find-Detail-Sort-Sequence

!***********************************************************************
! Build-Dynamic-Clause                                                 *
!                                                                      *
! Description:  This procedure builds the order by or group by clause  *
!               based on the sort options chosen in the run control.   *
!***********************************************************************

begin-procedure Build-Dynamic-Clause

#ifdef debugw
  show 'Inside procedure Build-Dynamic-Clause'
#end-if

  let $DynClause = ''

  let #i = 1
  while #i <= #max_sort
      if #CalGrp_Sort = #i
         let $BldClause = $DynPrefix || '.CAL_RUN_ID'
      end-if
      if #PayEnt_Sort = #i
         let $BldClause = $DynPrefix || '.PAY_ENTITY'
      end-if
      if #PayGrp_Sort = #i
         let $BldClause = $DynPrefix || '.GP_PAYGROUP'
      end-if
      if #Comp_Sort = #i
         let $BldClause = $DynPrefix || '.COMPANY'
      end-if
      if #Dept_Sort = #i
         let $BldClause = $DynPrefix || '.DEPTID'
      end-if
      if #Locn_Sort = #i
         let $BldClause = $DynPrefix || '.LOCATION'
      end-if
      if #Estab_Sort = #i
         let $BldClause = $DynPrefix || '.ESTABID'
      end-if
      if #RunType_Sort = #i
         let $BldClause = $DynPrefix || '.RUN_TYPE'
      end-if
      if #Curr_Sort = #i
         let $BldClause = $DynPrefix || '.CURRENCY_CD'
      end-if
      if #i = 1
         if $ClauseType = 'O'
            let $DynClause = 'ORDER BY ' || $BldClause
         else
            let $DynClause = 'GROUP BY ' || $BldClause
         end-if
      else
         let $DynClause = $DynClause || ', ' || $BldClause
      end-if

      let #i = #i + 1
  end-while


  if $ClauseType = 'O' and $Rpt_Type <> '30'
     if $Empl_Sort = '10'
        let $DynClause = $DynClause || ', ' || $DynPrefix || '.NAME, ' || $DynPrefix ||'.EMPL_RCD'
     else
        let $DynClause = $DynClause || ', ' || $DynPrefix || '.EMPLID, ' || $DynPrefix || '.EMPL_RCD'
     end-if
  end-if

 #ifdef debugy
    show '$ClauseType= ' $ClauseType
    show '$DynPrefix=  ' $DynPrefix
    show '$DynClause=  ' $DynClause
 #end-if

end-procedure ! Build-Dynamic-Clause


begin-procedure Build-Sum-Where-Clause

#ifdef debugw
  show 'Inside procedure Build-Sum-Where-Clause'
#end-if

  let $DynClause = ''
  let #i = 1
  while #i <= #max_sort
      if #CalGrp_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.CAL_RUN_ID = ' || $SQLQuote || $Cal_Run_ID || $SQLQuote
      end-if
      if #PayEnt_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.PAY_ENTITY = ' || $SQLQuote || $Pay_Entity || $SQLQuote
      end-if
      if #PayGrp_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.GP_PAYGROUP = ' || $SQLQuote || $Paygroup || $SQLQuote
      end-if
      if #Comp_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.COMPANY = ' || $SQLQuote || $Company || $SQLQuote
      end-if
      if #Dept_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.DEPTID = ' || $SQLQuote || $Department || $SQLQuote
      end-if
      if #Locn_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.LOCATION = ' || $SQLQuote || $Location || $SQLQuote
      end-if
      if #Estab_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.ESTABID = ' || $SQLQuote || $Establishment || $SQLQuote
      end-if
      if #RunType_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.RUN_TYPE = ' || $SQLQuote || $Run_Type || $SQLQuote
      end-if
      if #Curr_Sort = #i
         let $BldClause = ' AND ' || $DynPrefix || '.CURRENCY_CD = ' || $SQLQuote || $Currency_Value || $SQLQuote
      end-if

      let $DynClause = $DynClause || $BldClause

      let #i = #i + 1
  end-while

#ifdef debugy
  show '$DynClause= ' $DynClause
#end-if

end-procedure ! Build-Sum-Where-Clause


!************************************************************************
! Get-Payment-Key-Labels                                                *
!                                                                       *
! Description:  Retrieves the fieldname of the payment key then assigns *
!               the Label of the Payment Key                            *
!************************************************************************

begin-procedure Get-Payment-Key-Labels

#ifdef debugw
  show 'Inside procedure Get-Payment-Key-Labels'
#end-if

  let $Key1_Nm = ' '
  let $Key2_Nm = ' '
  let $Key3_Nm = ' '
  let $Key4_Nm = ' '

begin-SELECT
#ifdef debugw
  show 'Inside SELECT, procedure Get-Payment-Key-Labels'
#end-if
PMTK.FIELDNAME_PYMT_K1   &PMTK.FIELDNAME_PMT_K1
PMTK.FIELDNAME_PYMT_K2   &PMTK.FIELDNAME_PMT_K2
PMTK.FIELDNAME_PYMT_K3   &PMTK.FIELDNAME_PMT_K3
PMTK.FIELDNAME_PYMT_K4   &PMTK.FIELDNAME_PMT_K4

  let $Key1_Nm = rtrim(&PMTK.FIELDNAME_PMT_K1,' ')
  let $Key2_Nm = rtrim(&PMTK.FIELDNAME_PMT_K2,' ')
  let $Key3_Nm = rtrim(&PMTK.FIELDNAME_PMT_K3,' ')
  let $Key4_Nm = rtrim(&PMTK.FIELDNAME_PMT_K4,' ')

FROM PS_GP_PYENT PMTK
WHERE PAY_ENTITY = $Pay_Entity
end-SELECT

#ifdef debugy
  show '$Key1_Nm= ' $Key1_Nm
  show '$Key2_Nm= ' $Key2_Nm
  show '$Key3_Nm= ' $Key3_Nm
  show '$Key4_Nm= ' $Key4_Nm
#end-if

  let $Pymt_Key = $Key1_Nm
  do Assign-Payment-Key-Label
  let $Pymt_Key1_lbl = $Key_lbl

  let $Pymt_Key = $Key2_Nm
  do Assign-Payment-Key-Label
  let $Pymt_Key2_lbl = $Key_lbl

  let $Pymt_Key = $Key3_Nm
  do Assign-Payment-Key-Label
  let $Pymt_Key3_lbl = $Key_lbl

  let $Pymt_Key = $Key4_Nm
  do Assign-Payment-Key-Label
  let $Pymt_Key4_lbl = $Key_lbl

end-procedure ! Get-Payment-Key-Labels

!***********************************************************************
! Assign-Payment-Key-Label                                             *
!                                                                      *
! Description:  Determines the label of Payment Key                    *
!***********************************************************************

begin-procedure Assign-Payment-Key-Label
#ifdef debugw
  show 'Inside procedure Assign-Payment-Key-Label'
#end-if
   let $Key_lbl = ' '

   evaluate $Pymt_Key
      when = 'COMPANY'
         let $Key_lbl = $Comp_lbl
         break
      when = 'DEPTID'
         let $Key_lbl = $Dept_lbl
         break
      when = 'ESTABID'
         let $Key_lbl = $Estab_lbl
         break
      when = 'CONTRACT_NUM'
         let $Key_lbl = $Contract_lbl
         break
   end-evaluate

end-procedure ! Assign-Payment-Key-Label

!***********************************************************************
! Get-Rslt-Ern-Ded                                                     *
!                                                                      *
! Called By:    Get-Seg-Info                                           *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               Print-Ern-Ded-Info                                     *
!                                                                      *
! Description:  Retrieves earnings & deductions info.  Manages         *
!               "Earnings and Deductions" section header Printing.     *
!***********************************************************************

begin-procedure Get-Rslt-Ern-Ded

#ifdef debugw
    Show 'Inside procedure Get-Rslt-Ern-Ded'
#end-if

    let #EEAmt = 0
    let #EEUnit = 0

    if $SectType = 'E'
       let $EDWhere = $ERNWhere
    end-if

    if $SectType = 'D'
       let $EDWhere = $DEDWhere
    end-if

    let $ErnDed_FirstTimethru = 'Y'
    let #ErnDed_Rows_Found    =  0

begin-Select
#ifdef debugw
    Show 'Inside SELECT, procedure Get-Rslt-Ern-Ded'
#end-if
DTLED.EMPLID                   &DTLED.EMPLID
DTLED.CAL_RUN_ID               &DTLED.CAL_RUN_ID
DTLED.EMPL_RCD                 &DTLED.EMPL_RCD
DTLED.GP_PAYGROUP              &DTLED.GP_PAYGROUP
DTLED.CAL_ID                   &DTLED.CAL_ID
DTLED.RSLT_SEG_NUM             &DTLED.RSLT_SEG_NUM
DTLED.PIN_NUM                  &DTLED.PIN_NUM
DTLED.INSTANCE                 &DTLED.INSTANCE
DTLED.SLICE_BGN_DT             &DTLED.SLICE_BGN_DT
DTLED.SLICE_END_DT             &DTLED.SLICE_END_DT
DTLED.CALC_RSLT_VAL            &DTLED.CALC_RSLT_VAL
DTLED.CALC_ADJ_VAL             &DTLED.CALC_ADJ_VAL
DTLED.BASE_RSLT_VAL            &DTLED.BASE_RSLT_VAL
DTLED.BASE_ADJ_VAL             &DTLED.BASE_ADJ_VAL
DTLED.RATE_RSLT_VAL            &DTLED.RATE_RSLT_VAL
DTLED.PCT_RSLT_VAL             &DTLED.PCT_RSLT_VAL
DTLED.UNIT_RSLT_VAL            &DTLED.UNIT_RSLT_VAL
DTLED.UNIT_ADJ_VAL             &DTLED.UNIT_ADJ_VAL
DTLED.PIN_NM                   &DTLED.PIN_NM
DTLED.PIN_TYPE                 &DTLED.PIN_TYPE
DTLED.USER_KEY1                &DTLED.USER_KEY1
DTLED.USER_KEY2                &DTLED.USER_KEY2
DTLED.USER_KEY3                &DTLED.USER_KEY3
DTLED.USER_KEY4                &DTLED.USER_KEY4
DTLED.USER_KEY5                &DTLED.USER_KEY5
DTLED.USER_KEY6                &DTLED.USER_KEY6


    let $Date6 = &DTLED.SLICE_BGN_DT
    do Format-DateTime($Date6, $out6, {DEFDATE}, '', '')

    let $Date7 = &DTLED.SLICE_END_DT
    do Format-DateTime($Date7, $out7, {DEFDATE}, '', '')

    let #Calc_Rslt = &DTLED.CALC_RSLT_VAL
    do Format-Number(#Calc_Rslt, $Calc_Rslt, $AmtMask)

    let #Calc_Adj = &DTLED.CALC_ADJ_VAL
    do Format-Number(#Calc_Adj,  $Calc_Adj, $AmtMask)

    let #Base_Rslt = &DTLED.BASE_RSLT_VAL
    do Format-Number(#Base_Rslt, $Base_Rslt, $UntMask)

    let #Base_Adj  = &DTLED.BASE_ADJ_VAL
    do Format-Number(#Base_Adj, $Base_Adj, $UntMask)

    let #Rate_Rslt = &DTLED.RATE_RSLT_VAL
    do Format-Number(#Rate_Rslt, $Rate_Rslt, $UntMask)

    let #Pct_Rslt = &DTLED.PCT_RSLT_VAL
    do Format-Number(#Pct_Rslt,  $Pct_Rslt,  $UntMask)

    let #Unit_Rslt = &DTLED.UNIT_RSLT_VAL
    do Format-Number(#Unit_Rslt, $Unit_Rslt, $UntMask)

    let #Unit_Adj = &DTLED.UNIT_ADJ_VAL
    do Format-Number(#Unit_Adj, $Unit_Adj,  $UntMask)

    let #Ern_Ded_PIN_Num        = &DTLED.PIN_NUM
    let #Ern_Ded_Instance       = &DTLED.INSTANCE
    let $Ern_Ded_Slice_Begin    = $out6
    let $Ern_Ded_Slice_End      = $out7
    let $Ern_Ded_PIN_Name       = &DTLED.PIN_NM
    let $UserKey1               = substr(&DTLED.USER_KEY1,1,20)
    let $UserKey2               = substr(&DTLED.USER_KEY2,1,20)
    let $UserKey3               = substr(&DTLED.USER_KEY3,1,20)
    let $UserKey4               = substr(&DTLED.USER_KEY4,1,20)
    let $UserKey5               = substr(&DTLED.USER_KEY5,1,20)
    let $UserKey6               = substr(&DTLED.USER_KEY6,1,20)

    if $curr_language_cd <> $Psoptions_Language_Cd
       let #PIN_Num        = #Ern_Ded_PIN_Num
       do exchange-pin-name
       if $PIN_Name <> ''
          let $Ern_Ded_PIN_Name       = $PIN_Name
       end-if
    end-if

    let #ErnDed_Rows_Found    = #ErnDed_Rows_Found + 1

    do print-Ern-Ded-Info
    let $ErnDed_FirstTimethru = 'N'

FROM PS_GP_RGST_DTL_TMP DTLED
WHERE DTLED.PROCESS_INSTANCE = #prcs_process_instance -1
  AND DTLED.PIN_TYPE IN ('ER','DD')
  AND DTLED.EMPLID           = $Emplid
  AND DTLED.EMPL_RCD         = #Empl_Rec
  AND DTLED.CAL_RUN_ID       = $Cal_Run_ID
  AND DTLED.ORIG_CAL_RUN_ID  = $Orig_Cal_Run_ID
  AND DTLED.CAL_ID           = $Cal_ID
  AND DTLED.GP_PAYGROUP      = $Paygroup
  AND DTLED.RSLT_SEG_NUM     = #Seg_Num
  AND [$EDWhere]
ORDER BY DTLED.PIN_TYPE, DTLED.PIN_NM, DTLED.SLICE_BGN_DT, DTLED.INSTANCE
end-Select

    if #ErnDed_Rows_Found =  0
       do print-Ern-Ded-Header
    end-if

end-procedure ! Get-Rslt-Ern-Ded



!***********************************************************************
! Get-Rslt-Ern-Ded-Sum                                                 *
!                                                                      *
! Called By:    Get-Seg-Info                                           *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               print-Ern-Ded-Info                                     *
!                                                                      *
! Description:  Retrieves earnings & deductions info.  Manages         *
!               "Earnings and Deductions" section header Printing.     *
!***********************************************************************

begin-procedure Get-Rslt-Ern-Ded-Sum

#ifdef debugw
    Show 'Inside procedure Get-Rslt-Ern-Ded-Sum'
#end-if

    if $SectType = 'E'
       let $EDWhere = $ERNWhere2
    end-if

    if $SectType = 'D'
       let $EDWhere = $DEDWhere2
    end-if

    let $ErnDed_FirstTimethru = 'Y'
    let #ErnDed_Rows_Found    =  0

#ifdef debugy
  show '$EDWhere=  ' $EDWhere
  show '$SumWhere= ' $SumWhere
  show '$Order_By_Clause2= ' $Order_By_Clause2
#end-if

begin-Select
#ifdef debugw
    Show 'Inside SELECT, procedure Get-Rslt-Ern-Ded-Sum'
#end-if
STLED.PIN_NUM                  &STLED.PIN_NUM
STLED.PIN_NM                   &STLED.PIN_NM
STLED.PIN_TYPE                 &STLED_PIN_TYPE
STLED.EMPLID                   &STLED.EMPLID
STLED.EMPL_RCD                 &STLED.EMPL_RCD
SUM(STLED.CALC_RSLT_VAL)       &STLED.CALC_RSLT_VAL
SUM(STLED.UNIT_RSLT_VAL)       &STLED.UNIT_RSLT_VAL
SUM(STLED.CALC_ADJ_VAL)        &STLED.CALC_ADJ_VAL
SUM(STLED.UNIT_ADJ_VAL)        &STLED.UNIT_ADJ_VAL


    let #Calc_Rslt = &STLED.CALC_RSLT_VAL
    do Format-Number(#Calc_Rslt, $Calc_Rslt, $TotAmtMask)

    let #Unit_Rslt = &STLED.UNIT_RSLT_VAL
    do Format-Number(#Unit_Rslt, $Unit_Rslt, $TotUntMask)

    let #Calc_Adj = &STLED.CALC_ADJ_VAL
    do Format-Number(#Calc_Adj, $Calc_Adj, $TotAmtMask)

    let #Unit_Adj = &STLED.UNIT_ADJ_VAL
    do Format-Number(#Unit_Adj, $Unit_Adj, $TotUntMask)

    let #Ern_Ded_PIN_Num        = &STLED.PIN_NUM

    let $Ern_Ded_PIN_Name       = &STLED.PIN_NM

    if $curr_language_cd <> $Psoptions_Language_Cd
       let #PIN_Num        = #Ern_Ded_PIN_Num
       do Exchange-Pin-Name
       if $PIN_Name <> ''
          let $Ern_Ded_PIN_Name       = $PIN_Name
       end-if
    end-if

    let #ErnDed_Rows_Found    = #ErnDed_Rows_Found + 1

    do print-Ern-Ded-Info

    let $ErnDed_FirstTimethru = 'N'

    let #tot_amt = #tot_amt + #Calc_Rslt
    let #tot_unt = #tot_unt + #Unit_Rslt
    let #tot_amt_adj = #tot_amt_adj + #Calc_Adj
    let #tot_unt_adj = #tot_unt_adj + #Unit_Adj

FROM PS_GP_RGST_DTL_TMP STLED
WHERE STLED.PROCESS_INSTANCE = #prcs_process_instance -1
  AND STLED.PIN_TYPE IN ('ER','DD')
  AND STLED.EMPLID           = $Emplid
  AND STLED.EMPL_RCD         = #Empl_Rec
  AND (STLED.CALC_RSLT_VAL <> 0 OR STLED.UNIT_RSLT_VAL <> 0
       OR STLED.UNIT_ADJ_VAL <> 0 OR STLED.CALC_ADJ_VAL <> 0)
  AND [$EDWhere]
[$SumWhere]
GROUP BY STLED.EMPLID, STLED.EMPL_RCD, STLED.PIN_NUM, STLED.PIN_NM, STLED.PIN_TYPE
ORDER BY 3,2
end-Select

    if #ErnDed_Rows_Found =  0
       do print-Ern-Ded-Header
    else
       if #current-line + 3 > #Maxlines
            New-Page
            let $ErnDed_FirstTimethru = 'Y'
            do print-Ern-Ded-Header
            let $ErnDed_FirstTimethru = 'N'
       end-if

       do Format-Number(#tot_amt,$Tot_Amt, $TotAmtMask)
       do Format-Number(#tot_unt,$Tot_Unt, $TotUntMask)
       do Format-Number(#tot_amt_adj, $Tot_Amt_Adj, $TotAmtMask)
       do Format-Number(#tot_unt_adj, $Tot_Unt_Adj, $TotUntMask)

       print ' ' (+1,1)

       if #tot_amt <> 0
          print '--------------------------' (, {Col_SUM_Amt})
       end-if

       if #tot_amt_adj <> 0
          print '--------------------------' (,   {Col_SUM_Amt_Adj})
       end-if

       if #tot_unt <> 0
          print '--------------------------' (,   {Col_SUM_Unit})
       end-if

       if #tot_unt_adj <> 0
          print '--------------------------' (,   {Col_SUM_Unit_Adj})
       end-if

       print $Total_lbl                 (+1,2) bold

       if #tot_amt <> 0
          print $Tot_Amt                   (,  {Col_SUM_Amt})
       end-if

       if #tot_amt_adj <> 0
          print $Tot_Amt_Adj               (,  {Col_SUM_Amt_Adj})
       end-if

       if #tot_unt <> 0
          print $Tot_Unt                   (,  {Col_SUM_Unit})
       end-if

       if #tot_unt_adj <> 0
          print $Tot_Unt_Adj               (,  {Col_SUM_Unit_Adj})
       end-if

       let #tot_amt = 0
       let #tot_unt = 0
       let #tot_amt_adj = 0
       let #tot_unt_adj = 0
    end-if

end-procedure ! Get-Rslt-Ern-Ded


!***********************************************************************
! Exchange-Pin-Name                                                    *
!                                                                      *
!                                                                      *
! Description:  Retrieve PIN Name related language entry.  Trim to fit *
!                   report.                                            *
!***********************************************************************

begin-procedure Exchange-Pin-Name

#ifdef debugw
    Show 'Inside procedure Exchange-Pin-Name'
#end-if

   let $PIN_name = ''

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Exchange-Pin-Name'
#end-if

PINLANG.PIN_NM  &PINLANG.PIN_NM

    let $PIN_Name     = &PINLANG.PIN_NM

FROM PS_GP_PIN_LANG PINLANG
WHERE PINLANG.PIN_NUM     = #PIN_Num
  AND PINLANG.LANGUAGE_CD = $curr_language_cd
end-Select

end-procedure ! exchange-pin-name


!***********************************************************************
! Print-Ern-Ded-Info                                                   *
!                                                                      *
! Called By:    Get-Rslt-Ern-Ded                                       *
!                                                                      *
! Calls:        print-Ern-Ded-Header                                   *
!                                                                      *
! Description:  Prints body of "Earnings and Deductions" section.      *
!               Manages "Earnings and Deductions" section header       *
!               Printing.  Manages page Breaking within the body of    *
!               "Earnings and Deductions" section.                     *
!***********************************************************************

begin-procedure Print-Ern-Ded-Info

   #ifdef debugw
      Show 'Inside procedure print-Ern-Ded-Info'
   #end-if

!***********************************************************************
! Make sure that a single row of retrieved information, which Prints   *
!   as two lines on the report, is not split so that the first line is *
!   on one page and the second line is on the other.  if this is the   *
!   case, start a new page so that both lines print on the new page.   *
!***********************************************************************

#ifdef debugy
  show '$ErnDed_FirstTimethru=' $ErnDed_FirstTimethru
#end-if
    if #current-line + 3 > #Maxlines
        New-Page
        let $ErnDed_FirstTimethru = 'Y'
    end-if

    if $ErnDed_FirstTimethru = 'Y'
        do print-Ern-Ded-Header
    end-if

    Position (+1)

  if $Rpt_Type = '10'
     print $Ern_Ded_PIN_Name         (,{Col_Sort_Label1})
     print #Ern_Ded_Instance         (,{Col_ED_Instance})       Edit 999
     print $Ern_Ded_Slice_Begin      (,{Col_ED_Slice_Dates})
     print $UserKey1                 (,{Col_ED_Field135})
     print $UserKey2                 (,{Col_ED_Field246})

!***********************************************************************
!                                                                      *
! do not print the value of a field if it is zero.                     *
!                                                                      *
!***********************************************************************

      if #Calc_Rslt <> 0
         print $Calc_Rslt        (,{Col_ED_Amt})
      else
         print ' '             (,{Col_ED_Amt})
      end-if

      if #Base_Rslt <> 0
         print $Base_Rslt        (,{Col_ED_Base})
      else
         print ' '             (,{Col_ED_Base})
      end-if

      if #Rate_Rslt <> 0
         print $Rate_Rslt        (,{Col_ED_Rate})
      else
         print ' '        (,{Col_ED_Rate})
      end-if

      if #Unit_Rslt <> 0
         print $Unit_Rslt        (,{Col_ED_Unit})
      else
         print ' '        (,{Col_ED_Unit})
      end-if

      print $Ern_Ded_Slice_End                (+1,{Col_ED_Slice_Dates})
      print $UserKey3                         (,{Col_ED_Field135})
      print $UserKey4                         (,{Col_ED_Field246})

      if #Calc_Adj <> 0
         print $Calc_Adj         (,{Col_ED_Amt})
      else
        print ' '               (,{Col_ED_Amt})
      end-if

      if #Base_Adj <> 0
         print $Base_Adj         (,{Col_ED_Base})
      else
         print ' '        (,{Col_ED_Base})
      end-if

      if #Pct_Rslt <> 0
         print $Pct_Rslt         (,{Col_ED_Rate})
      else
         print  ' '         (,{Col_ED_Rate})
      end-if

      if #Unit_Adj <> 0
         print $Unit_Adj         (,{Col_ED_Unit})
      else
         print ' '        (,{Col_ED_Unit})
      end-if

      let $UserKey5 = rtrim($UserKey5,' ')
      let $UserKey6 = rtrim($UserKey6,' ')
      if $UserKey5 = ''
         if $UserKey6 = ''
         else
            print $UserKey6 (+1,{Col_ED_Field246})
         end-if
      else
         print $UserKey5 (+1, {Col_ED_Field135})
         print $UserKey6 (,   {Col_ED_Field246})
      end-if
      print ' ' (+1,1)

   else
      print $Ern_Ded_PIN_Name         (,{Col_Sort_Label1})

      if #Calc_Rslt <> 0
         print $Calc_Rslt        (,{Col_SUM_Amt})
      else
         print ' '       (,{Col_SUM_Amt})
      end-if

      if #Calc_Adj <> 0
         print $Calc_Adj         (,{Col_SUM_Amt_Adj})
      else
         print ' '         (,{Col_SUM_Amt_Adj})
      end-if

      if #Unit_Rslt <> 0
         print $Unit_Rslt        (,{Col_SUM_Unit})
      else
         print ' '       (,{Col_SUM_Unit})
      end-if

      if #Unit_Adj <> 0
         print $Unit_Adj         (,{Col_SUM_Unit_Adj})
      else
         print ' '         (,{Col_SUM_Unit_Adj})
      end-if

   end-if

end-procedure ! Print-Ern-Ded-Info


!***********************************************************************
! Print-Ern-Ded-Header                                                 *
!                                                                      *
! Called By:    Print-Ern-Ded-Info                                     *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Prints "Earnings and Deductions" section header.       *
!               Manages page Breaking for "Earnings and Deductions"    *
!               section.                                               *
!***********************************************************************

begin-procedure Print-Ern-Ded-Header

#ifdef debugw
    Show 'Inside procedure Print-Ern-Ded-Header'
#end-if

#ifdef debugy
   show '$Tot_lbl ' $Tot_lbl
   show '$First_Section ' $First_Section
#end-if

!***********************************************************************
! if beginning a new report section, do not print a section header and *
! only one row of information on a page.  if this is the case, start a *
! new page, then print the header & body.                              *
!***********************************************************************

    if #Current-Line + 6 > #Maxlines
          New-Page
    end-if

    if $Rpt_Type = '30' and $First_Section = 'Y'
    !   new-page
       print $Tot_lbl                  (+2,{Col_Sort_Label1}) Bold
    end-if

    if $SectType = 'E'
       if $First_Section = 'Y' and $Rpt_Type <> '30'
          print $ErnTitle              (+1,{Col_Sort_Label1})  Bold
       else
          print $ErnTitle              (+2,{Col_Sort_Label1})  Bold
       end-if
    else
       if $First_Section = 'Y' and $Rpt_Type <> '30'
          print $DedTitle              (+1,{Col_Sort_Label1})  Bold
       else
          print $DedTitle              (+2,{Col_Sort_Label1})  Bold
       end-if
    end-if

    let $First_Section = 'N'

    if $Rpt_Type = '10'
       print $Elem_Nm_lbl              (+2,{Col_Sort_Label1})
       print $Instance_lbl             (,  {Col_ED_Instance})
       print $Slice_Dt_lbl             (,  {Col_ED_Slice_Dates})
       print $Field135_lbl             (,  {Col_ED_Field135})
       print $Field246_lbl             (,  {Col_ED_Field246})
       print $Amt_Adj_lbl              (,  {Col_ED_Amt_lbl})
       print $Base_Adj_lbl             (,  {Col_ED_Base_lbl})
       print $Rate_lbl                 (,  {Col_ED_Rate_lbl})
       print $Unit_Adj_lbl             (,  {Col_ED_Unit_lbl})
       print $Source_lbl               (,  {Col_ED_Source_lbl})
       Graphic (, 2, 180) Horz-Line
    else
       print $Elem_Nm_lbl              (+2,{Col_Sort_Label1})
       print $Sum_Amt_lbl              (,{Col_SUM_Amt_Lbl})
       print $Sum_Adj_lbl              (,{Col_SUM_Adj_lbl})
       print $Sum_Unit_lbl             (,{Col_SUM_Unit_lbl})
       print $Sum_Unit_Adj_lbl         (,{Col_SUM_Unit_Adj_lbl})
       Graphic (,2,180) Horz-line
    end-if

!***********************************************************************
! if no earnings or deductions rows found, print message, "No earnings *
!     or deductions this segment."                                     *
!***********************************************************************

    if #ErnDed_Rows_Found = 0
        print $NoSegMsg            (+2,{Col_Sort_Value1})
    end-if

end-procedure ! Print-Ern-Ded-Header


!***********************************************************************
! Get-Rslt-Accum                                                       *
!                                                                      *
! Called By:    Get-Seg-Info                                           *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               Read-Translate-Table                                   *
!               print-Rslt-Accum                                       *
!                                                                      *
! Description:  Retrieves accumulators info.  Manages "Accumulators"   *
!               section header Printing.                               *
!***********************************************************************

begin-procedure Get-Rslt-Accum

#ifdef debugw
    Show 'Inside procedure Get-Rslt-Accum'
#end-if

    let $Accum_FirstTimethru = 'Y'
    let #Accum_Rows_Found    =  0

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Rslt-Accum'
#end-if

DTLAC.EMPLID            &DTLAC.EMPLID
DTLAC.CAL_RUN_ID        &DTLAC.CAL_RUN_ID
DTLAC.EMPL_RCD          &DTLAC.EMPL_RCD
DTLAC.GP_PAYGROUP       &DTLAC.GP_PAYGROUP
DTLAC.CAL_ID            &DTLAC.CAL_ID
DTLAC.RSLT_SEG_NUM      &DTLAC.RSLT_SEG_NUM
DTLAC.PIN_NUM           &DTLAC.PIN_NUM
DTLAC.ACM_FROM_DT       &DTLAC.ACM_FROM_DT
DTLAC.ACM_THRU_DT       &DTLAC.ACM_THRU_DT
DTLAC.USER_KEY1         &DTLAC.USER_KEY1
DTLAC.USER_KEY2         &DTLAC.USER_KEY2
DTLAC.USER_KEY3         &DTLAC.USER_KEY3
DTLAC.USER_KEY4         &DTLAC.USER_KEY4
DTLAC.USER_KEY5         &DTLAC.USER_KEY5
DTLAC.USER_KEY6         &DTLAC.USER_KEY6
DTLAC.SLICE_BGN_DT      &DTLAC.SLICE_BGN_DT
DTLAC.SLICE_END_DT      &DTLAC.SLICE_END_DT
DTLAC.USER_ADJ_VAL      &DTLAC.USER_ADJ_VAL
DTLAC.CALC_RSLT_VAL     &DTLAC.CALC_RSLT_VAL
DTLAC.ACM_PRD_OPTN      &DTLAC.ACM_PRD_OPTN
DTLAC.PIN_NM            &DTLAC.PIN_NM
DTLAC.PIN_TYPE          &DTLAC.PIN_TYPE

    let $Date10 = &DTLAC.ACM_FROM_DT
    do Format-DateTime($Date10, $out10, {DEFDATE}, '', '')

    let $Date11 = &DTLAC.ACM_THRU_DT
    do Format-DateTime($Date11, $out11, {DEFDATE}, '', '')

    let $Date12 = &DTLAC.SLICE_BGN_DT
    do Format-DateTime($Date12, $out12, {DEFDATE}, '', '')

    let $Date13 = &DTLAC.SLICE_END_DT
    do Format-DateTime($Date13, $out13, {DEFDATE}, '', '')

    let #Acc_Rslt_Val = &DTLAC.CALC_RSLT_VAL + &DTLAC.USER_ADJ_VAL
    do Format-Number(#Acc_Rslt_Val, $Acc_Rslt_Val, $AmtMask)

    let #Acc_Adj_Val = &DTLAC.USER_ADJ_VAL
    do Format-Number(#Acc_Adj_Val,  $Acc_Adj_Val,  $AmtMask)

    let #Accum_PIN_Num          = &DTLAC.PIN_NUM
    let $Accum_From_Dt          = $out10
    let $Accum_Thru_Dt          = $out11
    let $User_Key1              = &DTLAC.USER_KEY1
    let $User_Key2              = &DTLAC.USER_KEY2
    let $User_Key3              = &DTLAC.USER_KEY3
    let $User_Key4              = &DTLAC.USER_KEY4
    let $User_Key5              = RTRIM(&DTLAC.USER_KEY5,' ')
    let $User_Key6              = RTRIM(&DTLAC.USER_KEY6,' ')
    let $Accum_Slice_Begin_Dt   = $out12
    let $Accum_Slice_End_Dt     = $out13

    let $Accum_PIN_Name         = &DTLAC.PIN_NM

    if $curr_language_cd <> $Psoptions_Language_Cd
        let #PIN_Num             = #Accum_PIN_Num
        do exchange-pin-name
        if $PIN_Name <> ''
           let $Accum_PIN_Name      = $PIN_Name
        end-if
    end-if

    let $FieldName = 'ACM_PRD_OPTN'
    let $FieldValue = &DTLAC.ACM_PRD_OPTN
    do Read-Translate-Table
    let $AcmPeriod               = $XlatLongName

    let #Accum_Rows_Found = #Accum_Rows_Found + 1

    do print-Rslt-Accum

    let $Accum_FirstTimethru = 'N'
    let $FirstTimeThru = 'N'

FROM PS_GP_RGST_DTL_TMP DTLAC
WHERE DTLAC.PROCESS_INSTANCE = #prcs_process_instance - 1
  AND DTLAC.PIN_TYPE         = 'AC'
  AND DTLAC.EMPLID           = $Emplid
  AND DTLAC.EMPL_RCD         = #Empl_Rec
  AND DTLAC.CAL_RUN_ID       = $Cal_Run_ID
  AND DTLAC.ORIG_CAL_RUN_ID  = $Orig_Cal_Run_ID
  AND DTLAC.CAL_ID           = $Cal_ID
  AND DTLAC.GP_PAYGROUP      = $Paygroup
  AND DTLAC.RSLT_SEG_NUM     = #Seg_Num
  AND (DTLAC.GP_RGST_SECT_TYPE = '30' OR (DTLAC.GP_RGST_SECT_TYPE = '50' AND DTLAC.PIN_TYPE = 'AC'))
ORDER BY DTLAC.PIN_NM, DTLAC.ACM_FROM_DT, DTLAC.SLICE_BGN_DT

end-Select

    if #Accum_Rows_Found = 0
        do Print-Rslt-Accum-Header
    end-if

end-procedure ! Get-Rslt-Accum

!***********************************************************************
!                                                                      *
! Print-Rslt-Accum                                                     *
!                                                                      *
!                                                                      *
! Called By:    Get-Rslt-Accum                                         *
!                                                                      *
! Calls:        print-Rslt-Accum-Header                                *
!                                                                      *
! Description:  Prints body of "Accumulators" section.  Manages        *
!               "Accumulators" section header Printing.  Manages page  *
!               Breaking within the body of "Accumulators" section.    *
!                                                                      *
!***********************************************************************

begin-procedure Print-Rslt-Accum

#ifdef debugw
    Show 'Inside procedure Print-Rslt-Accum'
#end-if

!***********************************************************************
!                                                                      *
! Make sure that a single row of retrieved information, which Prints   *
!   as two lines on the report, is not split so that the first line is *
!   on one page and the second line is on the other.  if this is the   *
!   case, start a new page so that both lines print on the new page.   *
!                                                                      *
!***********************************************************************

    if #current-line + 3 > #Maxlines
        new-page
        let $Accum_FirstTimethru = 'Y'
    end-if

    if $Accum_FirstTimethru = 'Y'
        do print-Rslt-Accum-Header
    end-if

    Position (+1)

    print $Accum_PIN_Name         (,{Col_Sort_Label1})
    print $Accum_From_Dt          (,{Col_ACM_From_To})
    print $User_Key1              (,{Col_ACM_Key1})
    print $User_Key2              (,{Col_ACM_Key2})
    print $Accum_Slice_Begin_Dt   (,{Col_ACM_Slice_Dates})

!***********************************************************************
!                                                                      *
! do not print the value of a field if it is zero.                     *
!                                                                      *
!***********************************************************************

    if #Acc_Rslt_Val <> 0
       print $Acc_Rslt_Val          (,{Col_ACM_Value})
    end-if

    if #Acc_Adj_Val <> 0
       print $Acc_Adj_Val          (  ,{Col_ACM_Adjust})
    end-if

    print $AcmPeriod              (,  {Col_ACM_Period})
    print $Accum_Thru_Dt          (+1,{Col_ACM_From_To})
    print $User_Key3              (,  {Col_ACM_Key1})
    print $User_Key4              (,  {Col_ACM_Key2})
    print $Accum_Slice_End_Dt     (,  {Col_ACM_Slice_Dates})

    if $User_Key5 = ''
       if $User_Key6 = ''
       else
          print $User_Key6 (+1,{Col_ACM_Key2})
       end-if
    else
       print $User_Key5 (+1, {Col_ACM_Key1})
       print $User_Key6 (,   {Col_ACM_Key2})
    end-if

    Position (+1)

end-procedure ! Print-Rslt-Accum


!***********************************************************************
! Print-Rslt-Accum-Header                                              *
!                                                                      *
! Called By:    Print-Rslt-Accum                                       *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Prints "Accumulators" section header.  Manages page    *
!               Breaking for "Accumulators" section.                   *
!***********************************************************************

begin-procedure Print-Rslt-Accum-Header

#ifdef debugw
        Show 'Inside procedure print-Rslt-Accum-Header'
#end-if

!***********************************************************************
!                                                                      *
! if beginning a new report section, do not print a section header and *
!   only one row of information on a page.  if this is the case, start *
!   a new page, then print the header & body.                          *
!                                                                      *
!***********************************************************************

    if #current-line + 6 > #Maxlines
        New-Page
    end-if

    if $First_Section = 'Y'
       print $AcmTitle          (+1,{Col_Sort_Label1}) Bold
    else
       print $AcmTitle          (+2,{Col_Sort_Label1}) Bold
    end-if

    let $First_Section = 'N'

    print $Elem_Nm_lbl          (+2,{Col_Sort_Label1})

    print $From_To_lbl          (,{Col_ACM_From_To})
    print $Value_lbl            (,{Col_ACM_Value_lbl})
    print $Key1_lbl             (,{Col_ACM_Key1})
    print $Key2_lbl             (,{Col_ACM_Key2})
    print $Slice_Dt_lbl         (,{Col_ACM_Slice_Dates})
    print $Adj_lbl              (,{Col_ACM_Adjust_lbl})
    print $Prd_lbl              (,{Col_ACM_Period_lbl})
    Graphic (,2, 180) Horz-Line


!***********************************************************************
!                                                                      *
! if no accumulators rows found, print message, "No accumulators this  *
!     segment."                                                        *
!                                                                      *
!***********************************************************************

    if #Accum_Rows_Found = 0
        print $NoSegMsg         (+2,{Col_Sort_Value1})
    end-if

end-procedure ! Print-Rslt-Accum-Header

!***********************************************************************
! Get-Ded-Arrears                                                      *
!                                                                      *
! Called By:    Get-Seg-Info                                           *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               print-Ded-Arrears                                      *
!                                                                      *
! Description:  Retrieves arrears info.  Manages "Arrears" section     *
!               header Printing.                                       *
!***********************************************************************

begin-procedure Get-Ded-Arrears

#ifdef debugw
    Show 'Inside procedure Get-Ded-Arrears'
#end-if

    let $Arr_FirstTimethru = 'Y'
    let #Arr_Rows_Found    =  0
    let $Arrears_Printed   = 'F'

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Ded-Arrears'
#end-if

DTLAR.PIN_NUM                     &DTLAR.PIN_NUM
DTLAR.INSTANCE                    &DTLAR.INSTANCE
DTLAR.SLICE_BGN_DT                &DTLAR.SLICE_BGN_DT
DTLAR.SLICE_END_DT                &DTLAR.SLICE_END_DT
DTLAR.CALC_RSLT_VAL               &DTLAR.CALC_RSLT_VAL
DTLAR.RSLT_NOT_TKN                &DTLAR.RSLT_NOT_TKN
DTLAR.RSLT_PAYBK                  &DTLAR.RSLT_PAYBK
DTLAR.RSLT_ADD_ARR                &DTLAR.RSLT_ADD_ARR
DTLAR.PIN_NM                      &DTLAR.PIN_NM
DTLAR.CALC_ADJ_VAL                &DTLAR.CALC_ADJ_VAL


    let $Date14 = &DTLAR.SLICE_BGN_DT
    do Format-DateTime($Date12, $out14, {DEFDATE}, '', '')

    let $Date15 = &DTLAR.SLICE_END_DT
    do Format-DateTime($Date13, $out15, {DEFDATE}, '', '')

    let #Arr_Rslt_Val = &DTLAR.CALC_RSLT_VAL
    do Format-Number(#Arr_Rslt_Val, $Arr_Rslt_Val, $AmtMask)

    let #Arr_Not_Tkn = &DTLAR.RSLT_NOT_TKN
    do Format-Number(#Arr_Not_Tkn,  $Arr_Not_Tkn,  $AmtMask)

    let #Arr_Pybk = &DTLAR.RSLT_PAYBK
    do Format-Number(#Arr_Pybk,     $Arr_Pybk,     $AmtMask)

    let #Arr_Add = &DTLAR.RSLT_ADD_ARR
    do Format-Number(#Arr_Add,      $Arr_Add,      $AmtMask)

    let #Arr_Adj_Val = &DTLAR.CALC_ADJ_VAL
    do Format-Number(#Arr_Adj_Val,  $Arr_Adj_Val,  $AmtMask)

    let #Arrears_PIN_Num            = &DTLAR.PIN_NUM
    let #Arrears_Instance_Num       = &DTLAR.INSTANCE
    let $Arrears_Slice_Begin        = $out14
    let $Arrears_Slice_End          = $out15
    let $Arrears_PIN_Name           = &DTLAR.PIN_NM

    if $curr_language_cd <> $Psoptions_Language_Cd
        let #PIN_Num             = #Arrears_PIN_Num
        do exchange-pin-name
        if $PIN_Name <> ''
           let $Arrears_PIN_Name    = $PIN_Name
        end-if
    end-if

!***********************************************************************
!                                                                      *
! print Arrears rows only if there is actually a non-zero amount in    *
!   the fields that print on the report in columns "Amount Not Taken", *
!   "Payback Amount", or "Amount to Arrears", respectively.            *
!                                                                      *
!***********************************************************************

    if #Arr_Not_Tkn <> 0
       if $Arrears_Printed = 'F'
          let #Arr_Rows_Found  = #Arr_Rows_Found + 1
          let $Arrears_Printed = 'T'
          do print-Ded-Arrears
       end-if
    end-if

    if #Arr_Pybk <> 0
       if $Arrears_Printed = 'F'
          let #Arr_Rows_Found  = #Arr_Rows_Found + 1
          let $Arrears_Printed = 'T'
          do print-Ded-Arrears
       end-if
    end-if

    if #Arr_Add <> 0
       if $Arrears_Printed = 'F'
          let #Arr_Rows_Found  = #Arr_Rows_Found + 1
          let $Arrears_Printed = 'T'
          do print-Ded-Arrears
       end-if
    end-if

    if &DTLAR.RSLT_NOT_TKN <> 0 Or
       &DTLAR.RSLT_PAYBK   <> 0 Or
       &DTLAR.RSLT_ADD_ARR <> 0
       do get-arrears-balance
    end-if

   let $Arrears_Printed   = 'F'       !   reset to print > 1 arrear

FROM PS_GP_RGST_DTL_TMP DTLAR
WHERE DTLAR.PROCESS_INSTANCE = #prcs_process_instance - 1
  AND DTLAR.PIN_TYPE='DD'
  AND DTLAR.EMPLID           = $Emplid
  AND DTLAR.EMPL_RCD         = #Empl_Rec
  AND DTLAR.CAL_RUN_ID       = $Cal_Run_ID
  AND DTLAR.ORIG_CAL_RUN_ID  = $Orig_Cal_Run_ID
  AND DTLAR.CAL_ID           = $Cal_ID
  AND DTLAR.GP_PAYGROUP      = $Paygroup
  AND DTLAR.RSLT_SEG_NUM     = #Seg_Num
  AND (DTLAR.GP_RGST_SECT_TYPE = '40' OR (DTLAR.GP_RGST_SECT_TYPE = '50' AND DTLAR.PIN_TYPE = 'DD'))
  AND (DTLAR.RSLT_NOT_TKN <> 0 OR DTLAR.RSLT_PAYBK <> 0 OR DTLAR.RSLT_ADD_ARR <> 0)
ORDER BY DTLAR.PIN_NM
end-Select

    if #Arr_Rows_Found = 0
        do print-Ded-Arrears-Header
    end-if

end-procedure ! Get-Ded-Arrears


!***********************************************************************
! Print-Ded-Arrears                                                    *
!                                                                      *
! Called By:    Get-Ded-Arrears                                        *
!                                                                      *
! Calls:        print-Ded-Arrears-Header                               *
!                                                                      *
! Description:  Prints body of "Arrears" section.  Manages             *
!               "Arrears" section header Printing.  Manages page       *
!               Breaking within the body of "Arrears" section.         *
!***********************************************************************

begin-procedure Print-Ded-Arrears

#ifdef debugw
    Show 'Inside procedure Print-Ded-Arrears'
#end-if

!***********************************************************************
!                                                                      *
! Make sure that a single row of retrieved information, which Prints   *
! as two lines on the report, is not split so that the first line is   *
! on one page and the second line is on the other.  if this is the     *
! case, start a new page so that both lines print on the new page.     *
!                                                                      *
!***********************************************************************

    if #current-line + 2 > #Maxlines
        New-Page
        let $Arr_FirstTimethru = 'Y'
    end-if

    if $Arr_FirstTimethru = 'Y'
        do Print-Ded-Arrears-Header
    end-if

    print $Arrears_PIN_Name                 (+1,{Col_Sort_Label1})
    print #Arrears_Instance_Num             (,{Col_ARR_Instance})           Edit 999
    print $Arrears_Slice_Begin              (,{Col_ARR_Slice_Dates})

    if #Arr_Rslt_Val <> 0
       print $Arr_Rslt_Val    (,{Col_ARR_Amt_Adj})
    end-if

    if #Arr_Not_Tkn <> 0
       print $Arr_Not_Tkn  (,{Col_ARR_Not_Taken})
    end-if

    if #Arr_Pybk <> 0
       print $Arr_Pybk (,{Col_ARR_Payback})
    end-if

    if #Arr_Add <> 0
       print $Arr_Add  (,{Col_ARR_Arrears})
    end-if

    print $Arrears_Slice_End                (+1,{Col_ARR_Slice_Dates})

    if #Arr_Adj_Val <> 0
       print $Arr_Adj_Val     (,{Col_ARR_Amt_Adj})
    end-if

    let $Arr_FirstTimethru = 'N'

end-procedure ! Print-Ded-Arrears


begin-procedure Get-Arrears-Balance

#ifdef debugw
    Show 'Inside procedure Get-Arrears-Balance'
#end-if

begin-Select
#ifdef debugw
    Show 'Inside SELECT, procedure Get-Arrears-Balance'
#end-if
CMPNT2.PIN_ARR_ACM_NUM           &CMPNT2.PIN_ARR_ACM_NUM

     do Format-Arrears-Balance

FROM PS_GP_PIN_CMPNT CMPNT2
WHERE CMPNT2.PIN_NUM = &DTLAR.PIN_NUM
end-Select

end-procedure !Get-Arrears-Balance


begin-procedure Format-Arrears-Balance

#ifdef debugw
    Show 'Inside procedure Format-Arrears-Balance'
#end-if

begin-Select
#ifdef debugw
    Show 'Inside SELECT, procedure Format-Arrears-Balance'
#end-if
DTLAR2.CALC_RSLT_VAL  &DTLAR2.CALC_RSLT_VAL

   do Format-Number(&DTLAR2.CALC_RSLT_VAL, $Arr_Bal, $AmtMask)
   print $Arr_Bal    (-1,{Col_ARR_Balance})   ! print arrears balance on the same line, last column
   print ' '         (+1,0)

FROM PS_GP_RGST_DTL_TMP DTLAR2
WHERE DTLAR2.EMPLID        = $Emplid
  AND DTLAR2.CAL_RUN_ID    = $Cal_Run_ID
  AND DTLAR2.EMPL_RCD      = #Empl_Rec
  AND DTLAR2.GP_PAYGROUP   = $Paygroup
  AND DTLAR2.CAL_ID        = $Cal_ID
  AND DTLAR2.RSLT_SEG_NUM  = #Seg_Num
  AND DTLAR2.PIN_NUM       = &CMPNT2.PIN_ARR_ACM_NUM
  AND DTLAR2.PROCESS_INSTANCE = #prcs_process_instance - 1
end-Select


end-procedure ! Format-Arrears-Balance

!***********************************************************************
! Print-Ded-Arrears-Header                                             *
!                                                                      *
! Called By:    print-Ded-Arrears                                      *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Prints "Arrears" section header.  Manages page         *
!               Breaking for "Arrears" section.                        *
!***********************************************************************

begin-procedure Print-Ded-Arrears-Header

#ifdef debugw
     Show 'Inside procedure Print-Ded-Arrears-Header'
#end-if

!***********************************************************************
!                                                                      *
! if beginning a new report section, do not print a section header and *
!   only one row of information on a page.  if this is the case, start *
!   a new page, then print the header & body.                          *
!                                                                      *
!***********************************************************************

    if #current-line + 6 > #Maxlines
        New-Page
    end-if

    print $ArrTitle                     (+2,{Col_Sort_Label1})    Bold
    print $Elem_Nm_lbl                  (+2,{Col_Sort_Label1})
    print $Instance_lbl                 (,  {Col_ARR_Instance})
    print $Slice_Dt_lbl                 (,  {Col_ARR_Slice_Dates})
    print $Amt_Adj_lbl                  (  ,{Col_ARR_Amt_Adj_lbl})
    print $Amt_Not_Taken_lbl            (,  {Col_ARR_Not_Taken_lbl})
    print $Paybk_Amt_lbl                (,  {Col_ARR_Payback_lbl})
    print $Amt_To_Arrears_lbl           (,  {Col_ARR_Arrears_lbl})
    print $Arr_Bal_lbl                  (,  {Col_ARR_Balance_lbl})
    Graphic (, 2, 180) Horz-Line

!***********************************************************************
!                                                                      *
! if no arrears rows found, print message, "No arrears this segment."  *
!                                                                      *
!***********************************************************************

    if #Arr_Rows_Found = 0
        print $NoSegMsg               (+2,{Col_Sort_Value1})
    end-if

end-procedure ! Print-Ded-Arrears-Header


!******************************** Organizational Summary Report ******************


!***********************************************************************
! Prcs-Org-Summary                                                     *
!                                                                      *
! Called By:    Process-Main                                           *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Creates the Summary Report                             *
!***********************************************************************

begin-procedure Prcs-Org-Summary
#ifdef debugw
    Show 'Inside procedure Prcs-Org-Summary'
#end-if
  do Init-Rep-Sum
  do Process-Main-OrgSum

end-procedure Prcs-Empl-Summary


begin-procedure Init-Rep-Sum

#ifdef debugw
   show 'Inside procedure Init-Rep-Sum'
#end-if

!***********************************************************************
!                                                                      *
! Various report variables.                                            *
!                                                                      *
!***********************************************************************

    let $ReportTitle            = $GPUSPY03_Title     ! Printed in header
    let $ReportDate             = $ReportDate         ! Printed in header
    let $ReportTime             = $ReportTime         ! Printed in header
    let $Report_Language        = $curr_language_cd   ! curr_language_cd resolved in prcslng.sqc
    let #Maxlines               = 55                  ! # rows on a page, used for page Breaking
    let $FirstTimeThru          = 'Y'                 ! Used for page Breaking
    let #Current_Seg_Num        = #Last_Seg_Num       ! Used for page Breaking
    let $Page_Break_Indicator   = 'Totals'            ! Used for page Breaking
    let #Max_Array_Init         = 50

!***********************************************************************
!                                                                      *
! Dates:   All of Europe uses date format DD/MM/YYYY                   *
!          The US uses date format of MM/DD/YYYY                       *
!                                                                      *
! Numbers: The U.S. and the U.K. use NN,NNN.NN                         *
!          The rest of Europe uses NN.NNN,NN                           *
!                                                                      *
!***********************************************************************

    if $curr_language_cd      = 'ENG'
        let $ReportDateType   = '0'             ! resolved in datetime.sqc
    else
        let $ReportDateType   = '1'
    end-if

!***********************************************************************
!                                                                      *
! Initialize date formatting.                                          *
!                                                                      *
!***********************************************************************

    let $Date_Init = '1900-01-01 00:00:00.000'

        #ifdef ORACLE
            let $Date_Init = '01-NOV-99'
        #end-if

    do Format-DateTime($Date_Init, $out999, {DEFDATE}, '', '')

    let $DynPrefix = 'SMG'
    do Build-Dynamic-Select-Fields

!***********************************************************************
!                                                                      *
! Create arrays for all levels of totalling.                           *
!                                                                      *
!***********************************************************************

    do Create-All-Arrays

end-procedure ! Init-report-Sum


begin-procedure Create-All-Arrays


#ifdef debugw
        Show 'Inside procedure Create-All-Arrays'
#end-if


#define max_array_size 10000     ! if increasing max_array_size, be sure to increase #Max_Array_Init

 if #CalGrp_sort <> 0
    create-array
        name  = CalGrp_Ern_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number

    create-array
        name  = CalGrp_Ded_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number
 end-if

 if #PayEnt_Sort <> 0
    create-array
        name  = PayEnt_Ern_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number

    create-array
        name  = PayEnt_Ded_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number
 end-if

 if #PayGrp_Sort <> 0
    create-array
            name  = PayGrp_Ern_Totals
            size  = {max_array_size}
            field = PIN_Num:number
            field = PIN_Name:char
            field = Units:number
            field = Amount:number
            field = Units_Adj:number
            field = Amount_Adj:number

        create-array
            name  = PayGrp_Ded_Totals
            size  = {max_array_size}
            field = PIN_Num:number
            field = PIN_Name:char
            field = Units:number
            field = Amount:number
            field = Units_Adj:number
        field = Amount_Adj:number
 end-if

 if #Comp_Sort <> 0
      create-array
          name  = Comp_Ern_Totals
          size  = {max_array_size}
          field = PIN_Num:number
          field = PIN_Name:char
          field = Units:number
          field = Amount:number
          field = Units_Adj:number
          field = Amount_Adj:number

      create-array
          name  = Comp_Ded_Totals
          size  = {max_array_size}
          field = PIN_Num:number
          field = PIN_Name:char
          field = Units:number
          field = Amount:number
          field = Units_Adj:number
          field = Amount_Adj:number
  end-if

 if #Dept_Sort <> 0
    create-array
        name  = Dept_Ern_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number

    create-array
        name  = Dept_Ded_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number
  end-if

  if #Locn_Sort <> 0
     create-array
         name  = Locn_Ern_Totals
         size  = {max_array_size}
         field = PIN_Num:number
         field = PIN_Name:char
         field = Units:number
         field = Amount:number
         field = Units_Adj:number
         field = Amount_Adj:number

     create-array
         name  = Locn_Ded_Totals
         size  = {max_array_size}
         field = PIN_Num:number
         field = PIN_Name:char
         field = Units:number
         field = Amount:number
         field = Units_Adj:number
         field = Amount_Adj:number
  end-if

  if #RunType_sort <> 0
     create-array
          name  = RunType_Ern_Totals
          size  = {max_array_size}
          field = PIN_Num:number
          field = PIN_Name:char
          field = Units:number
          field = Amount:number
          field = Units_Adj:number
          field = Amount_Adj:number

      create-array
          name  = RunType_Ded_Totals
          size  = {max_array_size}
          field = PIN_Num:number
          field = PIN_Name:char
          field = Units:number
          field = Amount:number
          field = Units_Adj:number
          field = Amount_Adj:number
  end-if

  if #estab_sort <> 0
       create-array
            name  = Estab_Ern_Totals
            size  = {max_array_size}
            field = PIN_Num:number
            field = PIN_Name:char
            field = Units:number
            field = Amount:number
            field = Units_Adj:number
            field = Amount_Adj:number

        create-array
            name  = Estab_Ded_Totals
            size  = {max_array_size}
            field = PIN_Num:number
            field = PIN_Name:char
            field = Units:number
            field = Amount:number
            field = Units_Adj:number
            field = Amount_Adj:number
  end-if

  if #curr_sort <> 0
     create-array
         name  = Curr_Ern_Totals
         size  = {max_array_size}
         field = PIN_Num:number
         field = PIN_Name:char
         field = Units:number
         field = Amount:number
         field = Units_Adj:number
         field = Amount_Adj:number

     create-array
        name  = Curr_Ded_Totals
        size  = {max_array_size}
        field = PIN_Num:number
        field = PIN_Name:char
        field = Units:number
        field = Amount:number
        field = Units_Adj:number
        field = Amount_Adj:number
  end-if

end-procedure !Create-All-Arrays


begin-procedure Process-Main-OrgSum

 #ifdef debugw
   show 'Inside procedure Process-Main-OrgSum'
 #end-if
 let $DynPrefix = 'SMG'
 let $ClauseType = 'O'
 do Build-Dynamic-Clause
 let $Order_By_Clause = $DynClause

 let $DynPrefix = 'SMED'
 do Build-Dynamic-Clause
 let $Order_By_Clause2 = $DynClause

 let #ErnDed_Rows_Found    =  0
 let #rows_selected = 0

begin-Select Distinct
#ifdef debugw
    Show 'Inside SELECT, procedure Process-Main-OrgSum'
#end-if
[$Sel_CalGrp]           &SMG.CAL_RUN_ID=char
[$Sel_PayEnt]           &SMG.PAY_ENTITY=char
[$Sel_PayGrp]           &SMG.GP_PAYGROUP=char
[$Sel_Comp]             &SMG.COMPANY=char
[$Sel_Dept]             &SMG.DEPTID=char
[$Sel_Locn]             &SMG.LOCATION=char
[$Sel_Estab]            &SMG.ESTABID=char
[$Sel_RunType]          &SMG.RUN_TYPE=char
[$Sel_Curr]             &SMG.CURRENCY_CD=char

!***********************************************************************
!                                                                      *
! Format-DateTime formats dates.  The format is controlled by          *
!   $ReportDateType which is conditionally set earlier in the report.  *
!                                                                      *
!***********************************************************************

    if $Sel_CalGrp <> ''
       let $Cal_Run_ID         = rtrim(&SMG.CAL_RUN_ID,' ')
    end-if

    if $Sel_PayEnt <> ''
       let $Pay_Entity         = rtrim(&SMG.PAY_ENTITY,' ')
    end-if

    if $Sel_PayGrp <> ''
       let $Paygroup           = rtrim(&SMG.GP_PAYGROUP,' ')
    end-if

    if $Sel_Comp <> ''
       let $Company            = rtrim(&SMG.COMPANY,' ')
    end-if

    if $Sel_Dept <> ''
       let $Department         = rtrim(&SMG.DEPTID,' ')
    end-if

    if $Sel_Locn <> ''
       let $Location           = rtrim(&SMG.LOCATION,' ')
    end-if

    if $Sel_Estab <> ''
       let $Establishment      = rtrim(&SMG.ESTABID,' ')
    end-if

    if $Sel_RunType <> ''
       let $Run_Type           = rtrim(&SMG.RUN_TYPE,' ')
    end-if

    if $Sel_Curr <> ''
       let $Currency_Value        = rtrim(&SMG.CURRENCY_CD,' ')
    end-if

    do Get-Header-Descriptions

!***********************************************************************
!                                                                      *
!   On organizational change, print the info in the array, then clear  *
!   out in preparation for the next round of information.  This        *
!   is performed at all levels of totalling.                           *
!                                                                      *
!***********************************************************************

   if not(isnull($Last_Currency_Value))
      do Locate-Org-Break-Level
!      if $FirstTimeThru = 'Y'
!         new-page
!         let $FirstTimeThru = 'N'
!      end-if
   end-if

   let $DynPrefix = 'SMED'
   do Build-Sum-Where-Clause
   let $SumWhere = $DynClause

   if $PrintERN = 'Y'
      let $SectType = 'E'
      do Get-Rslt-Ern-Ded-Org
   end-if

   if $PrintDED = 'Y'
      let $SectType = 'D'
      do Get-Rslt-Ern-Ded-Org
   end-if


!***********************************************************************
!                                                                      *
! Keep track of previous segment information for purposes of writing   *
!   out headers.  This info is used in gprgsth2.sqc                    *
!                                                                      *
!***********************************************************************

    let $Last_Comp                  = $Company
    let $Last_Comp_descr            = $Comp_descr
    let $Last_PayEnt                = $Pay_Entity
    let $Last_PayEnt_descr          = $PayEnt_descr
    let $Last_CalGrp                = $Cal_Run_ID
    let $Last_CalGrp_descr          = $CalGrp_descr
    let $Last_Cal_ID                = $Cal_ID
    let $Last_PayGrp                = $PayGroup
    let $Last_PayGrp_Descr          = $PayGrp_descr
    let $Last_Dept                  = $Department
    let $Last_Dept_descr            = $Dept_descr
    let $Last_Estab                 = $Establishment
    let $Last_Locn                  = $Location
    let $Last_Estab_descr           = $Estab_descr
    let $Last_Locn_Descr            = $Locn_descr
    let $Last_RunType               = $Run_Type
    let $Last_RunType_Descr         = $RunType_Descr
    let $Last_Currency_Value        = $Currency_Value
    let $Last_Currency_Descr        = $Currency_Descr

    let #rows_selected = #rows_selected + 1

FROM PS_GP_RGST_GDE_TMP  SMG
WHERE SMG.PROCESS_INSTANCE = #prcs_process_instance - 1
[$Order_By_Clause]
end-Select

   if not #rows_selected
      #include 'gprgsth2.sqc'
      print $NoDataMsg   (+5,10)
   else
      let $End_Report = 'Y'
      let $Force_Break = 'Y'
      do Locate-Org-Break-Level
   end-if

end-procedure ! Process-Main-OrgSum

begin-procedure Check-Org-Sort-Sequence

#ifdef debugw
   show 'Inside Check-Org-Sort-Sequence'
#end-if

#ifdef debugy
     show '$Force_Break  ' $End_Report
     show '$Last_CalGrp  ' $Last_CalGrp
     show '$Cal_Run_Id   '  $Cal_Run_Id
     show '$Last_PayEnt  ' $Last_PayEnt
     show '$Pay_Entity   ' $Pay_Entity
     show '$Last_PayGrp  ' $Last_PayGrp
     show '$PayGroup     ' $PayGroup
     show '$Last_Dept    ' $Last_Dept
     show '$Department   ' $Department
     show '$Last_Estab   ' $Last_Estab
     show '$Establishment' $Establishment
     show '$Last_Locn    ' $Last_Locn
     show '$Location     ' $Location
     show '$Run_Type     ' $Run_Type
     show '$Last_RunType ' $Last_RunType
     show '$Last_Currency_value ' $Last_Currency_Value
     show '$Currency_value ' $Currency_Value
#end-if

   let #k = #max_sort

   while #k <> 0
      do Find-Org-Sort-Sequence
      let #k = #k - 1
   end-while

end-procedure ! Check-Org-Sort-Sequence

!***********************************************************************
! Find-Low-Level-Break                                                 *
!                                                                      *
!                                                                      *
! Description:  Finds the level at which the break occurred so that    *
!               all lower level break levels are processed             *
!***********************************************************************

begin-procedure Find-Low-Level-Break

#ifdef debugw
   show 'Inside procedure Find-Low-Level-Break'
#end-if

#ifdef debugy
     show '$End_Report   ' $End_Report
     show '$Last_CalGrp  ' $Last_CalGrp
     show '$Cal_Run_Id   '  $Cal_Run_Id
     show '$Last_PayEnt  ' $Last_PayEnt
     show '$Pay_Entity   ' $Pay_Entity
     show '$Last_PayGrp  ' $Last_PayGrp
     show '$PayGroup     ' $PayGroup
     show '$Last_Dept    ' $Last_Dept
     show '$Department   ' $Department
     show '$Last_Estab   ' $Last_Estab
     show '$Establishment' $Establishment
     show '$Last_Locn    ' $Last_Locn
     show '$Location     ' $Location
     show '$Last_RunType ' $Last_RunType
     show '$Run_Type     ' $Run_Type
     show '$Last_Currency_value ' $Last_Currency_Value
     show '$Currency_value ' $Currency_Value
#end-if

  let #l = #max_sort
  while #l >= 1

     if #CalGrp_Sort = #l
         if $Last_CalGrp <> $Cal_Run_ID
            break
          end-if
     end-if

     if #PayEnt_Sort = #l
        if $Last_PayEnt <> $Pay_Entity
           break
        end-if
     end-if

     if #PayGrp_Sort = #l
        if $Last_PayGrp <> $PayGroup
           break
        end-if
     end-if

     if #Comp_Sort = #l
        if $Last_Comp <> $Company
           break
         end-if
     end-if

     if #Dept_Sort = #l
        if $Last_Dept <> $Department
           break
        end-if
     end-if

     if #Locn_Sort = #l
        if $Last_Locn <> $Location
           break
        end-if
     end-if

     if #Estab_Sort = #l
        if $Last_Estab <> $Establishment
           break
        end-if
     end-if

     if #RunType_Sort = #l
        if $Last_RunType <> $Run_Type
            break
        end-if
     end-if

     if #Curr_Sort = #l
        if $Last_Currency_Value <> $Currency_Value
           break
        end-if
     end-if

     let #l = #l - 1
   end-while

#ifdef debugy
   show 'lowest break level #l ' #l
#end-if


end-procedure !Find-Low-Level-Break


!***********************************************************************
! Find-High-Level-Break                                                *
!                                                                      *
!                                                                      *
! Description:  Finds the level at which the break occurred so that    *
!               all lower level break levels are processed             *
!***********************************************************************

begin-procedure Find-High-Level-Break

#ifdef debugw
   show 'Inside procedure Find-High-Level-Break'
#end-if

#ifdef debugy
     show '$End_Report' $End_Report
     show '$Last_CalGrp  ' $Last_CalGrp
     show '$Cal_Run_Id   '  $Cal_Run_Id
     show '$Last_PayEnt  ' $Last_PayEnt
     show '$Pay_Entity   ' $Pay_Entity
     show '$Last_PayGrp  ' $Last_PayGrp
     show '$PayGroup     ' $PayGroup
     show '$Last_Dept    ' $Last_Dept
     show '$Department   ' $Department
     show '$Last_Estab   ' $Last_Estab
     show '$Establishment' $Establishment
     show '$Last_Locn    ' $Last_Locn
     show '$Location     ' $Location
     show '$Last_RunType ' $Last_RunType
     show '$Run_Type     ' $Run_Type
     show '$Last_Currency_value ' $Last_Currency_Value
     show '$Currency_value ' $Currency_Value
#end-if

   let #l = 1
   while #l <= #max_sort
     if #CalGrp_Sort = #l
         if $Last_CalGrp <> $Cal_Run_ID
            break
          end-if
     end-if

     if #PayEnt_Sort = #l
        if $Last_PayEnt <> $Pay_Entity
           break
        end-if
     end-if

     if #PayGrp_Sort = #l
        if $Last_PayGrp <> $PayGroup
           break
        end-if
     end-if

     if #Comp_Sort = #l
        if $Last_Comp <> $Company
           break
         end-if
     end-if

     if #Dept_Sort = #l
        if $Last_Dept <> $Department
           break
        end-if
     end-if

     if #Locn_Sort = #l
        if $Last_Locn <> $Location
           break
        end-if
     end-if

     if #Estab_Sort = #l
        if $Last_Estab <> $Establishment
           break
        end-if
     end-if

     if #RunType_Sort = #l
        if $Last_RunType <> $Run_Type
           break
        end-if
     end-if

     if #Curr_Sort = #l
        if $Last_Currency_Value <> $Currency_Value
           break
        end-if
     end-if

     let #l = #l + 1
   end-while

#ifdef debugy
   show 'lowest break level #l ' #l
#end-if


end-procedure !Find-High-Level-Break


begin-procedure Locate-Detail-Break-Level

#ifdef debugw
   show 'Inside procedure Locate-Detail-Break-Level'
#end-if

!**************************************************************************
!  If End of Report then start at the lowest level and force a break      *
!**************************************************************************

   if $End_Report = 'Y'
      let #l = 1
   else
      do Find-High-Level-Break
   end-if

   let #k = #Max_Sort
   let $Force_Break = 'Y'
   while #k >= #l
      do Find-Detail-Sort-Sequence
      let #k = #k - 1
   end-while

end-procedure ! Locate-Detail-Break-Level


begin-procedure Locate-Org-Break-Level

#ifdef debugw
   show 'Inside procedure Locate-Org-Break-Level'
#end-if
   if $End_Report = 'Y'
      let #l = 1
   else
      do Find-High-Level-Break
   end-if

   let #k = #Max_Sort
   let $Force_Break = 'Y'
   while #k >= #l
      do Find-Org-Sort-Sequence
      let #k = #k - 1
   end-while

end-procedure !Locate-Org-Break-Level

!***********************************************************************
! Find-Org-Sort-Sequence                                               *
!                                                                      *
!                                                                      *
! Description:  Finds the break level based on what changed or forces  *
!               break if the End of Report                             *
!***********************************************************************

begin-procedure Find-Org-Sort-Sequence

#ifdef debugw
  show 'Inside Find-Org-Sort-Sequence'
#end-if

   if #CalGrp_Sort = #k
      if $Last_CalGrp <> $Cal_Run_ID
             or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_CalGrp_lbl || ' ' || $Last_CalGrp || ' ' || $Last_CalGrp_Descr
         do Print-CalGrp-Totals
         let $CalGrp_Printed = 'Y'
         do Initialize-CalGrp-Arrays
      end-if
   end-if

   if #PayEnt_Sort = #k
      if $Last_PayEnt <> $Pay_Entity
            or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_PayEnt_lbl || ' ' || $Last_PayEnt || ' ' || $Last_PayEnt_Descr
         do Print-PayEnt-Totals
         let $PayEnt_Printed = 'Y'
         do Initialize-PayEnt-Arrays
      end-if
   end-if

   if #PayGrp_Sort = #k
      if $Last_PayGrp <> $PayGroup
            or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_PayGrp_lbl || ' ' || $Last_PayGrp || ' ' || $Last_PayGrp_Descr
         do Print-PayGrp-Totals
         let $PayGrp_Printed = 'Y'
         do Initialize-PayGrp-Arrays
      end-if
   end-if

   if #Comp_Sort = #k
      if $Last_Comp <> $Company
          or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_Comp_lbl || ' ' || $Last_Comp || ' ' || $Last_Comp_Descr
         do Print-Comp-Totals
         let $Comp_Printed = 'Y'
         do Initialize-Comp-Arrays
      end-if
   end-if

   if #Dept_Sort = #k
      if $Last_Dept <> $Department
            or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_Dept_lbl || ' ' || $Last_Dept || ' ' || $Last_Dept_Descr
         do Print-Dept-Totals
         let $Dept_Printed = 'Y'
         do Initialize-Dept-Arrays
      end-if
   end-if

   if #Locn_Sort = #k
      if $Last_Locn <> $Location
           or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_Locn_lbl || ' ' || $Last_Locn || ' ' || $Last_Locn_Descr
         do Print-Locn-Totals
         let $Locn_Printed = 'Y'
         do Initialize-Locn-Arrays
      end-if
   end-if

   if #Estab_Sort = #k
      if $Last_Estab <> $Establishment
          or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_Estab_lbl || ' ' || $Last_Estab || ' ' || $Last_Estab_Descr
         do Print-Estab-Totals
         let $Estab_Printed = 'Y'
         do Initialize-Estab-Arrays
      end-if
   end-if

   if #RunType_Sort = #k
      if $Last_RunType <> $Run_Type
             or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_RunType_lbl || ' ' || $Last_RunType || ' ' || $Last_RunType_Descr
         do Print-RunType-Totals
         let $RunType_Printed = 'Y'
         do Initialize-RunType-Arrays
      end-if
   end-if

   if #Curr_Sort = #k
      if $Last_Currency_value <> $Currency_Value
             or $Force_Break = 'Y'
         let $Tot_lbl = $Tot_Curr_lbl || ' ' || $Last_Currency_value || ' ' || $Last_Currency_Descr
         do Print-Curr-Totals
         let $Curr_Printed = 'Y'
         do Initialize-Curr-Arrays
      end-if
   end-if

end-procedure ! Find-Org-Sort-Sequence


!***********************************************************************
! Get-Rslt-Ern-Ded-Org                                                 *
!                                                                      *
! Called By:    Process-Main-Org                                       *
!                                                                      *
! Calls:        Format-DateTime                                        *
!               print-Ern-Ded-Info                                     *
!                                                                      *
! Description:  Retrieves earnings & deductions info.  Manages         *
!               "Earnings and Deductions" section header Printing.     *
!***********************************************************************

begin-procedure Get-Rslt-Ern-Ded-Org

#ifdef debugw
    Show 'Inside procedure Get-Rslt-Ern-Ded-Org'
#end-if
    if $SectType = 'E'
       let $EDWhere = $ERNWhere3
    end-if

    if $SectType = 'D'
       let $EDWhere = $DEDWhere3
    end-if

begin-Select

#ifdef debugw
    Show 'Inside SELECT, procedure Get-Rslt-Ern-Ded-Org'
#end-if
SMED.PIN_TYPE                 &SMED.PIN_TYPE
SMED.PIN_NM                   &SMED.PIN_NM
SMED.PIN_NUM                  &SMED.PIN_NUM
SUM(SMED.CALC_RSLT_VAL)       &SMED.CALC_RSLT_VAL
SUM(SMED.CALC_ADJ_VAL)        &SMED.CALC_ADJ_VAL
SUM(SMED.UNIT_RSLT_VAL)       &SMED.UNIT_RSLT_VAL
SUM(SMED.UNIT_ADJ_VAL)        &SMED.UNIT_ADJ_VAL

    let #Ern_Ded_PIN_Num        = &SMED.PIN_NUM
    let $Ern_Ded_PIN_Type       = &SMED.PIN_TYPE
    Let $Ern_Ded_PIN_Name       = &SMED.PIN_NM

    let #Calc_RsltIn = &SMED.CALC_RSLT_VAL
    let #Calc_AdjIn  = &SMED.CALC_ADJ_VAL
    let #Unit_Rslt   = &SMED.UNIT_RSLT_VAL
    let #Unit_Adj    = &SMED.UNIT_ADJ_VAL

    if $curr_language_cd <> $Psoptions_Language_Cd
      do Get-PIN-Name-Rel-Lang-Smry
    end-if

    let #ErnDed_Rows_Found    = #ErnDed_Rows_Found + 1

    if #CalGrp_Sort <> 0
       do Add-to-CalGrp-Array
    end-if

    if #PayEnt_Sort <> 0
       do Add-to-PayEnt-Array
    end-if

    if #PayGrp_Sort <> 0
       do Add-to-PayGrp-Array
    end-if

    if #Comp_Sort <> 0
       do Add-to-Comp-Array
    end-if

    if #Dept_Sort <> 0
       do Add-to-Dept-Array
    end-if

    if #Locn_Sort <> 0
       do Add-to-Locn-Array
    end-if

    if #Estab_Sort <> 0
       do Add-to-Estab-Array
    end-if

    if #RunType_Sort <> 0
       do Add-to-RunType-Array
    end-if

    if #Curr_Sort <> 0
       do Add-to-Curr-Array
    end-if

FROM PS_GP_RGST_DTL_TMP  SMED
WHERE SMED.PROCESS_INSTANCE = #prcs_process_instance - 1
  AND SMED.PIN_TYPE IN ('DD','ER')
  AND (SMED.CALC_RSLT_VAL <> 0 OR SMED.UNIT_RSLT_VAL <> 0
       OR SMED.UNIT_ADJ_VAL <> 0 OR SMED.CALC_ADJ_VAL <> 0)
  AND [$EDWhere]
[$SumWhere]
GROUP BY SMED.PIN_TYPE, SMED.PIN_NUM, SMED.PIN_NM
ORDER BY 1, 2
end-Select


end-procedure ! Get-Rslt-Ern-Ded-Org


!***********************************************************************
! Get-PIN-Name-Rel-Lang-Smry                                           *
!                                                                      *
! Called By:    Get-Rslt-Ern-Ded-Smry                                  *
!                                                                      *
! Calls:        none                                                   *
!                                                                      *
! Description:  Retrieve PIN Name related language entry.  Trim to fit *
!                   report.                                            *
!***********************************************************************

begin-procedure Get-PIN-Name-Rel-Lang-Smry

#ifdef debugw
    Show 'Inside procedure Get-PIN-Name-Rel-Lang-Smry'
#end-if

begin-Select
#ifdef debugw
    Show 'Inside SELECT, procedure Get-PIN-Name-Rel-Lang-Smry'
#end-if
PINLANGSM.PIN_NM  &PINLANGSM.PIN_NM

    let $Ern_Ded_PIN_Name     = &PINLANGSM.PIN_NM

    if length($Ern_Ded_PIN_Name) > 15
        let $Ern_Ded_PIN_Name = substr($Ern_Ded_PIN_Name,1,15)
    end-if

FROM PS_GP_PIN_LANG PINLANGSM
WHERE PINLANGSM.PIN_NUM     = #Ern_Ded_PIN_Num
  AND PINLANGSM.LANGUAGE_CD = $curr_language_cd
end-Select

end-procedure ! Get-PIN-Name-Rel-Lang-Smry


!***********************************************************************
! Initialize-CalGrp-Arrays                                             *
!                                                                      *
! Description:  Clears out calendar group-level earnings & deductions  *
!               arrays.                                                *
!***********************************************************************

begin-procedure Initialize-CalGrp-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-CalGrp-Arrays'
#end-if

    let #i = 0
    while #i <= #Max_Array_Init
        put 0  Into CalGrp_Ded_Totals(#i) PIN_Num
        put '' Into CalGrp_Ded_Totals(#i) PIN_Name
        put 0  Into CalGrp_Ded_Totals(#i) Units
        put 0  Into CalGrp_Ded_Totals(#i) Amount
        put 0  Into CalGrp_Ded_Totals(#i) Units_Adj
        put 0  Into CalGrp_Ded_Totals(#i) Amount_Adj

        put 0  Into CalGrp_Ern_Totals(#i) PIN_Num
        put '' Into CalGrp_Ern_Totals(#i) PIN_Name
        put 0  Into CalGrp_Ern_Totals(#i) Units
        put 0  Into CalGrp_Ern_Totals(#i) Amount
        put 0  Into CalGrp_Ern_Totals(#i) Units_Adj
        put 0  Into CalGrp_Ern_Totals(#i) Amount_Adj

        add 1 to #i
    end-while

 end-procedure ! Initialize-CalGrp-Arrays

 !***********************************************************************
 ! Initialize-PayEnt-Arrays                                             *
 !                                                                      *
 ! Description:  Clears out pay entity-level earnings & deductions      *
 !               arrays.                                                *
 !***********************************************************************

 begin-procedure Initialize-PayEnt-Arrays

 #ifdef debugw
     Show 'Inside procedure Initialize-PayEnt-Array'
 #end-if

     let #i = 0
     while #i <= #Max_Array_Init
         put 0  Into PayEnt_Ded_Totals(#i) PIN_Num
         put '' Into PayEnt_Ded_Totals(#i) PIN_Name
         put 0  Into PayEnt_Ded_Totals(#i) Units
         put 0  Into PayEnt_Ded_Totals(#i) Amount
         put 0  Into PayEnt_Ded_Totals(#i) Units_Adj
         put 0  Into PayEnt_Ded_Totals(#i) Amount_Adj

         put 0  Into PayEnt_Ern_Totals(#i) PIN_Num
         put '' Into PayEnt_Ern_Totals(#i) PIN_Name
         put 0  Into PayEnt_Ern_Totals(#i) Units
         put 0  Into PayEnt_Ern_Totals(#i) Amount
         put 0  Into PayEnt_Ern_Totals(#i) Units_Adj
         put 0  Into PayEnt_Ern_Totals(#i) Amount_Adj

         add 1 to #i
     end-while

 end-procedure ! Initialize-PayEnt-Arrays

 !***********************************************************************
 ! Initialize-PayGrp-Arrays                                             *
 !                                                                      *
 ! Description:  Clears out pay group-level earnings & deductions       *
 !               arrays.                                                *
 !***********************************************************************

 begin-procedure Initialize-PayGrp-Arrays

 #ifdef debugw
     Show 'Inside procedure Initialize-PayGrp-Array'
 #end-if

    let #i = 0
    while #i <= #Max_Array_Init
       put 0  Into PayGrp_Ded_Totals(#i) PIN_Num
       put '' Into PayGrp_Ded_Totals(#i) PIN_Name
       put 0  Into PayGrp_Ded_Totals(#i) Units
       put 0  Into PayGrp_Ded_Totals(#i) Amount
       put 0  Into PayGrp_Ded_Totals(#i) Units_Adj
       put 0  Into PayGrp_Ded_Totals(#i) Amount_Adj

       put 0  Into PayGrp_Ern_Totals(#i) PIN_Num
       put '' Into PayGrp_Ern_Totals(#i) PIN_Name
       put 0  Into PayGrp_Ern_Totals(#i) Units
       put 0  Into PayGrp_Ern_Totals(#i) Amount
       put 0  Into PayGrp_Ern_Totals(#i) Units_Adj
       put 0  Into PayGrp_Ern_Totals(#i) Amount_Adj

       add 1 to #i
     end-while

 end-procedure ! Initialize-PayGrp-Arrays

!***********************************************************************
! Initialize-Comp-Arrays                                               *
!                                                                      *
!                                                                      *
! Description:  Clears out company-level earnings & deductions arrays. *
!***********************************************************************

begin-procedure Initialize-Comp-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-CalGrp-Array'
#end-if

    let #i = 0
    while #i <= #Max_Array_Init
        put 0  Into Comp_Ded_Totals(#i) PIN_Num
        put '' Into Comp_Ded_Totals(#i) PIN_Name
        put 0  Into Comp_Ded_Totals(#i) Units
        put 0  Into Comp_Ded_Totals(#i) Amount
        put 0  Into Comp_Ded_Totals(#i) Units_Adj
        put 0  Into Comp_Ded_Totals(#i) Amount_Adj

        put 0  Into Comp_Ern_Totals(#i) PIN_Num
        put '' Into Comp_Ern_Totals(#i) PIN_Name
        put 0  Into Comp_Ern_Totals(#i) Units
        put 0  Into Comp_Ern_Totals(#i) Amount
        put 0  Into Comp_Ern_Totals(#i) Units_Adj
        put 0  Into Comp_Ern_Totals(#i) Amount_Adj

        add 1 to #i
    end-while

 end-procedure ! Initialize-Comp-Arrays

!***********************************************************************
! Initialize-Dept-Arrays                                               *
!                                                                      *
! Description:  Clears out department-level earnings & deductions      *
!               arrays.                                                *
!***********************************************************************

begin-procedure Initialize-Dept-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-Dept-Arrays'
#end-if

    let #i = 0
    while #i <= #Max_Array_Init
        put 0  Into Dept_Ded_Totals(#i) PIN_Num
        put '' Into Dept_Ded_Totals(#i) PIN_Name
        put 0  Into Dept_Ded_Totals(#i) Units
        put 0  Into Dept_Ded_Totals(#i) Amount
        put 0  Into Dept_Ded_Totals(#i) Units_Adj
        put 0  Into Dept_Ded_Totals(#i) Amount_Adj

        put 0  Into Dept_Ern_Totals(#i) PIN_Num
        put '' Into Dept_Ern_Totals(#i) PIN_Name
        put 0  Into Dept_Ern_Totals(#i) Units
        put 0  Into Dept_Ern_Totals(#i) Amount
        put 0  Into Dept_Ern_Totals(#i) Units_Adj
        put 0  Into Dept_Ern_Totals(#i) Amount_Adj

        add 1 to #i
    end-while

 end-procedure ! Initialize-Dept-Array

!***********************************************************************
! Initialize-Locn-Arrays                                               *
!                                                                      *
! Description:  Clears out location-level earnings & deductions        *
!               arrays.                                                *
!***********************************************************************

begin-procedure Initialize-Locn-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-Locn-Arrays'
#end-if

    let #i = 0
    while #i <= #Max_Array_Init
        put 0  Into Locn_Ded_Totals(#i) PIN_Num
        put '' Into Locn_Ded_Totals(#i) PIN_Name
        put 0  Into Locn_Ded_Totals(#i) Units
        put 0  Into Locn_Ded_Totals(#i) Amount
        put 0  Into Locn_Ded_Totals(#i) Units_Adj
        put 0  Into Locn_Ded_Totals(#i) Amount_Adj

        put 0  Into Locn_Ern_Totals(#i) PIN_Num
        put '' Into Locn_Ern_Totals(#i) PIN_Name
        put 0  Into Locn_Ern_Totals(#i) Units
        put 0  Into Locn_Ern_Totals(#i) Amount
        put 0  Into Locn_Ern_Totals(#i) Units_Adj
        put 0  Into Locn_Ern_Totals(#i) Amount_Adj

        add 1 to #i
    end-while

 end-procedure ! Initialize-Lcon-Arrays


!***********************************************************************
! Initialize-Estab-Array                                               *
!                                                                      *
! Description:  Clears out establishment-level earnings & deductions   *
!               arrays.                                                *
!***********************************************************************

begin-procedure Initialize-Estab-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-Estab-Arrays'
#end-if

    let #i = 0
    while #i <= #Max_Array_Init
        put 0  Into Estab_Ded_Totals(#i) PIN_Num
        put '' Into Estab_Ded_Totals(#i) PIN_Name
        put 0  Into Estab_Ded_Totals(#i) Units
        put 0  Into Estab_Ded_Totals(#i) Amount
        put 0  Into Estab_Ded_Totals(#i) Units_Adj
        put 0  Into Estab_Ded_Totals(#i) Amount_Adj

        put 0  Into Estab_Ern_Totals(#i) PIN_Num
        put '' Into Estab_Ern_Totals(#i) PIN_Name
        put 0  Into Estab_Ern_Totals(#i) Units
        put 0  Into Estab_Ern_Totals(#i) Amount
        put 0  Into Estab_Ern_Totals(#i) Units_Adj
        put 0  Into Estab_Ern_Totals(#i) Amount_Adj

        add 1 to #i
     end-while

 end-procedure ! Initialize-Estab-Arrays

 !***********************************************************************
 ! Initialize-RunType-Arrays                                            *
 !                                                                      *
 ! Description:  Clears out run type-level earnings & deductions        *
 !               arrays.                                                *
 !***********************************************************************

 begin-procedure Initialize-RunType-Arrays

 #ifdef debugw
     Show 'Inside procedure Initialize-RunType-Arrays'
 #end-if

     let #i = 0
     while #i <= #Max_Array_Init
         put 0  Into RunType_Ded_Totals(#i) PIN_Num
         put '' Into RunType_Ded_Totals(#i) PIN_Name
         put 0  Into RunType_Ded_Totals(#i) Units
         put 0  Into RunType_Ded_Totals(#i) Amount
         put 0  Into RunType_Ded_Totals(#i) Units_Adj
         put 0  Into RunType_Ded_Totals(#i) Amount_Adj

         put 0  Into RunType_Ern_Totals(#i) PIN_Num
         put '' Into RunType_Ern_Totals(#i) PIN_Name
         put 0  Into RunType_Ern_Totals(#i) Units
         put 0  Into RunType_Ern_Totals(#i) Amount
         put 0  Into RunType_Ern_Totals(#i) Units_Adj
         put 0  Into RunType_Ern_Totals(#i) Amount_Adj

         add 1 to #i
      end-while

 end-procedure ! Initialize-RunType-Arrays

 !***********************************************************************
 ! Initialize-Curr-Arrays                                               *
 !                                                                      *
 ! Description:  Clears out currency-level earnings & deductions        *
 !               arrays.                                                *
 !***********************************************************************

 begin-procedure Initialize-Curr-Arrays

 #ifdef debugw
     Show 'Inside procedure Initialize-Curr-Arrays'
 #end-if

     let #i = 0
     while #i <= #Max_Array_Init
         put 0  Into Curr_Ded_Totals(#i) PIN_Num
         put '' Into Curr_Ded_Totals(#i) PIN_Name
         put 0  Into Curr_Ded_Totals(#i) Units
         put 0  Into Curr_Ded_Totals(#i) Amount
         put 0  Into Curr_Ded_Totals(#i) Units_Adj
         put 0  Into Curr_Ded_Totals(#i) Amount_Adj

         put 0  Into Curr_Ern_Totals(#i) PIN_Num
         put '' Into Curr_Ern_Totals(#i) PIN_Name
         put 0  Into Curr_Ern_Totals(#i) Units
         put 0  Into Curr_Ern_Totals(#i) Amount
         put 0  Into Curr_Ern_Totals(#i) Units_Adj
         put 0  Into Curr_Ern_Totals(#i) Amount_Adj

         add 1 to #i
     end-while

 end-procedure ! Initialize-Curr-Arrays

!***********************************************************************
! Add-To-CalGrp-Array                                                  *
!                                                                      *
! Description: Manages Addition of information Into calendar group     *
!              level earnings & deductions arrays.                     *
!***********************************************************************

begin-procedure Add-To-CalGrp-Array

#ifdef debugw
    Show 'Inside procedure Add-To-CalGrp-Arrays'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = CalGrp_Ded_Totals.PIN_Num(#i)
          let #A_Units      = CalGrp_Ded_Totals.Units(#i)
          let #A_Amount     = CalGrp_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = CalGrp_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = CalGrp_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into CalGrp_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into CalGrp_Ded_Totals(#i) PIN_Name
             put #A_Units          Into CalGrp_Ded_Totals(#i) Units
             put #A_Amount         Into CalGrp_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into CalGrp_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into CalGrp_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into CalGrp_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into CalGrp_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into CalGrp_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into CalGrp_Ded_Totals(#i) Amount
           put #Unit_Adj         Into CalGrp_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into CalGrp_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = CalGrp_Ern_Totals.PIN_Num(#i)
           let #A_Units      = CalGrp_Ern_Totals.Units(#i)
           let #A_Amount     = CalGrp_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = CalGrp_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = CalGrp_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into CalGrp_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into CalGrp_Ern_Totals(#i) PIN_Name
              put #A_Units          Into CalGrp_Ern_Totals(#i) Units
              put #A_Amount         Into CalGrp_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into CalGrp_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into CalGrp_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into CalGrp_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into CalGrp_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into CalGrp_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into CalGrp_Ern_Totals(#i) Amount
           put #Unit_Adj         Into CalGrp_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into CalGrp_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-CalGrp-Array


!***********************************************************************
! Add-To-PayEnt-Array                                                  *
!                                                                      *
! Description: Manages Addition of information Into pay entity-level   *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-PayEnt-Array

#ifdef debugw
    Show 'Inside procedure Add-To-PayEnt-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = PayEnt_Ded_Totals.PIN_Num(#i)
          let #A_Units      = PayEnt_Ded_Totals.Units(#i)
          let #A_Amount     = PayEnt_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = PayEnt_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = PayEnt_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into PayEnt_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into PayEnt_Ded_Totals(#i) PIN_Name
             put #A_Units          Into PayEnt_Ded_Totals(#i) Units
             put #A_Amount         Into PayEnt_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into PayEnt_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into PayEnt_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into PayEnt_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into PayEnt_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into PayEnt_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into PayEnt_Ded_Totals(#i) Amount
           put #Unit_Adj         Into PayEnt_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into PayEnt_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = PayEnt_Ern_Totals.PIN_Num(#i)
           let #A_Units      = PayEnt_Ern_Totals.Units(#i)
           let #A_Amount     = PayEnt_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = PayEnt_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = PayEnt_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into PayEnt_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into PayEnt_Ern_Totals(#i) PIN_Name
              put #A_Units          Into PayEnt_Ern_Totals(#i) Units
              put #A_Amount         Into PayEnt_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into PayEnt_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into PayEnt_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into PayEnt_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into PayEnt_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into PayEnt_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into PayEnt_Ern_Totals(#i) Amount
           put #Unit_Adj         Into PayEnt_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into PayEnt_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-PayEnt-Array


!***********************************************************************
! Add-To-PayGrp-Array                                                  *
!                                                                      *
! Description: Manages Addition of information Into pay group-level    *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-PayGrp-Array

#ifdef debugw
    Show 'Inside procedure Add-To-PayGrp-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $Ern_Ded_PIN_Type = 'DD'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = PayGrp_Ded_Totals.PIN_Num(#i)
          let #A_Units      = PayGrp_Ded_Totals.Units(#i)
          let #A_Amount     = PayGrp_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = PayGrp_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = PayGrp_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into PayGrp_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into PayGrp_Ded_Totals(#i) PIN_Name
             put #A_Units          Into PayGrp_Ded_Totals(#i) Units
             put #A_Amount         Into PayGrp_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into PayGrp_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into PayGrp_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into PayGrp_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into PayGrp_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into PayGrp_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into PayGrp_Ded_Totals(#i) Amount
           put #Unit_Adj         Into PayGrp_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into PayGrp_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = PayGrp_Ern_Totals.PIN_Num(#i)
           let #A_Units      = PayGrp_Ern_Totals.Units(#i)
           let #A_Amount     = PayGrp_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = PayGrp_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = PayGrp_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into PayGrp_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into PayGrp_Ern_Totals(#i) PIN_Name
              put #A_Units          Into PayGrp_Ern_Totals(#i) Units
              put #A_Amount         Into PayGrp_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into PayGrp_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into PayGrp_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into PayGrp_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into PayGrp_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into PayGrp_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into PayGrp_Ern_Totals(#i) Amount
           put #Unit_Adj         Into PayGrp_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into PayGrp_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-PayGrp-Array


!***********************************************************************
! Add-To-Comp-Array                                                    *
!                                                                      *
! Description: Manages Addition of information Into company-level      *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Comp-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Comp-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = Comp_Ded_Totals.PIN_Num(#i)
          let #A_Units      = Comp_Ded_Totals.Units(#i)
          let #A_Amount     = Comp_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = Comp_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = Comp_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into Comp_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into Comp_Ded_Totals(#i) PIN_Name
             put #A_Units          Into Comp_Ded_Totals(#i) Units
             put #A_Amount         Into Comp_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into Comp_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into Comp_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

       end-while

       if $Added_To_Existing = 'F'
          put #Ern_Ded_PIN_Num  Into Comp_Ded_Totals(#i) PIN_Num
          put $Ern_Ded_PIN_Name Into Comp_Ded_Totals(#i) PIN_Name
          put #Unit_Rslt        Into Comp_Ded_Totals(#i) Units
          put #Calc_RsltIn      Into Comp_Ded_Totals(#i) Amount
          put #Unit_Adj         Into Comp_Ded_Totals(#i) Units_Adj
          put #Amount_Adj       Into Comp_Ded_Totals(#i) Amount_Adj
       end-if
    end-if

    if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = Comp_Ern_Totals.PIN_Num(#i)
           let #A_Units      = Comp_Ern_Totals.Units(#i)
           let #A_Amount     = Comp_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = Comp_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = Comp_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Comp_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into Comp_Ern_Totals(#i) PIN_Name
              put #A_Units          Into Comp_Ern_Totals(#i) Units
              put #A_Amount         Into Comp_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into Comp_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into Comp_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Comp_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Comp_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Comp_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into Comp_Ern_Totals(#i) Amount
           put #Unit_Adj         Into Comp_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Comp_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-Comp-Array

!***********************************************************************
! Add-To-Dept-Array                                                    *
!                                                                      *
! Description: Manages Addition of information Into department-level   *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Dept-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Dept-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = Dept_Ded_Totals.PIN_Num(#i)
          let #A_Units      = Dept_Ded_Totals.Units(#i)
          let #A_Amount     = Dept_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = Dept_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = Dept_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into Dept_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into Dept_Ded_Totals(#i) PIN_Name
             put #A_Units          Into Dept_Ded_Totals(#i) Units
             put #A_Amount         Into Dept_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into Dept_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into Dept_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Dept_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Dept_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Dept_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into Dept_Ded_Totals(#i) Amount
           put #Unit_Adj         Into Dept_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Dept_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = Dept_Ern_Totals.PIN_Num(#i)
           let #A_Units      = Dept_Ern_Totals.Units(#i)
           let #A_Amount     = Dept_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = Dept_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = Dept_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Dept_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into Dept_Ern_Totals(#i) PIN_Name
              put #A_Units          Into Dept_Ern_Totals(#i) Units
              put #A_Amount         Into Dept_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into Dept_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into Dept_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Dept_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Dept_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Dept_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into Dept_Ern_Totals(#i) Amount
           put #Unit_Adj         Into Dept_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Dept_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-Dept-Array

!***********************************************************************
! Add-To-Locn-Array                                                    *
!                                                                      *
! Called By:   Get-Rslt-Ern-Ded                                        *
!                                                                      *
! Calls:       none                                                    *
!                                                                      *
! Description: Manages Addition of information Into department-level   *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Locn-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Locn-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = Locn_Ded_Totals.PIN_Num(#i)
          let #A_Units      = Locn_Ded_Totals.Units(#i)
          let #A_Amount     = Locn_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = Locn_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = Locn_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into Locn_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into Locn_Ded_Totals(#i) PIN_Name
             put #A_Units          Into Locn_Ded_Totals(#i) Units
             put #A_Amount         Into Locn_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into Locn_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into Locn_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Locn_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Locn_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Locn_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into Locn_Ded_Totals(#i) Amount
           put #Unit_Adj         Into Locn_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Locn_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = Locn_Ern_Totals.PIN_Num(#i)
           let #A_Units      = Locn_Ern_Totals.Units(#i)
           let #A_Amount     = Locn_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = Locn_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = Locn_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Locn_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into Locn_Ern_Totals(#i) PIN_Name
              put #A_Units          Into Locn_Ern_Totals(#i) Units
              put #A_Amount         Into Locn_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into Locn_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into Locn_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Locn_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Locn_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Locn_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into Locn_Ern_Totals(#i) Amount
           put #Unit_Adj         Into Locn_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Locn_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-Locn-Array


!***********************************************************************
! Add-To-Estab-Array                                                   *
!                                                                      *
! Description: Manages Addition of information Into location-level     *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Estab-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Estab-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = Estab_Ded_Totals.PIN_Num(#i)
          let #A_Units      = Estab_Ded_Totals.Units(#i)
          let #A_Amount     = Estab_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = Estab_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = Estab_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into Estab_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into Estab_Ded_Totals(#i) PIN_Name
             put #A_Units          Into Estab_Ded_Totals(#i) Units
             put #A_Amount         Into Estab_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into Estab_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into Estab_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Estab_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Estab_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Estab_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into Estab_Ded_Totals(#i) Amount
           put #Unit_Adj         Into Estab_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Estab_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = Estab_Ern_Totals.PIN_Num(#i)
           let #A_Units      = Estab_Ern_Totals.Units(#i)
           let #A_Amount     = Estab_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = Estab_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = Estab_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Estab_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into Estab_Ern_Totals(#i) PIN_Name
              put #A_Units          Into Estab_Ern_Totals(#i) Units
              put #A_Amount         Into Estab_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into Estab_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into Estab_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Estab_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Estab_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Estab_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into Estab_Ern_Totals(#i) Amount
           put #Unit_Adj         Into Estab_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Estab_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-Estab-Array

!***********************************************************************
! Add-To-RunType-Array                                                 *
!                                                                      *
! Called By:   Get-Rslt-Ern-Ded                                        *
!                                                                      *
! Calls:       none                                                    *
!                                                                      *
! Description: Manages Addition of information Into department-level   *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-RunType-Array

#ifdef debugw
    Show 'Inside procedure Add-To-RunType-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = RunType_Ded_Totals.PIN_Num(#i)
          let #A_Units      = RunType_Ded_Totals.Units(#i)
          let #A_Amount     = RunType_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = RunType_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = RunType_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into RunType_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into RunType_Ded_Totals(#i) PIN_Name
             put #A_Units          Into RunType_Ded_Totals(#i) Units
             put #A_Amount         Into RunType_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into RunType_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into RunType_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into RunType_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into RunType_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into RunType_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into RunType_Ded_Totals(#i) Amount
           put #Unit_Adj         Into RunType_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into RunType_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = RunType_Ern_Totals.PIN_Num(#i)
           let #A_Units      = RunType_Ern_Totals.Units(#i)
           let #A_Amount     = RunType_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = RunType_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = RunType_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Locn_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into RunType_Ern_Totals(#i) PIN_Name
              put #A_Units          Into RunType_Ern_Totals(#i) Units
              put #A_Amount         Into RunType_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into RunType_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into RunType_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into RunType_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into RunType_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into RunType_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into RunType_Ern_Totals(#i) Amount
           put #Unit_Adj         Into RunType_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into RunType_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-RunType-Array


!***********************************************************************
! Add-To-Curr-Array                                                    *
!                                                                      *
! Description: Manages Addition of information Into currency-level     *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Curr-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Curr-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
! PIN units and amount to the row.  if it is not already in the        *
! array, Add it, updating all columns.                                 *
!                                                                      *
!***********************************************************************

    if $SectType = 'D'
       let $Added_To_Existing = 'F'
       let #i = 0

       while #i <= {max_array_size}
          let #A_PIN_Num    = Curr_Ded_Totals.PIN_Num(#i)
          let #A_Units      = Curr_Ded_Totals.Units(#i)
          let #A_Amount     = Curr_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = Curr_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = Curr_Ded_Totals.Amount_Adj(#i)

          if #A_PIN_Num = #Ern_Ded_PIN_Num
             let #A_Units      = #A_Units      + #Unit_Rslt
             let #A_Amount     = #A_Amount     + #Calc_RsltIn
             let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
             let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

             put #Ern_Ded_PIN_Num  Into Curr_Ded_Totals(#i) PIN_Num
             put $Ern_Ded_PIN_Name Into Curr_Ded_Totals(#i) PIN_Name
             put #A_Units          Into Curr_Ded_Totals(#i) Units
             put #A_Amount         Into Curr_Ded_Totals(#i) Amount
             put #A_Units_Adj      Into Curr_Ded_Totals(#i) Units_Adj
             put #A_Amount_Adj     Into Curr_Ded_Totals(#i) Amount_Adj
             let $Added_To_Existing = 'Y'
             break
          else
             if #A_PIN_Num = 0
                Break
             end-if
          end-if

          add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Curr_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Curr_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Curr_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into Curr_Ded_Totals(#i) Amount
           put #Unit_Adj         Into Curr_Ded_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Curr_Ded_Totals(#i) Amount_Adj
        end-if
     end-if

     if $SectType = 'E'
        let $Added_To_Existing = 'F'
        let #i = 0

        while #i <= {max_array_size}
           let #A_PIN_Num    = Curr_Ern_Totals.PIN_Num(#i)
           let #A_Units      = Curr_Ern_Totals.Units(#i)
           let #A_Amount     = Curr_Ern_Totals.Amount(#i)
           let #A_Units_Adj  = Curr_Ern_Totals.Units_Adj(#i)
           let #A_Amount_Adj = Curr_Ern_Totals.Amount_Adj(#i)
           if #Ern_Ded_PIN_Num = #A_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into Curr_Ern_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into Curr_Ern_Totals(#i) PIN_Name
              put #A_Units          Into Curr_Ern_Totals(#i) Units
              put #A_Amount         Into Curr_Ern_Totals(#i) Amount
              put #A_Units_Adj      Into Curr_Ern_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into Curr_Ern_Totals(#i) Amount_Adj
              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 break
              end-if
           end-if

           add 1 to #i

        end-while

        if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into Curr_Ern_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into Curr_Ern_Totals(#i) PIN_Name
           put #Unit_Rslt        Into Curr_Ern_Totals(#i) Units
           put #Calc_RsltIn      Into Curr_Ern_Totals(#i) Amount
           put #Unit_Adj         Into Curr_Ern_Totals(#i) Units_Adj
           put #Calc_AdjIn       Into Curr_Ern_Totals(#i) Amount_Adj
        end-if
     end-if

end-procedure ! Add-To-Estab-Array

!***********************************************************************
! Print-CalGrp-Totals                                                  *
!                                                                      *
! Description:  Manages Printing of calendar group-level earnings and  *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-CalGrp-Totals

#ifdef debugw
    Show 'Inside procedure Print-CalGrp-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'

       let $SectType = 'E'
       do Print-CalGrp-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-CalGrp-Data
    end-if

   new-page

end-procedure ! Print-CalGrp-Totals


begin-procedure Print-CalGrp-Data

#ifdef -debugw
   show 'Inside Print-CalGrp-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = CalGrp_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = CalGrp_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = CalGrp_Ded_Totals.Units      (#m)
          let #tot_amt        = CalGrp_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = CalGrp_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = CalGrp_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = CalGrp_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = CalGrp_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = CalGrp_Ern_Totals.Units      (#m)
          let #tot_amt        = CalGrp_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = CalGrp_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = CalGrp_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-CalGrp-Subtotals


!***********************************************************************
! Print-PayEnt-Totals                                                  *
!                                                                      *
! Description:  Manages Printing of pay entity-level earnings and      *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-PayEnt-Totals

#ifdef debugw
    Show 'Inside procedure Print-PayEnt-Totals'
#end-if


    let $First_Section = 'Y'
    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-PayEnt-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-PayEnt-Data
    end-if

    new-page

end-procedure !Print-PayEnt-Totals


begin-procedure Print-PayEnt-Data

#ifdef debugw
    Show 'Inside procedure Print-PayEnt-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = PayEnt_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = PayEnt_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = PayEnt_Ded_Totals.Units      (#m)
          let #tot_amt        = PayEnt_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = PayEnt_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = PayEnt_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = PayEnt_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = PayEnt_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = PayEnt_Ern_Totals.Units      (#m)
          let #tot_amt        = PayEnt_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = PayEnt_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = PayEnt_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-PayEnt-Data

!***********************************************************************
! Print-PayGrp-Totals                                                  *
!                                                                      *
! Description:  Manages Printing of pay group-level earnings and       *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-PayGrp-Totals

#ifdef debugw
    Show 'Inside procedure Print-PayGrp-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-PayGrp-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-PayGrp-Data
    end-if

    new-page

end-procedure ! Print-PayGrp-Totals


begin-procedure Print-PayGrp-Data

#ifdef debugw
    Show 'Inside procedure Print-PayGrp-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = PayGrp_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = PayGrp_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = PayGrp_Ded_Totals.Units      (#m)
          let #tot_amt        = PayGrp_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = PayGrp_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = PayGrp_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = PayGrp_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = PayGrp_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = PayGrp_Ern_Totals.Units      (#m)
          let #tot_amt        = PayGrp_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = PayGrp_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = PayGrp_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-PayGrp-Subtotals

!***********************************************************************
! Print-Dept-Totals                                                    *
!                                                                      *
! Description:  Manages Printing of department-level earnings and      *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-Dept-Totals

#ifdef debugw
    Show 'Inside procedure Print-Dept-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-Dept-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-Dept-Data
    end-if

    new-page

end-procedure ! Print-Dept-Totals


begin-procedure Print-Dept-Data

#ifdef debugw
    Show 'Inside procedure Print-Dept-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = Dept_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Dept_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = Dept_Ded_Totals.Units      (#m)
          let #tot_amt        = Dept_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = Dept_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Dept_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = Dept_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Dept_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = Dept_Ern_Totals.Units      (#m)
          let #tot_amt        = Dept_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = Dept_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Dept_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-Dept-Totals


!***********************************************************************
! Print-Comp-Totals                                                    *
!                                                                      *
! Description:  Manages Printing of company-level earnings and         *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-Comp-Totals

#ifdef debugw
    Show 'Inside procedure Print-Dept-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-Comp-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-Comp-Data
    end-if

    new-page

end-procedure ! Print-Comp-Totals


begin-procedure Print-Comp-Data

#ifdef debugw
    Show 'Inside procedure Print-Comp-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = Comp_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Comp_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = Comp_Ded_Totals.Units      (#m)
          let #tot_amt        = Comp_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = Comp_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Comp_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = Comp_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Comp_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = Comp_Ern_Totals.Units      (#m)
          let #tot_amt        = Comp_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = Comp_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Comp_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-Comp-Data

!***********************************************************************
! Print-Locn-Totals                                                    *
!                                                                      *
! Description:  Manages Printing of location-level earnings and        *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-Locn-Totals

#ifdef debugw
    Show 'Inside procedure Print-Locn-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-Locn-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-Locn-Data
    end-if

    new-page


end-procedure ! Print-Locn-Totals


begin-procedure Print-Locn-Data

#ifdef debugw
    Show 'Inside procedure Print-Locn-Data'
#end-if

    do Print-Ern-Ded-Header
    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = Locn_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Locn_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = Locn_Ded_Totals.Units      (#m)
          let #tot_amt        = Locn_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = Locn_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Locn_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = Locn_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Locn_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = Locn_Ern_Totals.Units      (#m)
          let #tot_amt        = Locn_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = Locn_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Locn_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-Locn-Subtotals

!***********************************************************************
! Print-Estab-Totals                                                   *
!                                                                      *
! Description:  Manages Printing of establishment-level earnings and   *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-Estab-Totals

#ifdef debugw
    Show 'Inside procedure Print-Estab-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-Estab-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-Estab-Data
    end-if

    new-page

end-procedure ! Print-Estab-Totals


begin-procedure Print-Estab-Data

#ifdef debugw
    Show 'Inside procedure Print-Estab-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = Estab_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Estab_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = Estab_Ded_Totals.Units      (#m)
          let #tot_amt        = Estab_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = Estab_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Estab_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = Estab_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Estab_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = Estab_Ern_Totals.Units      (#m)
          let #tot_amt        = Estab_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = Estab_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Estab_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-Estab-Data

!***********************************************************************
! Print-RunType-Totals                                                    *
!                                                                      *
! Description:  Manages Printing of location-level earnings and        *
!               deductions arrays.                                     *
!***********************************************************************

begin-procedure Print-RunType-Totals

#ifdef debugw
    Show 'Inside procedure Print-RunType-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-RunType-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-RunType-Data
    end-if

end-procedure ! Print-RunType-Totals


begin-procedure Print-RunType-Data

#ifdef debugw
    Show 'Inside procedure Print-RunType-Data'
#end-if

    do Print-Ern-Ded-Header
    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = RunType_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = RunType_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = RunType_Ded_Totals.Units      (#m)
          let #tot_amt        = RunType_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = RunType_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = RunType_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = RunType_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = RunType_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = RunType_Ern_Totals.Units      (#m)
          let #tot_amt        = RunType_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = RunType_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = RunType_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj
     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-RunType-Subtotals


!***********************************************************************
! Print-Curr-Totals                                                    *
!                                                                      *
! Description:  Manages Printing of currency-level earnings and        *
!               deductions arrays.                                     *
!**********************************************************************

begin-procedure Print-Curr-Totals

#ifdef debugw
    Show 'Inside procedure Print-Curr-Totals'
#end-if

    let $First_Section = 'Y'

    if $PrintERN = 'Y'
       let $SectType = 'E'
       do Print-Curr-Data
    end-if

    if $PrintDED = 'Y'
       let $SectType = 'D'
       do Print-Curr-Data
    end-if

    new-page

end-procedure ! Print-Curr-Totals


begin-procedure Print-Curr-Data

#ifdef debugw
    Show 'Inside procedure Print-Curr-Data'
#end-if

    do Print-Ern-Ded-Header

    let #m = 0
    let #etot_units = 0
    let #etot_amt = 0
    let #etot_units_adj = 0
    let #etot_amt_adj = 0

    while #m <= {max_array_size}

       if $SectType = 'D'
          let #tot_pin_num    = Curr_Ded_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Curr_Ded_Totals.PIN_Name   (#m)
          let #tot_units      = Curr_Ded_Totals.Units      (#m)
          let #tot_amt        = Curr_Ded_Totals.Amount     (#m)
          let #tot_units_adj  = Curr_Ded_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Curr_Ded_Totals.Amount_Adj (#m)
       else
          let #tot_pin_num    = Curr_Ern_Totals.PIN_Num    (#m)
          let $tot_pin_nm     = Curr_Ern_Totals.PIN_Name   (#m)
          let #tot_units      = Curr_Ern_Totals.Units      (#m)
          let #tot_amt        = Curr_Ern_Totals.Amount     (#m)
          let #tot_units_adj  = Curr_Ern_Totals.Units_Adj  (#m)
          let #tot_amt_adj    = Curr_Ern_Totals.Amount_Adj (#m)
       end-if

       if #tot_pin_num     = 0
          break
       end-if

       do Print-Org-Sub-Totals

       let #m = #m + 1
       let #etot_units = #etot_units + #tot_units
       let #etot_amt = #etot_amt + #tot_amt
       let #etot_units_adj = #etot_units_adj + #tot_units_adj
       let #etot_amt_adj = #etot_amt_adj + #tot_amt_adj

     end-while

     do Print-Org-Sect-Totals

end-procedure !Print-Curr-Data


begin-procedure Print-Org-Sect-Totals

#ifdef debugw
    Show 'Inside procedure Print-Org-Sect-Totals'
#end-if

  if #current-line + 3 > #Maxlines
     New-Page
     do Print-Ern-Ded-Header
     let $Arr_FirstTimethru = 'N'
  end-if

   print ' ' (+1,1)
   if #etot_amt <> 0
      print '--------------------------' (,  {Col_SUM_Amt})
   end-if

   if #etot_amt_adj <> 0
      print '--------------------------' (,  {Col_SUM_Amt_Adj})
   end-if

   if #etot_units <> 0
      print '--------------------------' (,  {Col_SUM_Unit})
   end-if

   if #etot_units_adj <> 0
      print '--------------------------' (,  {Col_SUM_Unit_Adj})
   end-if

   print $total_lbl                     (+1,{Col_sort_label1})

   if #etot_amt <> 0
      do Format-Number(#etot_amt,    $Tot_Amt,     $TotAmtMask)
      print $Tot_Amt           (,{Col_SUM_Amt})
   end-if

   if #etot_amt_adj <> 0
      do Format-Number(#etot_amt_adj, $Tot_Amt_Adj, $TotAmtMask)
      print $Tot_Amt_Adj       (,{Col_SUM_Amt_Adj})
   end-if

   if #etot_units <> 0
      do Format-Number(#etot_units, $Tot_Units, $TotUntMask)
      print $Tot_Units        (,{Col_SUM_Unit}
   end-if

   if #etot_units_adj <> 0
      do Format-Number(#etot_units_adj, $Tot_Units_Adj, $TotUntMask)
      print $Tot_Units_Adj    (,{Col_SUM_Unit_Adj}
   end-if

end-procedure !Print-Org-Sect-Totals


begin-procedure Print-Org-Sub-Totals

#ifdef debugw
    Show 'Inside procedure Print-Org-Sub-Totals'
#end-if

   if #current-line + 3 > #Maxlines
      New-Page
      let $ErnDed_FirstTimethru = 'Y'
   end-if

   if $ErnDed_FirstTimethru = 'Y'
       do Print-Ern-Ded-Header
       let $ErnDed_FirstTimethru = 'N'
   end-if

   if #tot_Units  <> 0
         or #tot_amt <> 0
         or #tot_units_adj <> 0
         or #tot_amt_adj <> 0

      print $tot_pin_nm        (+1,{Col_sort_label1})

      if #tot_amt <> 0
         do Format-Number(#tot_amt,    $Tot_Amt,     $TotAmtMask)
         print $Tot_Amt           (,{Col_SUM_Amt})
      else
         print ' '                 (,{Col_SUM_Amt})
      end-if

      if #tot_amt_adj <> 0
         do Format-Number(#tot_amt_adj, $Tot_Amt_Adj, $TotAmtMask)
         print $Tot_Amt_Adj       (,{Col_SUM_Amt_Adj})
      else
         print ' '      (,{Col_SUM_Amt_Adj})
      end-if

      if #tot_units <> 0
         do Format-Number(#tot_units, $Tot_Units, $TotUntMask)
         print $Tot_Units        (,{Col_SUM_Unit}
      else
         print ' '       (,{Col_SUM_Unit}
      end-if

      if #tot_units_adj <> 0
         do Format-Number(#tot_units_adj, $Tot_Units_Adj, $TotUntMask)
         print $Tot_Units_Adj    (,{Col_SUM_Unit_Adj}
      else
         print ' '    (,{Col_SUM_Unit_Adj}
      end-if

   end-if

end-procedure !Print-Org-Sub-Totals

!***********************************************************************
! Add-To-Paygroup-Array                                                *
!                                                                      *
! Description: Manages Addition of information Into pay group-level    *
!              earnings & deductions arrays.                           *
!***********************************************************************

begin-procedure Add-To-Paygroup-Array

#ifdef debugw
    Show 'Inside procedure Add-To-Paygroup-Array'
#end-if

!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
!       PIN units and amount to the row.  if it is not already in the  *
!       array, Add it, updating all columns.                           *
!                                                                      *
!***********************************************************************

      let $Added_To_Existing = 'F'

      let #i = 0
      while #i <= {max_array_size}
          let #A_PIN_Num    = PayGrp_Ded_Totals.PIN_Num(#i)
          let #A_Units      = PayGrp_Ded_Totals.Units(#i)
          let #A_Amount     = PayGrp_Ded_Totals.Amount(#i)
          let #A_Units_Adj  = PayGrp_Ded_Totals.Units_Adj(#i)
          let #A_Amount_Adj = PayGrp_Ded_Totals.Amount_Adj(#i)

          if  #A_PIN_Num = #Ern_Ded_PIN_Num
              let #A_Units      = #A_Units      + #Unit_Rslt
              let #A_Amount     = #A_Amount     + #Calc_RsltIn
              let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
              let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn
              put #Ern_Ded_PIN_Num  Into PayGrp_Ded_Totals(#i) PIN_Num
              put $Ern_Ded_PIN_Name Into PayGrp_Ded_Totals(#i) PIN_Name
              put #A_Units          Into PayGrp_Ded_Totals(#i) Units
              put #A_Amount         Into PayGrp_Ded_Totals(#i) Amount
              put #A_Units_Adj      Into PayGrp_Ded_Totals(#i) Units_Adj
              put #A_Amount_Adj     Into PayGrp_Ded_Totals(#i) Amount_Adj

              let $Added_To_Existing = 'Y'
              break
           else
              if #A_PIN_Num = 0
                 Break
              end-if
           end-if
              Add 1 to #i
       end-While

       if $Added_To_Existing = 'F'
           put #Ern_Ded_PIN_Num  Into PayGrp_Ded_Totals(#i) PIN_Num
           put $Ern_Ded_PIN_Name Into PayGrp_Ded_Totals(#i) PIN_Name
           put #Unit_Rslt        Into PayGrp_Ded_Totals(#i) Units
           put #Calc_RsltIn      Into PayGrp_Ded_Totals(#i) Amount
           put #Unit_Adj         Into PayGrp_Ded_Totals(#i) Units_Adj
           put #Amount_Adj       Into PayGrp_Ded_Totals(#i) Amount_Adj
        end-if

        if $SectType = 'E'

            let $Added_To_Existing = 'F'

            let #i = 0
            While #i <= {max_array_size}
                let #A_PIN_Num    = PayGrp_Ern_Totals.PIN_Num(#i)
                let #A_Units      = PayGrp_Ern_Totals.Units(#i)
                let #A_Amount     = PayGrp_Ern_Totals.Amount(#i)
                let #A_Units_Adj  = PayGrp_Ern_Totals.Units_Adj(#i)
                let #A_Amount_Adj = PayGrp_Ern_Totals.Amount_Adj(#i)

                if #Ern_Ded_PIN_Num = #A_PIN_Num
                    let #A_Units      = #A_Units      + #Unit_Rslt
                    let #A_Amount     = #A_Amount     + #Calc_RsltIn
                    let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
                    let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

                    put #Ern_Ded_PIN_Num  Into PayGrp_Ern_Totals(#i) PIN_Num
                    put $Ern_Ded_PIN_Name Into PayGrp_Ern_Totals(#i) PIN_Name
                    put #A_Units          Into PayGrp_Ern_Totals(#i) Units
                    put #A_Amount         Into PayGrp_Ern_Totals(#i) Amount
                    put #A_Units_Adj      Into PayGrp_Ern_Totals(#i) Units_Adj
                    put #A_Amount_Adj     Into PayGrp_Ern_Totals(#i) Amount_Adj

                    let $Added_To_Existing = 'Y'
                    Break
                else
                    if #A_PIN_Num = 0
                        Break
                    end-if
                end-if

                Add 1 to #i
            end-While

            if $Added_To_Existing = 'F'
               put #Ern_Ded_PIN_Num  Into PayGrp_Ern_Totals(#i) PIN_Num
               put $Ern_Ded_PIN_Name Into PayGrp_Ern_Totals(#i) PIN_Name
               put #Unit_Rslt        Into PayGrp_Ern_Totals(#i) Units
               put #Calc_RsltIn      Into PayGrp_Ern_Totals(#i) Amount
               put #Unit_Adj         Into PayGrp_Ern_Totals(#i) Units_Adj
               put #Amount_Adj       Into PayGrp_Ern_Totals(#i) Amount_Adj
            end-if
        end-if

end-procedure ! Add-To-Paygroup-Array


!***********************************************************************
! Initialize-Paygroup-Array                                            *
!                                                                      *
! Description: This procedure initializes the array                    *
!***********************************************************************

begin-procedure Initialize-Paygroup-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-Paygroup-Array'
#end-if

   let #i = 0
   while #i <= #Max_Array_Init
        put 0  Into PayGrp_Ded_Totals(#i) PIN_Num
        put '' Into PayGrp_Ded_Totals(#i) PIN_Name
        put 0  Into PayGrp_Ded_Totals(#i) Units
        put 0  Into PayGrp_Ded_Totals(#i) Amount
        put 0  Into PayGrp_Ded_Totals(#i) Units_Adj
        put 0  Into PayGrp_Ded_Totals(#i) Amount_Adj

        put 0  Into PayGrp_Ern_Totals(#i) PIN_Num
        put '' Into PayGrp_Ern_Totals(#i) PIN_Name
        put 0  Into PayGrp_Ern_Totals(#i) Units
        put 0  Into PayGrp_Ern_Totals(#i) Amount
        put 0  Into PayGrp_Ern_Totals(#i) Units_Adj
        put 0  Into PayGrp_Ern_Totals(#i) Amount_Adj
        add 1 to #i
    end-while

end-procedure ! Initialize-Paygroup-Array


!***********************************************************************
! Add-To-PayEntity-Array                                               *
!                                                                      *
! Description: Manages Addition of information Into pay entity-level   *
!              earnings & deductions arrays.                           *
!                                                                      *
!***********************************************************************


begin-procedure Add-To-PayEntity-Array


#ifdef debugw
    Show 'Inside procedure Add-To-PayEntity-Array'
#end-if


!***********************************************************************
!                                                                      *
! Check to see if the PIN # exists in the array.  if it does, Add the  *
!       PIN units and amount to the row.  if it is not already in the  *
!       array, Add it, updating all columns.                           *
!                                                                      *
!***********************************************************************


       if $SectType = 'D'

            let $Added_To_Existing = 'F'

            let #i = 0
            While #i <= {max_array_size}
                let #A_PIN_Num    = PayEnt_Ded_Totals.PIN_Num(#i)
                let #A_Units      = PayEnt_Ded_Totals.Units(#i)
                let #A_Amount     = PayEnt_Ded_Totals.Amount(#i)
                let #A_Units_Adj  = PayEnt_Ded_Totals.Units_Adj(#i)
                let #A_Amount_Adj = PayEnt_Ded_Totals.Amount_Adj(#i)

                if  #A_PIN_Num = #Ern_Ded_PIN_Num
                    let #A_Units      = #A_Units      + #Unit_Rslt
                    let #A_Amount     = #A_Amount     + #Calc_RsltIn
                    let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
                    let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

                    put #Ern_Ded_PIN_Num  Into PayEnt_Ded_Totals(#i) PIN_Num
                    put $Ern_Ded_PIN_Name Into PayEnt_Ded_Totals(#i) PIN_Name
                    put #A_Units          Into PayEnt_Ded_Totals(#i) Units
                    put #A_Amount         Into PayEnt_Ded_Totals(#i) Amount
                    put #A_Units_Adj      Into PayEnt_Ded_Totals(#i) Units_Adj
                    put #A_Amount_Adj     Into PayEnt_Ded_Totals(#i) Amount_Adj

                    let $Added_To_Existing = 'Y'

                    Break
                else
                    if #A_PIN_Num = 0
                        Break
                    end-if
                end-if

                Add 1 to #i
            end-While

            if $Added_To_Existing = 'F'
               put #Ern_Ded_PIN_Num  Into PayEnt_Ded_Totals(#i) PIN_Num
               put $Ern_Ded_PIN_Name Into PayEnt_Ded_Totals(#i) PIN_Name
               put #Unit_Rslt        Into PayEnt_Ded_Totals(#i) Units
               put #Calc_RsltIn      Into PayEnt_Ded_Totals(#i) Amount
               put #Unit_Adj         Into PayEnt_Ded_Totals(#i) Units_Adj
               put #Amount_Adj       Into PayEnt_Ded_Totals(#i) Amount_Adj
            end-if
        end-if

        if $SectType = 'E'

            let $Added_To_Existing = 'F'
            let #i = 0

            While #i <= {max_array_size}
                let #A_PIN_Num    = PayEnt_Ern_Totals.PIN_Num(#i)
                let #A_Units      = PayEnt_Ern_Totals.Units(#i)
                let #A_Amount     = PayEnt_Ern_Totals.Amount(#i)
                let #A_Units_Adj  = PayEnt_Ern_Totals.Units_Adj(#i)
                let #A_Amount_Adj = PayEnt_Ern_Totals.Amount_Adj(#i)

                if #Ern_Ded_PIN_Num = #A_PIN_Num
                    let #A_Units      = #A_Units      + #Unit_Rslt
                    let #A_Amount     = #A_Amount     + #Calc_RsltIn
                    let #A_Units_Adj  = #A_Units_Adj  + #Unit_Adj
                    let #A_Amount_Adj = #A_Amount_Adj + #Calc_AdjIn

                    put #Ern_Ded_PIN_Num  Into PayEnt_Ern_Totals(#i) PIN_Num
                    put $Ern_Ded_PIN_Name Into PayEnt_Ern_Totals(#i) PIN_Name
                    put #A_Units          Into PayEnt_Ern_Totals(#i) Units
                    put #A_Amount         Into PayEnt_Ern_Totals(#i) Amount
                    put #A_Units_Adj      Into PayEnt_Ern_Totals(#i) Units_Adj
                    put #A_Amount_Adj     Into PayEnt_Ern_Totals(#i) Amount_Adj

                    let $Added_To_Existing = 'Y'
                    Break
                else
                    if #A_PIN_Num = 0
                        Break
                    end-if
                end-if

                Add 1 To #i
            end-While

            if $Added_To_Existing = 'F'
                put #Ern_Ded_PIN_Num  Into PayEnt_Ern_Totals(#i) PIN_Num
                put $Ern_Ded_PIN_Name Into PayEnt_Ern_Totals(#i) PIN_Name
                put #Unit_Rslt        Into PayEnt_Ern_Totals(#i) Units
                put #Calc_RsltIn      Into PayEnt_Ern_Totals(#i) Amount
                put #Unit_Adj         Into PayEnt_Ern_Totals(#i) Units_Adj
                put #Amount_Adj       Into PayEnt_Ern_Totals(#i) Amount_Adj
            end-if
        end-if

end-procedure ! Add-To-PayEntity-Array


!***********************************************************************
!                                                                      *
! Initialize-PayEntity-Array                                           *
!                                                                      *
!***********************************************************************

begin-procedure Initialize-PayEntity-Arrays

#ifdef debugw
    Show 'Inside procedure Initialize-PayEntity-Array'
#end-if

   let #i = 0
   While #i <= #Max_Array_Init
      put 0  Into PayEnt_Ded_Totals(#i) PIN_Num
      put '' Into PayEnt_Ded_Totals(#i) PIN_Name
      put 0  Into PayEnt_Ded_Totals(#i) Units
      put 0  Into PayEnt_Ded_Totals(#i) Amount
      put 0  Into PayEnt_Ded_Totals(#i) Units_Adj
      put 0  Into PayEnt_Ded_Totals(#i) Amount_Adj

      put 0  Into PayEnt_Ern_Totals(#i) PIN_Num
      put '' Into PayEnt_Ern_Totals(#i) PIN_Name
      put 0  Into PayEnt_Ern_Totals(#i) Units
      put 0  Into PayEnt_Ern_Totals(#i) Amount
      put 0  Into PayEnt_Ern_Totals(#i) Units_Adj
      put 0  Into PayEnt_Ern_Totals(#i) Amount_Adj

      Add 1 To #i
   end-While

end-procedure ! Initialize-PayEntity-Array


!***********************************************************************
! Delete-Tmp-Tbl                                                       *
!                                                                      *
! Description:  Delete the data in the Temp tables when report runs to *
!               Success                                                *
!***********************************************************************

begin-procedure Delete-Tmp-Tbl

#ifdef debugw
   Show 'Inside procedure Delete-Tmp-Tbl'
#end-if

#ifndef debugz
begin-Sql
 DELETE FROM PS_GP_RGST_GDE_TMP WHERE PROCESS_INSTANCE = #prcs_process_instance -1
end-Sql

begin-Sql
 DELETE FROM PS_GP_RGST_DTL_TMP WHERE PROCESS_INSTANCE = #prcs_process_instance -1
end-Sql
#end-if

#ifdef debugz
  show 'GP_RGST_GDE_TMP and GP_RGST_DTL_TMP not deleted'
#end-if

end-procedure ! Delete-Tmp-Tbl


!***********************************************************************
! SQCs included in the report                                          *
!                                                                      *
!***********************************************************************

#include 'gprgstrc.sqc'     ! Get run control parameter values, specific to this report
#include 'datemath.sqc'     ! Date conversion procedures
#include 'sqrtrans.sqc'     ! Translate SQR strings to given language
#include 'prcslng.sqc'      ! Replaces getrplng.sqc
#include 'readxlat.sqc'     ! procedure to read values from xlattable
#include 'reset1.sqc'       ! Reset Printer procedureRes
